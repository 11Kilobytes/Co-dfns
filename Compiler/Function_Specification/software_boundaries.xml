<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Software Boundaries</title>
  <para>
    There are two primary sources of user input. The user will
    first call the compiler with a given program to compile, which represents
    the first external input. Secondly, the compiled namespace that is
    created as a result will be called repeatedly and used as its own thing.
    This represents the second potential input to the system. These are
    distinct because the input given to the second, and the behavior that
    is appropriate to it is entirely dependent on the input that is given
    as the program input. Thus, it is impossible to speak directly about
    the kinds of inputs and their responses for the second types of input,
    except very broadly. Instead, the semantics are encoded in the first
    input, and as long as the semantics are preserved in the compiler,
    then it will work as intended.
  </para>
  <para>
    Thus, the main sources of input that will be considered are
    the programs that are given, rather than on the inputs that will be
    given to the programs described or compiled. This may or may not accurately
    reflect how the code is used in practice. Indeed, we normally expected
    to compile a program once and then run it multiple times. However,
    most of the more useful information comes from the program input, rather
    than the input to the compiled program.
  </para>
  <para>
    Finally, the code produced must interact with the DWA interface of the
    Dyalog Interpreter, which is the primary interface to the user.
  </para>
  <table frame="void" rules="rows" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <caption>Summary of External Entities</caption>
    <thead>
      <tr>
        <th>Name</th>
        <th colspan="2">Notes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Source Code</td>
        <td colspan="2">
          Primary input source from the user; specifies semantics
          and intended behavior of module behavior.
        </td>
      </tr>
      <tr>
        <td>Compiled Module</td>
        <td colspan="2">
          Behavior is determined completely by the input source
          code, and cannot be readily specified outside of a specific input
          beyond summary behavior.
        </td>
      </tr>
      <tr>
        <td>DWA Interface</td>
        <td colspan="2">
          The programming API interfacing with the dyalog interpreter which
          enables high-performance interactions between the interpreter and
          the compiler
        </td>
      </tr>
    </tbody>
  </table>
  <para>
    However, the software itself, as complex as it is, requires a decomposition
    of the primary compiler into a set of components that are each specified
    individually. Each component is in charge of a specific task, transforming
    the input it receives into either the output of the compiler or another
    set of stimuli suitable for the next component to receive. In this case
    we have the following compiler passes for specification.
  </para>
  <table frame="void" rules="rows" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <caption>Summary of Passes</caption>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th colspan="3">Notes</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Tokenizer</td>
        <td>Entry</td>
        <td colspan="3">Converts input into tokens for further use</td>
      </tr>
      <tr>
        <td>ResolveVars</td>
        <td>Entry</td>
        <td colspan="3">Identifies binding status and type class for variables</td>
      </tr>
      <tr>
        <td>Parser</td>
        <td>Entry</td>
        <td colspan="3">Parses token stream into an AST</td>
      </tr>
      <tr>
        <td>DropFnUnnamed</td>
        <td>Optimization</td>
        <td colspan="3">Eliminates unnamed functions at the top-level</td>
      </tr>
      <tr>
        <td>DropUnreachable</td>
        <td>Optimization</td>
        <td colspan="3">Drop syntactically unreachable code</td>
      </tr>
      <tr>
        <td>LiftConstants</td>
        <td>Standard</td>
        <td colspan="3">Moves all constants to the top-level</td>
      </tr>
      <tr>
        <td>LiftFunctions</td>
        <td>Standard</td>
        <td colspan="3">Moves all function definitions to the top-level</td>
      </tr>
      <tr>
        <td>FlattenExprs</td>
        <td>Standard</td>
        <td colspan="3">Linearizes expressions into a flat representation</td>
      </tr>
      <tr>
        <td>FuseScalars</td>
        <td>Optimization</td>
        <td colspan="3">Fuse scalar function computations</td>
      </tr>
      <tr>
        <td>AnchorVars</td>
        <td>Standard</td>
        <td colspan="3">Assigns variables slots and environments</td>
      </tr>
      <tr>
        <td>GenCode</td>
        <td>Exit</td>
        <td colspan="3">Generates code for module</td>
      </tr>
    </tbody>
  </table>
</section>
