<itemizedlist spacing="compact"
              xmlns="http://docbook.org/ns/docbook" version="5.0">
  <title>Summary of Analysis</title>
  <listitem>
    <simpara>[NanoPass] Compiler should use a single unified
    grammar</simpara>
  </listitem>
  <listitem>
    <simpara>[NanoPass] Use a formal verification of the
    correctness of each compiler pass</simpara>
  </listitem>
  <listitem>
    <simpara>[NanoPass] Use small, numerous compiler passes rather
    than large, monolithic passes</simpara>
  </listitem>
  <listitem>
    <simpara>[NanoPass] Use aggregate, pure-functional programming
    as much as possible</simpara>
  </listitem>
  <listitem>
    <simpara>[NanoPass] Global state is okay, but should remain
    immutable throughout a given compiler invocation</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] Most of the parsing of Co-Dfns is regular</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] There are specific cases of necessary recursions</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] There are simple, but necessary needs for
    muli-pass refinements of the parsing</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] The parser must use passes to extract type
    information for variables in order to eliminate most
    ambiguity</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] Some instance of ambiguity will remain</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] The grammar will need to take into account
    those instances of ambiguity that cannot be
    eliminated</simpara>
  </listitem>
  <listitem>
    <simpara>[Parsing] Most of the parser should be able to use
    aggregate style programming to express the parsing stages
    clearly</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] Runtime should provide facilities for array class promotion</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] It might make sense to have individual scalar operations in C</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] Scalar functions are probably best implemented in Co-Dfns</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] Most of the primitive functions and
    operators should be implemented in Co-Dfns, not in the
    runtime</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] Implementation language of the core runtime should be C</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] Runtime should take cache behavior into account</simpara>
  </listitem>
  <listitem>
    <simpara>[Runtime] The compiler should try to mitigate the cost of a function call</simpara>
  </listitem>
  <listitem>
    <simpara>
      [Benchmark] Scalar fusion is a significant opportunity for
      performance increase and is the primary bottleneck in Dyalog
      APL interpretation based strategies
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Benchmark] Many optimization transformation conducted by
      hand on Dyalog code had to do with copy avoidance
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Benchmark] Avoiding garbage collection and providing
      predictable allocation behavior is a win
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Benchmark] Cache behavior is one of the key performance
      killers in the existing system, and a core target for
      optimization in the compiler
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Benchmark] A specialized runtime can keep up with other
      code in most cases when the above conditions are not
      affecting the performance.
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Tokenization scheme is suggested by the abstract stimuli chosen
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Recursions inherent in the problem are indicated by the recursive stimuli
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Recursive stimuli suggest a decomposition and grammar for the AST
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Many stimuli lend themselves to aggregate analysis
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Variables and their relation to primitives
      is very complex and should be handled carefully in the AST
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] The AST should allow for easy analysis of
      primitive values, whatever they are named
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Atom-level elements of the AST are suggested
      by the stimuli sets and scheme in general
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Specification] Function expressions are the most
      state-heavy elements due to the number of classes of
      operator behavior and the supporting of nested behavior
    </simpara>
  </listitem>
  <listitem>
    <simpara>
      [Language Reference] The Language Reference should be used
      to provide detailed behavior of the primitives and the
      nature of promotion
    </simpara>
  </listitem>
  <listitem>
    <simpara>[LLVM] Most of the IR is unnecessary for this level of optimizations</simpara>
  </listitem>
  <listitem>
    <simpara>[LLVM] The C interface is the best to use right now</simpara>
  </listitem>
  <listitem>
    <simpara>
      [LLVM] We should have handles to control the prefixes used
      for variables and runtime values to ensure that we can
      self-host our runtime if necessary.
    </simpara>
  </listitem>
</itemizedlist>
