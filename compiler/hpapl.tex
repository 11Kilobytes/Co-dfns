\input ConTeXtLPMacros

\definefontsynonym[APL][Apl385]
\setupbodyfont[xits]
\definefont[tt][APL sa 1]

\setuppapersize[letter][letter]
\setupwhitespace[medium]

\starttext
\startfrontmatter
\title{HPAPL: The Compiler}

\completecontent
\vfill
Copyright $\copyright$ 2012 Aaron W. Hsu $⟨${\tt arcfide@sacrideo.us}$⟩$

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\stopfrontmatter

\startbodymatter
\chapter{Introduction}

This is a first simple attempt to get a small piece of each element of 
the HPAPL compiler working and running.

\chapter{Parsing and Pretty Printing}

This chapter focuses on getting the HPAPL program from strings into 
a reasonable representation, and getting back into a string again. Here 
is the grammar of our language:\index{Language Grammar}

\startformula
\eqalign{
  Assignment &\Rightarrow Variable\ \hbox{\tt ←}\ Number\cr
  Variable   &\Rightarrow \hbox{\tt variable}\cr
  Number     &\Rightarrow \hbox{\tt number}\cr
}
\stopformula   

We are going to try to create a very flexible grammar using the 
paper “Design Patterns for Parsing” by Dung Nguyen, et al. for the 
SIGCSE'05 conference.  

\section{Token Class Hierarchy}

We start with a parent class for talking about 
tokens. Every token has a lexeme value. \index{Design Patterns}
\index{Tokens} Every token also should have some means of executing 
a visitor for that token.  We call this method \cid{Exec}. 

\defchunk{Token Class}
:Class Token
    :Access Public
    ⎕IO←0
    
    :Field Public Instance lexeme
    :Field Private Instance parser←#.TokParser
    /BTEX\chunk{Token Registry}/ETEX
    
    ∇ Make(value vis)
      :Access Public
      :Implements Constructor
      lexeme parser←value vis
    ∇
    
    ∇ R←Parse algo
      :Access Public
      :If parser∊⊃⎕CLASS algo
          (parser ⎕CLASS algo).Parse ⎕THIS
      :Else
          (#.TokParser ⎕CLASS algo).Parse ⎕THIS
      :EndIf 
    ∇
:EndClass
\stopchunk

We also have a basic visitors interface for all tokens, which 
specifies the method \cid{DefaultCase}.

\defchunk{TokParser Interface}
:Interface TokParser
    ∇ R←Parse host
    ∇
:EndInterface
\stopchunk

For each given token, we have a name for that token, as well as a 
regular expression that allows us to recognize those tokens uniquely 
in a document. We want to associate these things together with the 
token class into a registry that allows easy querying about the 
tokens and their properties.  This will be especially useful when 
we want to write a tokenizer.  Thus, in the \cid{Token} class we 
expose an interface for registering tokens and asking questions about 
them.

\defchunk{Token Registry}
:Field Private Shared TokenNames←⍬
:Field Private Shared TokenPats←⍬
:Field Private Shared TokenClasses←⍬

∇ R←Register(class name pat)
  :Access Public Shared
  TokenNames,←⊂name
  TokenPats,←⊂pat
  TokenClasses,←class
  R←0 0⍴⍬
∇

∇ C←ClassByPatNum PN;I
  :Access Public Shared
  C←TokenClasses[PN]
∇

∇ R←Patterns
  :Access Public Shared
  R←TokenPats
∇
\stopchunk

\subsection{Number Token}

Now we want to define a class for each of our token types.  Let's start 
with the \cid{number} token.  Each token class knows how 
to do a few things: it knows how to execute a given visitor to produce 
an AST; it defines an interface for defining visitors for that token 
class; and, it usually will provide a starter base class implementing 
the default methods for chaining visitors.
For more information on Visitors as a design pattern, see 
\in{Appendix}[designpatterns]. \index{Design Patterns+Visitors}

Let's look at how to define \cid{NumberToken}.  Here's a basic skeleton
that does not do the chaining. XXX

\defchunk{NumToken Class}
:Class NumToken: Token
    :Access Public
    
    ∇ Make value
      :Access Public
      :Implements Constructor :Base (value #.NumTokParser)
    ∇
    
    #.Token.Register ⎕THIS 'number' '[0-9]+'
:EndClass
\stopchunk

\defchunk{NumTokParser Interface}
:Interface NumTokParser
    ∇ R←Parse host
    ∇
:EndInterface
\stopchunk

\subsection{Variable Tokens}

\defchunk{VarToken Class}
:Class VarToken: Token
    :Access Public
    
    ∇ Make value
      :Access Public
      :Implements Constructor :Base (value #.VarTokParser)
    ∇
    
    #.Token.Register ⎕THIS 'variable' '[a-zA-Z][a-zA-Z0-9]*'
:EndClass
\stopchunk

\defchunk{VarTokParser Interface}
:Interface VarTokParser
    ∇ R←Parse host
    ∇
:EndInterface
\stopchunk

\subsection{AssignmentToken}

The assignment token is specific to the \cid{←} token. Let's see what 
this one looks like.

\defchunk{AssgnToken Class}
:Class AssgnToken: Token
    :Access Public
    
    ∇ Make value
      :Access Public
      :Implements Constructor :Base ('←' #.AssgnTokParser)
    ∇
    
    #.Token.Register ⎕THIS 'assignment' '←'
:EndClass
\stopchunk

\defchunk{AssgnTokParser Interface}
:Interface AssgnTokParser
    ∇ R←Parse host
    ∇
:EndInterface
\stopchunk

\subsection{Tokenizer}

Now that we have all of our tokens defined, let's move on to defining a 
tokenizer to make use of it.  This is the basic OOP Tokenizer interface, 
though we use PCRE under the hood to do the actual tokenization.

\defchunk{Tokenizer Class}
:Class Tokenizer
    :Access Public

    :Field Private tokens
    :Field Private lasttok←⍬
    
    /BTEX\chunk{Token List Manipulators}/ETEX
    
    ∇ R←MakeToken M;T;L
      T←#.Token.ClassByPatNum M.PatternNum
      F←M.Block[(⊃M.Offsets)+⍳⊃M.Lengths]
      R←⎕NEW T F
    ∇
    
    ∇ Make file;tie
      :Access Public
      :Implements Constructor
      tie←file ⎕NTIE 0
      tokens←(#.Token.Patterns⎕S MakeToken ⍠ 'Mode' 'D') tie
      ⎕NUNTIE tie
    ∇
:EndClass
\stopchunk

A tokenizer provides two public methods, {\tt NextToken} and 
{\tt PutBackToken}, which allow you to get tokens in and out of 
the tokenizer in order.

\defchunk{Token List Manipulators}
∇ R←NextToken
  :Access Public

  :If 0<⍴tokens
      R←lasttok←⊃tokens
      tokens←1↓tokens
  :Else
      R←⍬
  :EndIf
∇

∇ PutBackToken
  :Access Public
  tokens←lasttok,tokens
∇
\stopchunk

\section{Non-terminals, Parse Trees, and their Objects}

With the tokens finished, we can move to the definition of an object 
hierarchy that accurately models the syntax tree that we want to 
define.  We have defined our grammar specifically so that each 
production is in one of the following forms:

1) It is a production with a single terminal token at the end;
2) It is a production of a sequence of terminals and non-terminals; or,
3) It is a production consisting of a set of non-terminals.

The simplest productions to model in our object hierarchy are the 
first kind.  These have no descendants, though they may have a parent 
(“is-a” relationship) or be composed together (“has-a” relationship).

In our grammar, we have only one production, $Number$ which has only 
a single token in it.

\defchunk{ASTNumber Class}
:Class ASTNumber: ASTNode
    :Access Public
    
    :Field Public numtok  ⍝ NumberToken
    
    ∇ Make num
      :Access Public
      :Implements Constructor :Base #.ASTNumVis
      ⎕SIGNAL(~NumberToken∊⊃⎕CLASS num)/11
      numtok←num
    ∇
:EndClass
\stopchunk

\section{Visitor Factories for Parsing}

Rather than defining the visitors explicitly, we use a 
Factory\index{Design Patterns+Factories} for each of the non-terminals, 
which are in charge of producing visitors. More information about the 
Factory design pattern can be found \in{Appendix}[factorypattern]. 

All factories inherit from the {\tt ASTFactory} class.

\defchunk{ASTFactory Class}
:Class ASTFactory
    :Access Public
    
    :Field Private tokenizer
    
    ∇ Make tkz
      :Access Public
      :Implements Constructor
      ⎕SIGNAL(~Tokenizer∊⊃⎕CLASS tkz)/11 ⍝ tkz is a Tokenizer
      tokenizer←tkz
    ∇
    
    ∇ R←NextToken
      :Access Public
      R←tokenizer.NextToken
    ∇
    
    ∇ PutBackToken
      :Access Public
      tokenizer.PutBackToken
    ∇
:EndClass
\stopchunk

In addition, all factories obey the following interface, which is the 
standard protocol for producing visitors.

\defchunk{FactProto Interface}
:Interface FactProto
    ∇ R←MakeVisitor
    ∇
:EndInterface
\stopchunk

Let's talk about the Factories for the simple non-terminals with only 
a single terminal sequence as their target.  This is our only grammar 
production at the moment called $Number$.  It has only a single way 
to progress, and it should implement the {\tt NumTokVisitor} 
interface.  This visitor class looks like this.

\defchunk{NumFact Class}
:Class NumFact: ASTFactory,#.FactProto
    :Access Public
    
    ∇ Make tkz
      :Access Public
      :Implements Constructor :Base tkz
    ∇
    
    :Class NumVis: ,#.NumTokParser,#.TokParser
        :Access Public
        
        ∇ R←NumCase numtok
          :Implements Method #.NumTokParser.Parse
          R←⎕NEW HPAPL.ASTNumber numtok
        ∇
        
        ∇ R←DefaultCase host
          :Implements Method #.TokParser.Parse
          'UNEXPECTED TOKEN'⎕SIGNAL 2
        ∇
    :EndClass
    
    ∇ R←MakeVisitor
      :Implements Method #.FactProto.MakeVisitor
      R←⎕NEW NumVis
    ∇
:EndClass
\stopchunk

\chapter{Outputting C Code}

With the basic syntax above, we can create a simple C program that 
prints out constants.  To support a number of traversals, I have 
encoded a simple Visitor pattern\index{Design Patterns+Visitors}
into the AST Nodes. 

\defchunk{ASTNode Class}
:Class ASTNode
    :Access Public
    :Field Private visitor
    
    ∇ Make vis
      :Access Public
      :Implements Constructor
      visitor←vis
    ∇
    
    ∇ R←Accept host
      :Access Public
      :If visitor∊⊃⎕CLASS host
          R←(visitor ⎕CLASS host).Visit ⎕THIS
      :Else
          R←(#.ASTVis ⎕CLASS host).Visit ⎕THIS
      :EndIf
    ∇
:EndClass
\stopchunk

I also provide Interfaces for each of the AST Production types for 
dispatch, since we are in an untyped system.

\defchunk{ASTVis Interface}
:Interface ASTVis
    ∇R←Visit host
    ∇
:EndInterface
\stopchunk

\defchunk{ASTNumVis Interface}
:Interface ASTNumVis
    ∇R←Visit host
    ∇
:EndInterface
\stopchunk

This allows us to implement the following visitor that renders C output.

\defchunk{OutCVisitor Class}
:Class OutCVisitor: ,#.ASTVis,#.ASTNumVis
    :Access Public
    :Field Private Instance out

    ∇ Make fout
      :Access Public
      :Implements Constructor
      out←fout
    ∇
    
    ∇ R←NumVisit host
      :Implements Method #.ASTNumVis.Visit
      out.println '#include <stdio.h>'
      out.println '#include <stdlib.h>'
      out.println ''
      out.println 'int main(int argc, char *argv[])'
      out.println '{'
      out.println '  int64_t x;'
      out.println '  x = ',host.numtok.lexeme,';'
      out.println '  printf("%d\n", x);'
      out.println '  return 0;'
      out.println '}'
      R←0 0⍴⍬
    ∇
    
    ∇ R←Visit host
      :Implements Method #.ASTVis.Visit
      'UNKNOWN AST NODE'⎕SIGNAL 11
      R←0 0⍴⍬
    ∇
:EndClass
\stopchunk

\chapter{Utilities}

Here are some of the utilities used throughout the rest of the text 
to make our lives easier.

\defchunk{FileOutput Class}
:Class FileOutput
    :Access Public
    :Field Private tie
    
    ∇ Make fname
      :Access Public
      :Implements Constructor
      :Trap 22
          tie←fname ⎕NCREATE 0
      :Else
          tie←fname ⎕NTIE 0
          fname ⎕NERASE tie
          tie←fname ⎕NCREATE 0
      :EndTrap
    ∇
    
    ∇ Close
      :Access Public
      ⎕NUNTIE tie
    ∇
    
    ∇ println data
      :Access Public
      (⎕UCS 'UTF-8' ⎕UCS data) ⎕NAPPEND tie,80
      (⎕UCS 10) ⎕NAPPEND tie,80
    ∇
    
:EndClass
\stopchunk


\stopbodymatter

\startappendices

\chapter[designpatterns]{Design Patterns}

\section[visitorpattern]{Visitor Pattern}

\section[factorypattern]{Factory Pattern}

\stopappendices

\startbackmatter
\completeindex
\stopbackmatter

\stoptext
