== CnC programs ==

=== CnC keyword ===

An HPAPL program is semantically equivalent to a single APL function to the 
outside world. Such a program is defined using the <code>:CnC ... :EndCnC</code> keyword 
pair. The syntax of this keyword is as follows:

<pre>
	:CnC <APL Function Signature>
	  <APL Function Body>
	:EndCnC
</pre>

The semantics of the body of this function are the same as a regular APL
function body with the following differences:

# All variables are single assignment variables;
# All arrays are single assignment arrays; and finally,
# The use of step functions (<nowiki>{{...}}</nowiki>) are permitted.

CnC functions or HPAPL programs (these are synonyms) occupy a completely 
isolated and independent process space from other APL functions, and may not 
interact with or side-effect the state of any other process space, including the 
process space of the Dyalog interpreter.
	
The treatment of single-assignment arrays alters the behavior of some APL 
functions which will be discussed below. We describe the definitions of 
single assignment variables first.

=== Single-assignment property ===

==== Single-assignment variables ====

Variables that are single assignment occupy the normal lexical space of an 
APL function, but they may not be mutated.  That is, they may not be assigned 
more than once.  This does not mean or imply that the arrays that are assigned 
to these values may not be mutated, but that the actual location associated to 
a variable may not be assigned more than once.

A program or process (see below) that attempts to reference a single assignment 
variable will either receive the value associated with that variable if the 
variable has been assigned, or it will block until the variable is assigned.

==== Single-assignment arrays ====

Single-assignment arrays are exactly the same as normal APL arrays with the 
additional note that their fill element is an unassigned single-assignment cell. 
A process may not assign a non-fill element of a single-assignment array.  
A process may assign an element that is a fill element. 
When a slot of an array that was 
previously valued as an empty single-assignment cell, that is, an unassigned 
cell, is assigned, that cell changes to the value to which it is assigned and 
may not be assigned again by any other process.  Attempting to assign to an
already assigned slot of a single-assignment array should signal an error.

A process that attempts to reference the value of a SAA cell that is already 
assigned will receive the value assigned to that cell.  If the cell is in an 
unassigned state, then the process will block until it that cell 
has been assigned, at which point it will receive the value assigned to that 
cell and will unblock, being available again to continue its execution.

=== Altered behavior of APL functions ===

APL functions which do not rely on examining the value contents of their 
arguments may return immediately their results even if the contents of an 
array may not be fully assigned. The resulting array must reflect the values 
that may eventually be assigned to the corresponding cells of the function's 
arguments that produced the resulting array.

All other APL functions that rely on the content of their array arguments to 
compute an answer will block until the necessary cells necessary to compute 
the answer are made available in the argument arrays.

=== Step functions ===

A step function is defined using the following syntax:

<pre>
	{{<D-fn body>}}
</pre>

(Note: "step" has a specific meaning in CnC.)

Typographically, the use of <nowiki>{{}}</nowiki> is provisional;
alternative symbols can be found in http://en.wikipedia.org/wiki/Bracket .

The semantics and syntax of a step function are exactly the same as a normal 
D-fn with the exception that the function returns immediately upon application 
with a promise value that will contain the result of applying the function. 
The equivalent D-fn will be enqueued in the process space as a new process 
instance to compute the result, which will be stored in the returned promise.

Attempting to access the promise value will block until the value is at least 
partially assigned or its shape is known, at which point the SAA will be the 
value of the promise. 

Operators that are given step functions return step functions that return 
SAA arrays of the cells corresponding to the promises associated with the 
semantically implied applications of the given step function.

=== Processes and threads ===

A process in the above description is only a single, serially executed program
or function that can be queued to execute, possibly in parallel, with other 
processes.  It may be stopped and resumed at any arbitrary point in its 
computation.

=== Atomicity ===

We need to talk about what operations are atomic?

=== Optimization opportunities ===

<font color=red>more stuff here</font>

=== Proof of deterministic behavior ===

<font color=red>more stuff here</font>

== Examples ==

Various APL operators are modelled as a way to test the CnC notation.  
All the instances of <nowiki>{{}}</nowiki> below are in the form
<nowiki>{{}}¨</nowiki>, 
but in general <nowiki>{{}}</nowiki> can be used in other ways.

=== Each ===

<pre>
:CnC Z ← {L} (f Each) R
  :if 0=⎕nc 'L'
    Z←{{f ⍵}}¨R
  :else
    Z←L {{⍺ f ⍵}}¨R
  :endif
:EndCnC
</pre>

=== Rank ===

<pre>
:CnC Z ← {L} (f Rank mlr) R

  effrank  ← {0≤⍺:⍺⌊⍴⍴⍵ ⋄ 0⌈⍺+⍴⍴⍵}
  cells    ← {⊂[(-⍺ effrank ⍵)↑⍳⍴⍴⍵]⍵}
  assemble ← {↑((1⍴¨⍨r-⍨⌈/,r←⍴∘⍴¨⍵),¨⍴¨⍵)⍴¨⍵}
  m l r ← ⌽3⍴⌽mlr

  :if 0=⎕nc 'L'
    Z ← assemble {{f ⍵}}¨ (m cells R)
  :else
    Z ← assemble (l cells L) {{⍺ f ⍵}}¨ (r cells R)
  :endif

:EndCnC
</pre>

See also [[User:Roger/Rank_Operator|here]].

In general <code>assemble</code> forces itself to be a synchronization point, 
because it reads the value of every element of its argument.
However, for many primitive and derived functions the rank and shape
of each result cell (the argument of assemble) 
is known and assemble is basically 
an identity function or, at worst, ↑⍵.

=== Key ===

<pre>
:CnC Z ← L (f Key) R

  assert←{⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}

  'rank error'   assert 0<⍴⍴L
  'rank error'   assert 0<⍴⍴R
  'length error' assert (≢L)=(≢R)

  Z ← ↑ (↓ {(∪⍵)∘.=⍵} ⍳⍨ ↓⍪L) {{f ⍺⌿⍵}}¨ ⊂R

:EndCnC
</pre>

See also [[User:Roger/Key_Operator|here]]. ≢⍵ is <i>tally</i> and is ⍬⍴(⍴⍵),1.

=== Scan ===

<pre>
:CnC Z ← (f Scan) R
 ⍝ assume f is associative
  Z←(⍴R)⍴⍬
  Z[0]←R[0]
  ⊣ {{0 ⊣ Z[⍵]←Z[⍵-1] f R[⍵]}}¨ 1↓⍳⍴R
:EndCnC
</pre>

There ought to be a more transparent way of discarding 
the formal result of a D-fn/step function than ⊣ or 0 ⊣.

=== Reduce ===

<pre>
:CnC Z ← (f Reduce) R;T

 ⍝ Aaron's version 0
  T←(⍳⍴R) {{0=⍺: ⊃R ⋄ T[⍺-1] f ⍵}}¨ R
  Z←⊃⌽T

 ⍝ Aarons' version 1
  T←(⊃R),(¯1+⍴R)⍴⍬
  (1↓T)←(1↓⍳⍴R) {{T[⍺-1] f ⍵}}¨ R

 ⍝ Roger's version 0
  T←(⍴R)⍴⍬
  T[0]←⊃R
 ⍝(1↓T)←(¯1↓T) {{⍺ f ⍵}}¨ (1↓R)
  T[1↓⍳⍴R]←T[¯1↓⍳⍴R] {{⍺ f ⍵}}¨ (1↓R)
  Z←⊃⌽T

:EndCnC
</pre>

The construct (1↓T)←(¯1↓T) <nowiki>{{⍺ f ⍵}}</nowiki>¨ (1↓R) raises some issues.
Let T be a SAA.  Is ¯1↓T also a SAA (yes?), and does the ¯1↓T on the right hand side of the ← cause T itself to be updated (how?)?

For the nonce, to reduce the amount of necessary magic, the more verbose T[¯1↓⍳⍴R] may be required.

=== Outer product ===

<pre>
:CnC Z ← L (f OuterProduct) R
  Z ← ((⍴⍴L)⌽⍳(⍴⍴L)+⍴⍴R)⍉((⍴R),⍴L)⍴L) {{⍺ f ⍵}}¨ ((⍴L),⍴R)⍴R
:EndCnC
</pre>

<code>Z←↑L<nowiki>{{⍺ f ⍵}}</nowiki>¨⊂R</code> if f is a scalar dyadic function.

=== Inner product ===

<pre>
:CnC Z ← L (f InnerProduct g) R
  Z ← ↑ (↓L) {{f⌿(↑(⊂1↓⍴⍵)⍴¨⍺) g ⍵}}¨ ⊂R   ⍝ (↑(⊂1↓⍴⍵)⍴¨⍺) g ⍵ ←→ ⍺ g[0] ⍵
:EndCnC
</pre>

This model uses the "row-at-a-time" method 
described [http://www.jsoftware.com/papers/innerproduct/ip.htm here].

=== Game of life ===

Not an operator, but obligatory.

<pre>
:CnC Z←N LIFE O;life;M;T

  T←((N+1),⍴O)⍴⍬
  (0⌷T)←O
  M←3 3    ⍝ Maximum slice size       
                                                                                
  life←{{              
    C←M⌊(⍴O)-⍺             
    S←⍵,¨(⊂⍴O)|(⊂⍺)+¯1+⍳2+C          
    G←1 0 ¯1∘.⊖1 0 ¯1⌽¨⊂T[S]                     
    ⊢ T[(⊂⍵+1),¨(⊂⍺)+⍳C]←1 1↓¯1 ¯1↓⊃1(T[S])∨.∧3 4=+/,G          
  }}                                  
                                                                                
  {} {{⍵+1⊣((⊂M)×⍳⌈(⍴O)÷M)life¨⍵}}⍣N ⊢0                                 
                                                        
  Z←N⌷T

:EndCnC                                               
</pre>

== Random thoughts ==

* Variables still automatically local?
* :SAA list of single-assignment arrays instead of ; list in header?
* :CnCAdvisory advice/declaration to compiler?
* Not aware of outer state of workspace (no ⎕io, no ⎕ml, etc.)?
* Whither ⎕ct?
* Some symbol other than :CnC? ∇ overstruck with something (∆)?
* ⍎ and the like not allowed anywhere in :CnC programs?
* Integer overflow behavior?
* Tail recursion can be executed in parallel! (Says Aaron, 2012-06-07 16:49.)

== References ==

* [http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/ Intel CnC page]
* [https://wiki.rice.edu/confluence/download/attachments/5210519/cnc_encyc_TR.pdf Introduction to CnC]
* [http://habanero.rice.edu/cnc.html Rice Habanero CnC Project]
* [http://code.google.com/p/qthreads/ qthreads library]
* [http://gasnet.cs.berkeley.edu/ GASNet]
