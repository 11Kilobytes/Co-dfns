<?xml version="1.0" encoding="utf-8" ?>

<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Engineering Change Log</title>
    <author><personname>Aaron W. Hsu</personname></author>
    <date>Saturday, July 20th, 2013</date>
  </info>
  <simpara>
    This document records and tracks all proposed engineering changes that 
    occur during development. An engineering change is a change proposed 
    or identified as desirable during one process that affects other work 
    products not part of the delivery of the current process. This document 
    tracks these proposed changes, their evaluation, analysis, and the 
    eventual resolution of these changes. 
  </simpara>
  <table frame="void" rules="rows">
    <caption>Summary of Changes</caption>
    <thead>
      <tr>
        <th>ID</th>
        <th colspan="2">Date</th>
        <th colspan="5">Summary</th>
        <th colspan="2">Resolution</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td colspan="2">2013-07-21</td>
        <td colspan="5">Update <function>Obj</function> and <function>Fix</function> Requirements</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>2</td>
        <td colspan="2">2013-07-23</td>
        <td colspan="5">Update class of valid input programs</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>3</td>
        <td colspan="2">2013-07-23</td>
        <td colspan="5">Add Dyalog Reference to Reuse Analysis</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>4</td>
        <td colspan="2">2013-07-29</td>
        <td colspan="5">Clarify exported bindings</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>5</td>
        <td colspan="2">2013-08-21</td>
        <td colspan="5">Cleanup System Requirements</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>6</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Fix FFI Declaration</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>7</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Fix missing definition</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>8</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Incorrect use of Scan</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>9</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Malformed result from Tokenize</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>10</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Missing assignment</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>11</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Incorrect comment identification</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>12</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Splitting on spaces fails for empty strings</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>13</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Domain error when wrapping tokens</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>14</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">SYNTAX ERROR on valid input</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>15</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">RANK ERROR on Parse return</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>16</td>
        <td colspan="2">2013-10-09</td>
        <td colspan="5">Parse accepts invalid input</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>17</td>
        <td colspan="2">2013-11-27</td>
        <td colspan="5">Redundancy in Sequence Enumeration</td>
        <td colspan="2">Pending</td>
      </tr>
      <tr>
        <td>18</td>
        <td colspan="2">2013-12-14</td>
        <td colspan="5">Incorrect arity for <function>Int4Type</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>19</td>
        <td colspan="2">2013-12-14</td>
        <td colspan="5">Incorrect rank and shape for scalars</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>20</td>
        <td colspan="2">2013-12-16</td>
        <td colspan="5">Unnecessary Stimuli in Top-Level</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>21</td>
        <td colspan="2">2013-12-16</td>
        <td colspan="5">Alter Fnf response</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>22</td>
        <td colspan="2">2013-12-20</td>
        <td colspan="5">Remove uses of INT4</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>23</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix Index Errors in <function>ParseExpr</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>24</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix <function>DropUnmd</function> for empty namespace</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>25</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix <function>DropUnmd</function> for empty namespace</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>26</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix <function>ErrorMessage</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>27</td>
        <td colspan="2">2013-12-24</td>
        <td colspan="5">Specify Valid Triple for Module</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>28</td>
        <td colspan="2">2013-12-26</td>
        <td colspan="5">Module to Namespace Generation Fails</td>
        <td colspan="2">Pending</td>
      </tr>
      <tr>
        <td>29</td>
        <td colspan="2">2013-12-26</td>
        <td colspan="5">Correct handling of muli-named functions</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>30</td>
        <td colspan="2">2014-01-24</td>
        <td colspan="5">Incorrect handling of input verification</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>31</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Incorrect handling of null return value for <function>⎕SIGNAL</function> in <function>Parse</function>.</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>32</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Incorrect use of <function>⊃</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>33</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Missing return value in <function>ParseFunc</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>34</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Missing return value in <function>ParseFuncExpr</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>35</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Condition parsing does not have right depths</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>36</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">ParseTopLine signals a SYNTAX ERROR when it should signal a VALUE ERROR.</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>37</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Improve handling of nested variable creating during test case generation</td>
        <td colspan="2">Pending</td>
      </tr>
      <tr>
        <td>38</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">Functions are missing the <type>Function</type> nodes.</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>39</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">RANK ERROR due to <function>⊃</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>40</td>
        <td colspan="2">2014-01-27</td>
        <td colspan="5">SYNTAX ERROR in <function>ParseLineVar[62]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>41</td>
        <td colspan="2">2014-01-31</td>
        <td colspan="5">Correct handling of shy results</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>42</td>
        <td colspan="2">2014-01-31</td>
        <td colspan="5">Incorrect handling of empty namespace</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>43</td>
        <td colspan="2">2014-01-31</td>
        <td colspan="5">LENGTH ERROR in <function>GenCond[8]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>44</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">LENGTH ERROR in <function>Parse[17]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>45</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">LENGTH ERROR in <function>Parse[21]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>46</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">LENGTH ERROR in <function>Parse[23]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>47</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">LENGTH ERROR in <function>Parse[24]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>48</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">VALUE ERROR in <function>LiftConsts[5]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>49</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">SYNTAX ERROR in <function>AnchorVars[6]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>50</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">LENGTH ERROR in <function>LiftFuncs[19]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>51</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">DOMAIN ERROR in <function>ConvPrims[2]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>52</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">VALUE ERROR in <function>GenInit[24]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>53</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">System error, crash</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>54</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">DOMAIN ERROR in <function>ModToNS[27]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>55</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">VALUE ERROR in <function>Fix[9]</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>56</td>
        <td colspan="2">2014-03-26</td>
        <td colspan="5">System error, crash</td>
        <td colspan="2">Applied</td>
      </tr>
    </tbody>
  </table>
  <orderedlist>
    <title>Change Description and Analysis</title>
    <?dbfo label-width="0.25in"?>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          During Functional Specification, the <function>Obj</function> and <function>Fix</function>
          functions were discovered to have a number of missing or undesirable requirement 
          implications. The following changes are suggested:
        </para>
      </formalpara>
      <orderedlist>
        <listitem>
          <simpara>
            Amend Requirement 16 to require only implementing the monadic interface of 
            the <function>⎕FIX</function> function.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            An additional requirement should state that the <function>Obj</function> function 
            will produce a shared object in the given file name that has the same semantics 
            and function bindings as defined in the namespace.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Requirements should be added to clarify the error reporting in the case of files 
            that already exist when handling <function>Obj</function> output.
          </simpara>
        </listitem>
      </orderedlist>
      <formalpara>
        <title>Analysis</title>
        <para>
          The above requirements do not change the semantics of the requirements, 
          and only refine them. They meet the intention of the project and should 
          be implemented. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Functional specification revealed a possible ambiguity in the description of 
          requirement 21. Recommend the following:
        </para>
      </formalpara>
      <orderedlist>
        <listitem>
          <simpara>
            That requirement 21 be changed to clearly indicate that only fully 
            closed namespaces are accepted; that is, only accept namespaces with 
            no free variable references.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Additionally, a new requirement 
            prohibiting the use of the <literal>⌶</literal>-beam should be included.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A new requirement prohibiting the use of the <function>⍎</function>
            function should be added. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Requirement 4 should be amended to specify D-fns, rather than Co-Dfns 
            programs.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            The new additions to the D-fns languages introduced by Co-Dfns should 
            be added and fully defined.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            It should be remarked that no assignment which changes the overall 
            nameclass of a variable is allowed. 
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A requirement detailing the unsupported operators should be added. 
            These operators include the <function>&amp;</function> operator as well as 
            the <function>⍠</function> operator.
          </simpara>
        </listitem>
      </orderedlist>
      <formalpara>
        <title>Analysis</title>
        <para>
          No semantic change is introduced based on the intention of the design, and 
          are at an early enough stage so as to not affect more than the functional 
          specification, so this should be implemented.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The primary specification for the D-fns language appears in the Dyalog
          <citetitle>Programmer's Guide and Language Reference</citetitle>. This 
          should be explicitly marked as the reference document for the semantics of 
          the D-fns language.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This clarifies a number of implied assumptions on the part of the specifications 
          and development plans, and should be included.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Clarify the exported functions that are produced by the compiler in the exported 
          namespace to indicate that currently, only global array variables and 
          functions will be exported. Operators and other such things will not. This 
          should be entered into the requirements document.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This is a semantic change from the existing requirements, but does not affect 
          anything more than the functional specification, which has been amended to 
          include these adjustments anyways. Additionally, it does not add any 
          complexity, but simplifies the technical implemenation burden. The only visible 
          change to the user is the removal of operators from the public interface, which 
          is acceptable. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Changes in the interface design are suggested by function specification. 
          It is unnecessary to have the object functionality separate from the fix 
          function. Additionally, analysis of the way that LLVM works indicates that 
          requirement #32 is not feasible, and will not be adequately implemented.
          A new requirement is suggested to indicate failures that may originate from 
          the LLVM Subsystem.
          This requires the following changes:
        </para>
      </formalpara>
      <orderedlist>
        <listitem>
          <simpara>
            Change requirements 9, 16, 17, 18, 29, 30, 31, and 42 accordingly.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Eliminate requirements 19, 20, and 32.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Add a new requirement that states an LLVM error will signal an <literal>INTERNAL ERROR</literal>.
          </simpara>
        </listitem>
      </orderedlist>
      <formalpara>
        <title>Analysis</title>
        <para>
          The change does not alter the functionality or intention of the compiler, but it 
          does create a simplified interface and is worth doing. It reduces workload later on.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          An error in the declaration of an FFI function was discovered during certification.
          This must be adjusted before further certification can proceed.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>ValidateInput</function> function is not defined. It should either be 
          defined or it should be replaced.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function gives a length error when trying to 
          split comments and code.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The comment splitting code is the following line:
        </para>
      </formalpara>
      <programlisting>T C←⊂[0]↑2↑¨(1,¨1↓¨(~∨\¨0,¨1↓¨¯1⌽¨A)∧A←1↓¨'⍝'=A)⊂¨A</programlisting>
      <simpara>
        This code assumes that the array being scanned is always the same length as the 
        array itself. However, this is not the case when we deal with an empty array.
        The <literal>0,</literal> catenation will mean that we have an array of at least 
        length 1. In this case, the above expression will not work.
      </simpara>
      <simpara>
        This problem has wide ranging consequences because it is very likely that a given 
        namespace script will have blank lines in it, which will trigger this problem. 
        This function is overly complicated anyways, and can be simplified by a proper 
        use of the <literal>⍳</literal> function. We can use the following code instead:
      </simpara>
      <programlisting>I←(⊂A)⍳¨'⍝' ⋄ T←I↑¨A ⋄ C←I↓¨A</programlisting>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function gives a malformed result.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This is due to an unnecessarily complex set of code. It is difficult to 
          verify this code, and it should not have made it through. Replacing the 
          code with simpler code that can be proven should fix the malformation 
          result.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function gives an incomplete result.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          There is a missing assignment in the <function>Tokenize</function> function.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function identifies comments incorrectly.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The code that finds the index incorrectly treats the non-scalar set of 
          lines as a scalar, leading to a single index value that cannot be correct.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function fails to split in cases where the 
          reduction fails because of too few elements, namely, empty vectors.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This reveals further problems with this first expression. It fails to 
          clearly split, and it also leaves the spaces around to be cleaned up later 
          or to introduce faulty tokens in the future.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Tokenize</function> function fails with a DOMAIN ERROR when 
          it tries to wrap tokens around empty lines.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Apparently you cannot catenate reduce on an empty vector of any sort. 
          This was news to me. The easiest way to fix this is to insert a check 
          that handles this special case.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Parse</function> function fails with a SYNTAX ERROR on 
          valid input.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The problem is the assumption of a nested result in this code for 
          doing the comparison, but in reality having a flat array:
        </para>
      </formalpara>
      <programlisting>NS←(⊃N),⊃⌽N←(¯1⌽T∊⊂'name')/T←,↑(⍵[;1]∊⊂'Token')/⍵[;3]
      ':Namespace' ':EndNamespace'≢NS:⎕SIGNAL 2</programlisting>
      <simpara>
        This is trivially fixed by unifying the types.
      </simpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Parse</function> function does not return two elements.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The function <function>Parse</function> is supposed to return both 
          and AST and the Names that are bound at the top-level, but it does 
          not do this currently.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>Parse</function> function accepts more than one 
          Nss and one Nse stimuli.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This happens because there is no check for it, while there is a 
          check to ensure that the first and last stimuli are Nss and Nse 
          respectively. Inserting this check should fix this issue.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Usage Modeling has identified a number of potential redundancies 
          in the Sequence Enumeration. Recommendation is to remove 
          these redundancies to simplify the <citetitle>Function Specification</citetitle>.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Analysis pending.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Statistical testing encountered a type error in the implementation 
          of <function>Int4Type</function> which was implemented in the 
          <classname>CoDfns</classname> namespace during the environment 
          conversion to UNIX. It should not be a dfns, but should be a niladic 
          function.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Change introduced during environment conversion was incorrect 
          and should be rectified immediately.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          In the LLVM output, the V9 rank is 1, rather than 0, and the 
          shape contains a one element vector containing 1. This is 
          incorrect for a single scalar value.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The coding of the <function>GenConst</function> function 
          is not sufficiently robust and requires reworking. In
          particular, the initial extraction of the expression values
          did not take into account the appropriate shape of the
          expression. These effects are localized and contained to the
          <function>GenConst</function> function, and do not affect
          any other elements or problems. 
        </para>
      </formalpara>
      <simpara>
        The cause of this problem can be traced at least partially
        back to having a function specification that is unable to
        express these precise details about the nature of each
        conversion. Adapting the function specification to include
        more information like this would like improve the ability to
        catch these errors earlier. Technically, however, these
        elements are clearly specified in the <citetitle>Programming
        Language Reference</citetitle> from Dyalog.
      </simpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <constant>Fnd</constant> and <constant>Fnm</constant>
          stimuli do not have any real purpose in the top-level
          enumeration and are redundant, they should be removed from
          the stimuli set.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This redundancy is demonstrated by the fact that these
          stimuli do not show up in the Canonical sequences at all, as
          well as being subsumed in all cases by the
          <constant>Fe</constant> stimuli, which itself has direct
          support for the <constant>Fnd</constant> and
          <constant>Fnm</constant> stimuli. This change has minimal
          impact on the rest of the system, as they are not mentioned
          directly anywhere else, and are already subsumed in the rest
          of the documentation. Thus, it is safe to remove them at any
          time. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Morten Kromberg has suggested that we do not need to follow the standard 
          APL behavior when handling the Fnf behavior, and we can instead follow 
          the method that we see in most other compilers. That is, we can just 
          overwrite the existing file rather than signalling an error. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This will require a small change in the Function Specification to handle 
          things, which will require changing the enumeration and subsequently 
          the Black Box Definitions. This will also require some code changes
          in the <filename>CoDfns.dyalog</filename> namespace script. Current 
          Usage Specification does not need to be changed, and the main models 
          for Increment 3 can be adjusted to handle this change. Previous increments 
          did not or were not sensitive to this change and do not need to be 
          recertified. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          There is little support for the <type>uint4_t</type> in
          compilers, so we should remove its use from the array and
          the compiler output. This will simplify the definition of
          the compiler in the shared object runtime. This will fix the
          compiler failure in building this shared object.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This will require some changes to the <citetitle>Software
          Architecture</citetitle> and subsequently to the
          <filename>CoDfns.dyalog</filename> namespace, which will
          have to adjust its use of the int4 type in various
          places. Other than this, it is not used elsewhere and will
          not affect other documents.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The following two programs trigger <symbol>INDEX ERROR</symbol> messages 
          in the compiler.
        </para>
      </formalpara>
      <programlisting linenumbering="numbered">:Namespace
 V1
:EndNamespace
</programlisting>
      <para>
        Signals an error with the following stack trace:
      </para>
      <screen>#.CoDfns.ParseExpr[21]*
#.CoDfns.ParseLine[51]
/
#.CoDfns.Parse[145]
#.CoDfns.Compile[2]
#.CoDfns.Fix[26]</screen>
      <para>
        And the following program gives a slightly different index error.
      </para>
      <programlisting linenumbering="numbered">:Namespace
 V1←
:EndNamespace
</programlisting>
      <para>
        Which errors at ParseExpr[19] with this stack trace:
      </para>
      <screen>#.CoDfns.ParseExpr[19]*
#.CoDfns.ParseExpr[24]
#.CoDfns.ParseLine[51]
/
#.CoDfns.Parse[145]
#.CoDfns.Compile[2]
#.CoDfns.Fix[26]</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          In the first case, we incorrectly assume that we will have
          at least two tokens in our token matrix when parsing for an
          expression. If there is only a single token in the token
          list that we are parsing, and that single token is a
          variable, then the first condition checks the second token
          to determing whether it is an assignment or not. However,
          since there is no second token, this fails with an
          <symbol>INDEX ERROR</symbol>. A simple check before this
          suffices to fix this oversight.
        </para>
      </formalpara>
      <para>
        The same thing happens with the second example, but a little
        earlier. If we have an assignment to a variable that has no
        expression on the right hand side of the assignment, then the
        <function>ParseExpr</function> function will be called without
        any tokens in it. Previously, we assumed that we would have at
        least one token in the matrix, but now we need to check to
        ensure that there is at least one token before checking
        whether that token is a variable on the 19th line of the
        function body.
      </para>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          We get a domain error in <function>DropUnmd</function> when
          trying to handle an empty namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <function>DropUnmd</function> function is called in the
          compiler right after the <function>KillLines</function>
          function. In the case of an empty namespace, this will
          result in a tree with no depth-1 subtrees. This will result
          in attempting to execute a first-axis catenate against an 
          empty array with no identity element by default. 
        </para>
      </formalpara>
      <para>
        The appropriate fix is to ensure that the catenation never
        receives and empty vector of sub-trees. We manually insert an
        empty AST node to the head of the vector coming in, which will
        ensure a non-zero vector, but will not affect the results of
        any of the catenations in the line. 
      </para>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>LiftConsts</function> as a domain error when
          handling an empty namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The root cause for this is the invalid output produced by
          the <function>DropUnmd</function> function, because of a
          misplaced scalar enclosure in the second line of that
          function. Removing the scalar enclosure will fix this.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The output of <function>ErrorMessage</function> does not
          seem to work right in that it gives only a single character
          response. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This is due to a misunderstanding in the way that the
          <function>cstring</function> function works. The function
          will actually return a vector of the characters in the
          string, rather than a single one element vector containing
          said string. This is an easy fix to apply.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When compiling an LLVM IR represented as a module, you must
          specify a target triple, which indicates the kernel,
          environment, and the processor architecture to be targeted
          during the compilation. This holds true especially when
          doing the JIT compilation. The current compiler does not do
          this, and thus fails any test to produce a valid namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The LLVM system has a complicated set of targets and the way
          that they work. I am not sure exactly how this is going to
          work, so it will take some experimentation. It appears that
          the target system works by requiring you to first initialize
          the set of targets that you want to support. I am not sure
          whether this needs to be done before or after module
          creation. 
        </para>
      </formalpara>
      <simpara>
        After the initialization of the modules, it appears that you
        can obtain a triple for the appropriate module that you want
        to work with and then use that triple when you JIT compile the
        module. 
      </simpara>
      <simpara>
        The eventual solution that was discovered for this particular
        problem is actually a combination of things. Firstly, the
        native target triple can be obtained using the
        <function>llvm-config(1)</function> program by using the
        <userinput>--host-target</userinput> option. Once this triple
        is identified, the LLVM system must still be initialized to
        use this target. 
      </simpara>
      <simpara>
        To initialize the target, the normal system would run the
        <function>LLVMInitializeNativeTarget()</function> function,
        but this function is declared <type>inline</type> in the
        headers, which makes it not possible to call from the shared
        object file that we are using. Instead, the three functions
        that it invokes must be manually called. Namely, the following
        set of functions calls will initialize the native target if
        that target is <constant>X86</constant>.
      </simpara>
      <programlisting>LLVMInitializeX86TargetInfo();
LLVMInitializeX86Target();
LLVMInitializeX86TargetMC();</programlisting>
      <simpara>
        Once this initialize is complete, the triple for the native
        host can be used with the <function>LLVMSetTarget()</function>
        function to set the target of the module. Unfortunately, I
        could not find documentation on how to do this anywhere, and I
        could barely find some StackOverflow postings that showed how
        this would have worked on a normal system. A good deal of
        experimentation was required to understand how to
        appropriately apply this fix. The current system uses to
        global values, <constant>Target</constant> and
        <constant>TargetTriple</constant> to store the current native
        settings, which are <literal>X86</literal> and
        <literal>x86_64-slackware-linux-gnu</literal> for the current
        development platform. 
      </simpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Module to Namespace generation appears to fail for a variety
          of reasons, most of the appearing to be syntactic
          ambiguities. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          After spending some thorough experimentation with this, the
          root of the problem is a clear issue with the way that dfns
          appear to interact with the <literal>⍎</literal> (Execute)
          function. It is not clear why this is happening, or how to
          fix it yet. The issue is currently being farmed out to
          Dyalog to identify what the core issue could be.
        </para>
      </formalpara>
      <simpara>
        To allow for further testing, it was decided to abandon the
        Namespace generation until further information from Dyalog
        arrives. Statistical testing will take place without the
        namespace generation aspect.
      </simpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Adapt the handling of the Generation of multi-named
          functions during the <function>GenLLVM</function> pass to
          handle the multiple names, which currently it fails with a
          <symbol>VALUE ERROR</symbol>. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The cause of this problem is that we had a shy result being
          returned by the <function>GenFunc</function> function, which
          apparently does not work well in places where a normal value
          is expected. This appeared to work during our initial
          investigations, but removing the shy value fixes this
          problem. Some investigation is worthwhile, so this is being
          sent to Dyalog to understand better why this error occurs. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When the input to the compiler is not a vector, then the
          shapes do not match up in the input verification of the Fix
          function and a <symbol>LENGTH ERROR</symbol> occurs.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          In the following code line that triggers this error:
        </para>
      </formalpara>
      <programlisting>~((,1)≡⍴⍴⍵)∧(∧/1≥⊃∘⍴∘⍴¨⍵)∧(∧/⊃,/' '=⊃∘(0∘⍴)∘⊂¨⍵):⎕SIGNAL 11</programlisting>
      <para>
        The shape of the conditional depends on the shape of the
        <varname>⍵</varname> value, which shouldn't be the
        case. Instead, this needs to be a scalar or 1 element vector
        independent of <varname>⍵</varname>.
      </para>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          In <function>Parse[128]</function>, the
          <function>⎕SIGNAL</function> result is null and no code
          handles that empty result value.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          In order to encapsulate the signal, we use the same
          technique as used in <function>do</function> by enclosing
          the signalling in an execute and returning the value of the
          signal. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          There is a RANK ERROR in <function>ParseFunc[12]</function>.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          I'm being stupid and using <literal>0 1⊃⍵</literal> instead
          of <literal>⊃0 1⌷⍵</literal>.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>ParseFunc</function> is not returning three values in the first line.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Add the obvious third return value to <function>ParseFunc</function>.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <function>ParseFuncExpr</function> is not returning four values in the first line.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Add the obvious missing value to <function>ParseFuncExpr</function>.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When parsing a condition, such as <literal>{ V3← 99 : 24 ⋄ }</literal>, the 
          <classname>Condition</classname> node will not have any children, because the 
          children are put at a depth one higher than they should be.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          In the <function>ParseCond</function> function, the two calls to <function>ParseExpr</function>
          will return nodes assumed to be at the same depth as the condition node, since the tokens 
          are at the same depth. Since there is actually an additional nesting level, we need to 
          put the (potentially) two nodes as children by increasing each of their depths by one. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When parsing something like <literal>{Vu}</literal> where <varname>Vu</varname> 
          is not bound, <function>ParseTopLine</function> signals a SYNTAX ERROR instead of 
          a VALUE ERROR. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This is because of the way handling of <classname>Expression</classname> nodes 
          occurs inside of the <function>ParseExpr</function> function. Specifically, it requires 
          that every expression be either an assignment to a name or a numeric constant.
          Because we rely on the error result of <function>ParseExpr</function> for our 
          error to report during states 3 and 4 of the <function>ParseFunc</function> 
          function, this causes the SYNTAX ERROR instead of the VALUE ERROR. This can be 
          considered okay for now.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The current <classname>Stimuli</classname> namespace does not handle the generation of variable 
          names in a clever way, and it has no concept of the scoping rules for nested scopes of any kind. 
          Improve this so that the generators can generate more useful and reliable code out of the 
          sequences.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When parsing a function expression, the function expression node and the body of the 
          function both show up, but the <type>Function</type> node does not. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This happens because at <function>ParseFunc[16]</function>
          we use <literal>(Fd&lt;D)×</literal> to strip off the
          <type>Function</type> node, while expecting it to be there
          at the end further down in the code. This is wrong. Removing
          the above snippet of code fixes this problem, and only
          includes the additional <type>Function</type> node, not any
          additional, unwanted nodes.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          There is a RANK ERROR in <function>ParseNamedBnd[40]</function>.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          I'm being stupid and using <literal>0 1⊃⍵</literal> instead
          of <literal>⊃0 1⌷⍵</literal>.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          In the call to <function>ParseNamedBnd</function> in
          <function>ParseLineVar[62]</function>, the call returns with
          a syntax error. Here are some important data elements:
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          When dealing with a nested set of assignments <literal>Vu ←
          Vfo ← Vu ← Fe</literal>, the
          <function>ParseLineVar</function> function should keep track
          of the nameclass of the assignment.  However, in the current
          code, it does not. Instead, it will only pass the correct
          type class value to <function>ParseNamedBnd</function> if it
          was the last seen variable. In other words, we do not ensure
          that all three values match class, and not just the most
          recently seen.  Fixing this in the full will require
          threading the type class back through the set of recursive
          calls to <function>ParseLineVar</function>, but the current
          work around is to always pass a type of 2, since we know
          that this will be the only type that we support at the
          moment.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The current version of the compiler does not handle shy results 
          correctly.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <citetitle>Increment Construction Plan</citetitle> details 
          that shy results should happen around Increment 7. However, 
          a reasonable semantics should exist for shy results before that. 
          In particular, shy results should just return as regular results, 
          rather than returning nothing at all. Currently, the situation 
          is even worse, because the compiler incorrectly generates an 
          empty body, which is not permitted in the LLVM IR.
        </para>
      </formalpara>
      <para>
        To improve this situation, we should adapt the compiler so that 
        shy results are at the very least returned, rather than discarded. 
        We should also ensure that we do not have an empty body as we 
        currently do in the IR.
      </para>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          When given an empty namespace, there is an INDEX ERROR in 
          <function>DropUnreached[9]</function>. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          An empty namespace will have no children, leading to an empty 
          array in <function>DropUnreached[9]</function>. To fix this, 
          we will insert a short circuit of the code when there are no 
          children.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          There is a LENGTH ERROR in <function>GenCond[8]</function>.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <function>BuildLoad</function> function requires three 
          arguments, not two; this line is missing the <varname>bldr</varname>
          variable.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A LENGTH ERROR in <function>Parse[17]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>Parse[17] fd←+\0,¯1↓tm\fm ⍝ Nesting depths of functions</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          In <function>Parse[15]</function> the use of <function>⌷</function> 
          receives an incorrect input.
        </para>
      </formalpara>
      <programlisting>fm←1 ¯1 0⌷⍨(,¨'{}')⍳'name'Prop tm⌿ns ⍝ Map of brackets, } ¯1, { 1, else 0</programlisting>
      <para>
        The result of the <function>⍳</function> is a vector of indices, and not 
        a single index. This means we need to use <literal>⊃¨⊂</literal> instead.
        So to fix this we replace <function>Parse[15]</function> with the following.
      </para>
      <programlisting>fm←(,¨'{}')⍳'name'Prop tm⌿ns ⍝ Class of each token name
fm←fm⊃¨⊂1 ¯1 0               ⍝ Convert } → ¯1 ; { → 1 ; else → 0</programlisting>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A LENGTH ERROR in <function>Parse[21]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>Parse[21] ((¯1⌽cm)/ns)←cm/ns ⍝ Shift all children down by one</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          The use of <function>/</function> applies the filter along the 
          wrong axis. Instead, the <function>⌿</function> filter should be 
          used instead. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A LENGTH ERROR in <function>Parse[23]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>Parse[23] fd←⍪0⌷⍉fm⌿ns ⍝ Depth of each function node</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <varname>fm</varname> is not expanded to the right size at 
          this point, though we do expand it once a few lines above. 
          The solution is to save the result of expanding the function 
          mask when we do it to compute the <varname>fd</varname> 
          function. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A LENGTH ERROR in <function>Parse[24]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>Parse[24] (fm⌿ns)←fd,⊂'Function',⊂'',⊂fa ⍝ Replace { token with Fn node</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          There is an obvious syntax error here with the use of 
          <function>⊂</function> and <function>,</function> . 
          Instead, we can make the following replacement.
        </para>
      </formalpara>
      <programlisting>fd,⊂'Function',⊂'',⊂fa ←→ ((fd,⊂'Function'),⊂''),⊂fa</programlisting>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A VALUE ERROR in <function>LiftConsts[5]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>LiftConsts[5] v←mkv¨⍳+/s←2&lt;/0,l ⍝ Variables we need; start of literals</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          The binding switched from <function>MkV</function> to 
          <function>mkv</function> but the transition didn't make it 
          it to the definition site, so changing the name will fix this.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A SYNTAX ERROR in <function>AnchorVars[6]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>AnchorVars[6] nm←⍪⊃,/(⊂0⍴⊂''),Split¨nm ⍝ Split names and prepare</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <function>Split</function> is missing a set of parentheses 
          to ensure that the binding of the left argument occurs as 
          the last thing. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A LENGTH ERROR in <function>LiftFuncs[19]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>LiftFuncs[19] (1↑⍵)⍪⊃⍪/0 vis/z ⍝ Nodes just the same</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          In the above code, <literal>0 vis/z</literal> will always be a 
          scalar, which means that we need to extract out the appropriate 
          values from there before applying the catenation reduction. 
          Adding a <function>⊃</function> fixes this problem. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A DOMAIN ERROR in <function>ConvPrims[2]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>ConvPrims[2] pn←⊃,/'name'Prop pm⌿⍵ ⍝ Primitive names</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          When <varname>pm⌿⍵</varname> is an empty AST, then 
          <literal>'name'Prop pm⌿⍵</literal> will be an empty list, which 
          is a domain error for a catenation reduction. Instead, we can 
          put an initial seed value to ensure that the reduction contains 
          at least one value. In this case the seed is 
          <literal>(,'')</literal> which must be attached as the first 
          or last element in the vector.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A VALUE ERROR in <function>GenInit[24]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>GenInit[24] _←{ ⍝ Handle each global expr in turn</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          When doing the initialization generation, there might not be 
          any expressions to initialize, in which case the main iteration 
          over each of these values will not work correctly, and an 
          empty value will be the return result, leading to this error. 
          Checking to ensure that we have data instead of a fill argument 
          test will help this.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A complete system crash occurs on an empty namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <function>clean_env</function> is not declared in the 
          module, giving a null return result that causes a crash 
          when passed unchecked to the <function>BuildCall</function>
          function. We add a check to handle this null case so that 
          it does not result in a crash. Additionally, we declare 
          the clean_env function as a part of the runtime. Furthermore, 
          an additional error in the way that the environments are 
          cleaned up here is fixed, by ensuring that the size stored 
          for the environment is actually a value reference, and not 
          an APL value. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A DOMAIN ERROR in <function>ModToNS[27]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>ModToNS[27] c fpv←FindFunction ee ⍵ 1 ⍝ Get function from LLVM Module</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          The above function has a domain error because <varname>⍵</varname> 
          is <literal>0</literal> rather than a string. This can be traced back 
          to the fill argument of an empty (name, type) environment, which 
          the <function>Parse</function> function handles incorrectly. It uses 
          <literal>⍬</literal> instead of <varname>MtNTE</varname>. This causes 
          an incorrect detection of the empty cases in the <function>Add</function>
          function of <function>ModToNS</function> which in turn causes 
          <function>FindFunction</function> to be called on bad data. The fix is 
          to use the appropriate seed value for an empty (name, type) environment. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A VALUE ERROR in <function>Fix[9]</function> occurs with 
          the following message.
        </para>
      </formalpara>
      <screen>Fix[9] ''≡Obj:ns ⍝ No optional object file output</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          This is a simple mis-capitalization.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          A complete system crash occurs on an empty namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The return on <function>GenInit</function> was incorrectly passing 
          and useless environment. In the GenInit function, we don't actually 
          have any interesting elements that need to be returned, so we can 
          just do a direct return and eliminate the need to make the call 
          to <function>MkRet</function>.
        </para>
      </formalpara>
    </listitem>
  </orderedlist>
</article>
