  <section xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Analysis: Performance Benchmarks</title>
    <simpara>
      A series of benchmarks, mostly taken from the NAS Parallel
      Benchmarks suite were implemented in Dyalog APL.  These were
      compared against the reference versions in Fortran and C
      provided by the NPB. Analysis of these benchmarks verified
      some initial expectations of the compiler, but also revealed
      that certain issues would not be relevant.
    </simpara>
    <simpara>
      In particular, the benchmarks revealed that cache behavior
      played a very significant role in the relative performance of
      the two systems. Where the cache behavior of Dyalog was not
      friendly, then we saw 10 times or worse slow downs compared to
      the reference implementations. However, where this was not an
      issue, the Dyalog system could keep up with the reference
      implementations nearly tit for tat, though in some versions it
      was around 2 or 3 times slower.
    </simpara>
    <simpara>
      The use of specific, optimized runtime elements gets good
      results in many cases, but the case of strings of scalar
      functions on large arrays is a clear bottleneck for the Dyalog
      interpreter which likely cannot be easily handled using just
      the interpreter technology without significant
      effort. Additionally, memory usage is a concern, and garbage
      collection can present some limitations. Thus, it is
      beneficial if the language can be implemented without the need
      for garbage collection and in a predictable, allocation
      friendly way. There are man opportunities for optimization in
      these cases.
    </simpara>
    <simpara>
      Finally, significant optimization focused transformations
      needed to be applied to the simpler Dyalog code in order to
      get it to go fastest, including some optimizations which were
      not obvious or that obfuscated the code somewhat. Many of
      these optimizations were for the sake of memory allocation or
      copying costs.  The compiler, then, has a great opportunity to
      improve this behavior by using a cost-effective strategy for
      allocation and avoding copying if it can, while still keeping
      the code simple, and not requiring excessive massaging to get
      the code into a copy-friendly state.
    </simpara>
    <itemizedlist spacing="compact">
      <title>Summary of Benchmarking Insights</title>
      <listitem>
        <simpara>
          Scalar fusion is a significant opportunity for performance
          increase and is the primary bottleneck in Dyalog APL
          interpretation based strategies
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Many optimization transformation conducted by hand on
          Dyalog code had to do with copy avoidance
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Avoiding garbage collection and providing predictable
          allocation behavior is a win
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Cache behavior is one of the key performance killers in
          the existing system, and a core target for optimization in
          the compiler
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          A specialized runtime can keep up with other code in most
          cases when the above conditions are not affecting the
          performance.
        </simpara>
      </listitem>
    </itemizedlist>
  </section>
