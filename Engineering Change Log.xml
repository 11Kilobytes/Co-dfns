<?xml version="1.0" encoding="utf-8" ?>

<article xmlns="http://docbook.org/ns/docbook" version="5.0">
	<info>
		<title>Engineering Change Log</title>
		<author><personname>Aaron W. Hsu</personname></author>
		<date>Saturday, July 20th, 2013</date>
	</info>
	<simpara>
		This document records and tracks all proposed engineering changes that 
		occur during development. An engineering change is a change proposed 
		or identified as desirable during one process that affects other work 
		products not part of the delivery of the current process. This document 
		tracks these proposed changes, their evaluation, analysis, and the 
		eventual resolution of these changes. 
	</simpara>
	<table frame="void" rules="rows">
		<caption>Summary of Changes</caption>
		<thead>
			<tr>
				<th>ID</th>
				<th colspan="2">Date</th>
				<th colspan="5">Summary</th>
				<th colspan="2">Resolution</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>1</td>
				<td colspan="2">2013-07-21</td>
				<td colspan="5">Update <function>Obj</function> and <function>Fix</function> Requirements</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>2</td>
				<td colspan="2">2013-07-23</td>
				<td colspan="5">Update class of valid input programs</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>3</td>
				<td colspan="2">2013-07-23</td>
				<td colspan="5">Add Dyalog Reference to Reuse Analysis</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>4</td>
				<td colspan="2">2013-07-29</td>
				<td colspan="5">Clarify exported bindings</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>5</td>
				<td colspan="2">2013-08-21</td>
				<td colspan="5">Cleanup System Requirements</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>6</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Fix FFI Declaration</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>7</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Fix missing definition</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>8</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Incorrect use of Scan</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>9</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Malformed result from Tokenize</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>10</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Missing assignment</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>11</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Incorrect comment identification</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>12</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Splitting on spaces fails for empty strings</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>13</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Domain error when wrapping tokens</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>14</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">SYNTAX ERROR on valid input</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>15</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">RANK ERROR on Parse return</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>16</td>
				<td colspan="2">2013-10-09</td>
				<td colspan="5">Parse accepts invalid input</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>17</td>
				<td colspan="2">2013-11-27</td>
				<td colspan="5">Redundancy in Sequence Enumeration</td>
				<td colspan="2">Pending</td>
			</tr>
			<tr>
				<td>18</td>
				<td colspan="2">2013-12-14</td>
				<td colspan="5">Incorrect arity for <function>Int4Type</function></td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>19</td>
				<td colspan="2">2013-12-14</td>
				<td colspan="5">Incorrect rank and shape for scalars</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>20</td>
				<td colspan="2">2013-12-16</td>
				<td colspan="5">Unnecessary Stimuli in Top-Level</td>
				<td colspan="2">Applied</td>
			</tr>
			<tr>
				<td>21</td>
				<td colspan="2">2013-12-16</td>
				<td colspan="5">Alter Fnf response</td>
				<td colspan="2">Applied</td>
			</tr>
      <tr>
        <td>22</td>
        <td colspan="2">2013-12-20</td>
        <td colspan="5">Remove uses of INT4</td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>23</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix Index Errors in <function>ParseExpr</function></td>
        <td colspan="2">Applied</td>
      </tr>
      <tr>
        <td>24</td>
        <td colspan="2">2013-12-21</td>
        <td colspan="5">Fix <function>DropUnmd</function> for empty namespace</td>
        <td colspan="2">Applied</td>
      </tr>
		</tbody>
	</table>
	<orderedlist>
		<title>Change Description and Analysis</title>
    <?dbfo label-width="0.25in"?>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					During Functional Specification, the <function>Obj</function> and <function>Fix</function>
					functions were discovered to have a number of missing or undesirable requirement 
					implications. The following changes are suggested:
				</para>
			</formalpara>
			<orderedlist>
				<listitem>
					<simpara>
						Amend Requirement 16 to require only implementing the monadic interface of 
						the <function>⎕FIX</function> function.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						An additional requirement should state that the <function>Obj</function> function 
						will produce a shared object in the given file name that has the same semantics 
						and function bindings as defined in the namespace.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Requirements should be added to clarify the error reporting in the case of files 
						that already exist when handling <function>Obj</function> output.
					</simpara>
				</listitem>
			</orderedlist>
			<formalpara>
				<title>Analysis</title>
				<para>
					The above requirements do not change the semantics of the requirements, 
					and only refine them. They meet the intention of the project and should 
					be implemented. 
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					Functional specification revealed a possible ambiguity in the description of 
					requirement 21. Recommend the following:
				</para>
			</formalpara>
			<orderedlist>
				<listitem>
					<simpara>
						That requirement 21 be changed to clearly indicate that only fully 
						closed namespaces are accepted; that is, only accept namespaces with 
						no free variable references.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Additionally, a new requirement 
						prohibiting the use of the <literal>⌶</literal>-beam should be included.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						A new requirement prohibiting the use of the <function>⍎</function>
						function should be added. 
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Requirement 4 should be amended to specify D-fns, rather than Co-Dfns 
						programs.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						The new additions to the D-fns languages introduced by Co-Dfns should 
						be added and fully defined.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						It should be remarked that no assignment which changes the overall 
						nameclass of a variable is allowed. 
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						A requirement detailing the unsupported operators should be added. 
						These operators include the <function>&amp;</function> operator as well as 
						the <function>⍠</function> operator.
					</simpara>
				</listitem>
			</orderedlist>
			<formalpara>
				<title>Analysis</title>
				<para>
					No semantic change is introduced based on the intention of the design, and 
					are at an early enough stage so as to not affect more than the functional 
					specification, so this should be implemented.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The primary specification for the D-fns language appears in the Dyalog
					<citetitle>Programmer's Guide and Language Reference</citetitle>. This 
					should be explicitly marked as the reference document for the semantics of 
					the D-fns language.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					This clarifies a number of implied assumptions on the part of the specifications 
					and development plans, and should be included.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					Clarify the exported functions that are produced by the compiler in the exported 
					namespace to indicate that currently, only global array variables and 
					functions will be exported. Operators and other such things will not. This 
					should be entered into the requirements document.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					This is a semantic change from the existing requirements, but does not affect 
					anything more than the functional specification, which has been amended to 
					include these adjustments anyways. Additionally, it does not add any 
					complexity, but simplifies the technical implemenation burden. The only visible 
					change to the user is the removal of operators from the public interface, which 
					is acceptable. 
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					Changes in the interface design are suggested by function specification. 
					It is unnecessary to have the object functionality separate from the fix 
					function. Additionally, analysis of the way that LLVM works indicates that 
					requirement #32 is not feasible, and will not be adequately implemented.
					A new requirement is suggested to indicate failures that may originate from 
					the LLVM Subsystem.
					This requires the following changes:
				</para>
			</formalpara>
			<orderedlist>
				<listitem>
					<simpara>
						Change requirements 9, 16, 17, 18, 29, 30, 31, and 42 accordingly.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Eliminate requirements 19, 20, and 32.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Add a new requirement that states an LLVM error will signal an <literal>INTERNAL ERROR</literal>.
					</simpara>
				</listitem>
			</orderedlist>
			<formalpara>
				<title>Analysis</title>
				<para>
					The change does not alter the functionality or intention of the compiler, but it 
					does create a simplified interface and is worth doing. It reduces workload later on.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					An error in the declaration of an FFI function was discovered during certification.
					This must be adjusted before further certification can proceed.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>ValidateInput</function> function is not defined. It should either be 
					defined or it should be replaced.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function gives a length error when trying to 
					split comments and code.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					The comment splitting code is the following line:
				</para>
			</formalpara>
			<programlisting>T C←⊂[0]↑2↑¨(1,¨1↓¨(~∨\¨0,¨1↓¨¯1⌽¨A)∧A←1↓¨'⍝'=A)⊂¨A</programlisting>
			<simpara>
				This code assumes that the array being scanned is always the same length as the 
				array itself. However, this is not the case when we deal with an empty array.
				The <literal>0,</literal> catenation will mean that we have an array of at least 
				length 1. In this case, the above expression will not work.
			</simpara>
			<simpara>
				This problem has wide ranging consequences because it is very likely that a given 
				namespace script will have blank lines in it, which will trigger this problem. 
				This function is overly complicated anyways, and can be simplified by a proper 
				use of the <literal>⍳</literal> function. We can use the following code instead:
			</simpara>
			<programlisting>I←(⊂A)⍳¨'⍝' ⋄ T←I↑¨A ⋄ C←I↓¨A</programlisting>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function gives a malformed result.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					This is due to an unnecessarily complex set of code. It is difficult to 
					verify this code, and it should not have made it through. Replacing the 
					code with simpler code that can be proven should fix the malformation 
					result.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function gives an incomplete result.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					There is a missing assignment in the <function>Tokenize</function> function.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function identifies comments incorrectly.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					The code that finds the index incorrectly treats the non-scalar set of 
					lines as a scalar, leading to a single index value that cannot be correct.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function fails to split in cases where the 
					reduction fails because of too few elements, namely, empty vectors.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					This reveals further problems with this first expression. It fails to 
					clearly split, and it also leaves the spaces around to be cleaned up later 
					or to introduce faulty tokens in the future.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Tokenize</function> function fails with a DOMAIN ERROR when 
					it tries to wrap tokens around empty lines.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					Apparently you cannot catenate reduce on an empty vector of any sort. 
					This was news to me. The easiest way to fix this is to insert a check 
					that handles this special case.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Parse</function> function fails with a SYNTAX ERROR on 
					valid input.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					The problem is the assumption of a nested result in this code for 
					doing the comparison, but in reality having a flat array:
				</para>
			</formalpara>
			<programlisting>NS←(⊃N),⊃⌽N←(¯1⌽T∊⊂'name')/T←,↑(⍵[;1]∊⊂'Token')/⍵[;3]
      ':Namespace' ':EndNamespace'≢NS:⎕SIGNAL 2</programlisting>
			<simpara>
				This is trivially fixed by unifying the types.
			</simpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Parse</function> function does not return two elements.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					The function <function>Parse</function> is supposed to return both 
					and AST and the Names that are bound at the top-level, but it does 
					not do this currently.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					The <function>Parse</function> function accepts more than one 
					Nss and one Nse stimuli.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					This happens because there is no check for it, while there is a 
					check to ensure that the first and last stimuli are Nss and Nse 
					respectively. Inserting this check should fix this issue.
				</para>
			</formalpara>
		</listitem>
		<listitem>
			<formalpara>
				<title>Description</title>
				<para>
					Usage Modeling has identified a number of potential redundancies 
					in the Sequence Enumeration. Recommendation is to remove 
					these redundancies to simplify the <citetitle>Function Specification</citetitle>.
				</para>
			</formalpara>
			<formalpara>
				<title>Analysis</title>
				<para>
					Analysis pending.
				</para>
			</formalpara>
		</listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Statistical testing encountered a type error in the implementation 
          of <function>Int4Type</function> which was implemented in the 
          <classname>CoDfns</classname> namespace during the environment 
          conversion to UNIX. It should not be a dfns, but should be a niladic 
          function.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          Change introduced during environment conversion was incorrect 
          and should be rectified immediately.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          In the LLVM output, the V9 rank is 1, rather than 0, and the 
          shape contains a one element vector containing 1. This is 
          incorrect for a single scalar value.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The coding of the <function>GenConst</function> function 
          is not sufficiently robust and requires reworking. In
          particular, the initial extraction of the expression values
          did not take into account the appropriate shape of the
          expression. These effects are localized and contained to the
          <function>GenConst</function> function, and do not affect
          any other elements or problems. 
        </para>
      </formalpara>
      <simpara>
        The cause of this problem can be traced at least partially
        back to having a function specification that is unable to
        express these precise details about the nature of each
        conversion. Adapting the function specification to include
        more information like this would like improve the ability to
        catch these errors earlier. Technically, however, these
        elements are clearly specified in the <citetitle>Programming
        Language Reference</citetitle> from Dyalog.
      </simpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The <constant>Fnd</constant> and <constant>Fnm</constant>
          stimuli do not have any real purpose in the top-level
          enumeration and are redundant, they should be removed from
          the stimuli set.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This redundancy is demonstrated by the fact that these
          stimuli do not show up in the Canonical sequences at all, as
          well as being subsumed in all cases by the
          <constant>Fe</constant> stimuli, which itself has direct
          support for the <constant>Fnd</constant> and
          <constant>Fnm</constant> stimuli. This change has minimal
          impact on the rest of the system, as they are not mentioned
          directly anywhere else, and are already subsumed in the rest
          of the documentation. Thus, it is safe to remove them at any
          time. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          Morten Kromberg has suggested that we do not need to follow the standard 
          APL behavior when handling the Fnf behavior, and we can instead follow 
          the method that we see in most other compilers. That is, we can just 
          overwrite the existing file rather than signalling an error. 
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This will require a small change in the Function Specification to handle 
          things, which will require changing the enumeration and subsequently 
          the Black Box Definitions. This will also require some code changes
          in the <filename>CoDfns.dyalog</filename> namespace script. Current 
          Usage Specification does not need to be changed, and the main models 
          for Increment 3 can be adjusted to handle this change. Previous increments 
          did not or were not sensitive to this change and do not need to be 
          recertified. 
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          There is little support for the <type>uint4_t</type> in
          compilers, so we should remove its use from the array and
          the compiler output. This will simplify the definition of
          the compiler in the shared object runtime. This will fix the
          compiler failure in building this shared object.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          This will require some changes to the <citetitle>Software
          Architecture</citetitle> and subsequently to the
          <filename>CoDfns.dyalog</filename> namespace, which will
          have to adjust its use of the int4 type in various
          places. Other than this, it is not used elsewhere and will
          not affect other documents.
        </para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          The following two programs trigger <symbol>INDEX ERROR</symbol> messages 
          in the compiler.
        </para>
      </formalpara>
      <programlisting linenumbering="numbered">:Namespace
 V1
:EndNamespace
</programlisting>
      <para>
        Signals an error with the following stack trace:
      </para>
      <screen>#.CoDfns.ParseExpr[21]*
#.CoDfns.ParseLine[51]
/
#.CoDfns.Parse[145]
#.CoDfns.Compile[2]
#.CoDfns.Fix[26]</screen>
      <para>
        And the following program gives a slightly different index error.
      </para>
      <programlisting linenumbering="numbered">:Namespace
 V1←
:EndNamespace
</programlisting>
      <para>
        Which errors at ParseExpr[19] with this stack trace:
      </para>
      <screen>#.CoDfns.ParseExpr[19]*
#.CoDfns.ParseExpr[24]
#.CoDfns.ParseLine[51]
/
#.CoDfns.Parse[145]
#.CoDfns.Compile[2]
#.CoDfns.Fix[26]</screen>
      <formalpara>
        <title>Analysis</title>
        <para>
          In the first case, we incorrectly assume that we will have
          at least two tokens in our token matrix when parsing for an
          expression. If there is only a single token in the token
          list that we are parsing, and that single token is a
          variable, then the first condition checks the second token
          to determing whether it is an assignment or not. However,
          since there is no second token, this fails with an
          <symbol>INDEX ERROR</symbol>. A simple check before this
          suffices to fix this oversight.
        </para>
      </formalpara>
      <para>
        The same thing happens with the second example, but a little
        earlier. If we have an assignment to a variable that has no
        expression on the right hand side of the assignment, then the
        <function>ParseExpr</function> function will be called without
        any tokens in it. Previously, we assumed that we would have at
        least one token in the matrix, but now we need to check to
        ensure that there is at least one token before checking
        whether that token is a variable on the 19th line of the
        function body.
      </para>
    </listitem>
    <listitem>
      <formalpara>
        <title>Description</title>
        <para>
          We get a domain error in <function>DropUnmd</function> when
          trying to handle an empty namespace.
        </para>
      </formalpara>
      <formalpara>
        <title>Analysis</title>
        <para>
          The <function>DropUnmd</function> function is called in the
          compiler right after the <function>KillLines</function>
          function. In the case of an empty namespace, this will
          result in a tree with no depth-1 subtrees. This will result
          in attempting to execute a first-axis catenate against an 
          empty array with no identity element by default. 
        </para>
      </formalpara>
      <para>
        The appropriate fix is to ensure that the catenation never
        receives and empty vector of sub-trees. We manually insert an
        empty AST node to the head of the vector coming in, which will
        ensure a non-zero vector, but will not affect the results of
        any of the catenations in the line. 
      </para>
    </listitem>
	</orderedlist>
</article>
