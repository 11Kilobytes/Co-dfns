<table frame="void" rules="rows" xmlns="http://docbook.org/ns/docbook" version="5.0">
  <caption>Stimuli for Source Input</caption>
  <thead>
    <tr>
      <th>Symbol</th>
      <th colspan="2">Name</th>
      <th colspan="3">Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{</td>
      <td colspan="2">Left Brace</td>
      <td colspan="3">A left brace token</td>
    </tr>
    <tr>
      <td>}</td>
      <td colspan="2">Unbalanced Right Brace</td>
      <td colspan="3">A right brace token</td>
    </tr>
    <tr>
      <td>[</td>
      <td colspan="2">Left Bracket</td>
      <td colspan="3">A left bracket token</td>
    </tr>
    <tr>
      <td>]</td>
      <td colspan="2">Right Bracket</td>
      <td colspan="3">A right bracket token</td>
    </tr>
    <tr>
      <td>(</td>
      <td colspan="2">Left Parenthesis</td>
      <td colspan="3">A left parenthesis token</td>
    </tr>
    <tr>
      <td>)</td>
      <td colspan="2">Right Parenthesis</td>
      <td colspan="3">A right parenthesis token</td>
    </tr>
    <tr>
      <td>;</td>
      <td colspan="2">Index Separator</td>
      <td colspan="3">The index separator for bracket indexing</td>
    </tr>
    <tr>
      <td>:</td>
      <td colspan="2">Conditional</td>
      <td colspan="3">The conditional token</td>
    </tr>
    <tr>
      <td>::</td>
      <td colspan="2">Error Guard</td>
      <td colspan="3">The error guard token</td>
    </tr>
    <tr>
      <td>
        <literal>⋄</literal>
      </td>
      <td colspan="2">Statement Separator</td>
      <td colspan="3">Statement separtor token</td>
    </tr>
    <tr>
      <td>
        <literal>←</literal>
      </td>
      <td colspan="2">Assignment</td>
      <td colspan="3">An assignment token</td>
    </tr>
    <tr>
      <td>
        <literal>⍨</literal>
      </td>
      <td colspan="2">Commute Operator</td>
      <td colspan="3">The Commute Operator</td>
    </tr>
    <tr>
      <td>
        <literal>∘</literal>
      </td>
      <td colspan="2">Compose Operator</td>
      <td colspan="3">The Compose Operator</td>
    </tr>
    <tr>
      <td>
        <literal>¨</literal>
      </td>
      <td colspan="2">Each Operator</td>
      <td colspan="3">The Each Operator</td>
    </tr>
    <tr>
      <td>
        <literal>.</literal>
      </td>
      <td colspan="2">Product Operator</td>
      <td colspan="3">The Product Operator</td>
    </tr>
    <tr>
      <td>
        <literal>⍣</literal>
      </td>
      <td colspan="2">Power Operator</td>
      <td colspan="3">The Power Operator</td>
    </tr>
    <tr>
      <td>
        <literal>/</literal>
      </td>
      <td colspan="2">Reduce Operator</td>
      <td colspan="3">The Reduce Operator</td>
    </tr>
    <tr>
      <td>
        <literal>⌿</literal>
      </td>
      <td colspan="2">First Reduce Operator</td>
      <td colspan="3">The First-axis Reduce Operator</td>
    </tr>
    <tr>
      <td>
        <literal>\</literal>
      </td>
      <td colspan="2">Scan Operator</td>
      <td colspan="3">The Scan Operator</td>
    </tr>
    <tr>
      <td>
        <literal>⍀</literal>
      </td>
      <td colspan="2">First Scan Operator</td>
      <td colspan="3">The First-axis Scan Operator</td>
    </tr>
    <tr>
      <td>Break</td>
      <td colspan="2">Interrupt/Break</td>
      <td colspan="3">User signalled interrupt</td>
    </tr>
    <tr>
      <td>D</td>
      <td colspan="2">Dyadic Primitive</td>
      <td colspan="3">A primitive function that can only be called dyadically.</td>
    </tr>
    <tr>
      <td>Da</td>
      <td colspan="2">Dyadic Axis Primitive</td>
      <td colspan="3">A primitive function that can only be called dyadically.
      Valid with the Axis Operator.</td>
    </tr>
    <tr>
      <td>Eot</td>
      <td colspan="2">End of Transmission</td>
      <td colspan="3">The end of the input to the compiler</td>
    </tr>
    <tr>
      <td>Fix</td>
      <td colspan="2">
        Call
        <function>Fix</function>
      </td>
      <td colspan="3">
        A call to the
        <function>Fix</function>
        function, arguments to follow.
      </td>
    </tr>
    <tr>
      <td>Fnb</td>
      <td colspan="2">Bad Filename</td>
      <td colspan="3">A pathname that is somehow an invalid syntax or otherwise
      invalid to be used as a pathname.</td>
    </tr>
    <tr>
      <td>Fne</td>
      <td colspan="2">Empty Filename</td>
      <td colspan="3">A filename/pathname that specifies a file that does
      not yet exist.</td>
    </tr>
    <tr>
      <td>Fnf</td>
      <td colspan="2">Found Filename</td>
      <td colspan="3">A filename that specifies a file that already exists
      in the filesystem.</td>
    </tr>
    <tr>
      <td>Lle</td>
      <td colspan="2">LLVM Error</td>
      <td colspan="3">Any LLVM derived error</td>
    </tr>
    <tr>
      <td>Lls</td>
      <td colspan="2">LLVM Success</td>
      <td colspan="3">Any LLVM derived success</td>
    </tr>
    <tr>
      <td>M</td>
      <td colspan="2">Monadic Primitive</td>
      <td colspan="3">A primtive function that can be called monadically.</td>
    </tr>
    <tr>
      <td>Ma</td>
      <td colspan="2">Monadic Axis Primitive</td>
      <td colspan="3">A primtive function that can be called monadically.
      Valid with Axis Operator.</td>
    </tr>
    <tr>
      <td>N</td>
      <td colspan="2">Literal Number</td>
      <td colspan="3">A valid, literal number</td>
    </tr>
    <tr>
      <td>Nl</td>
      <td colspan="2">Newline</td>
      <td colspan="3">A newline character of some sort</td>
    </tr>
    <tr>
      <td>Nse</td>
      <td colspan="2">Namespace End</td>
      <td colspan="3">
        The ending token for a namespace script, usually
        <literal>:EndNamespace</literal>
        .
      </td>
    </tr>
    <tr>
      <td>Nss</td>
      <td colspan="2">Namespace Start</td>
      <td colspan="3">
        The starting token for a namespace script, usually
        <literal>:Namespace</literal>
        .
      </td>
    </tr>
    <tr>
      <td>S</td>
      <td colspan="2">String</td>
      <td colspan="3">A literal character array string</td>
    </tr>
    <tr>
      <td>Sm</td>
      <td colspan="2">Monadic Selector</td>
      <td colspan="3">A monadic primitive suitable for selective assignment</td>
    </tr>
    <tr>
      <td>Sd</td>
      <td colspan="2">Dyadic Selector</td>
      <td colspan="3">A dyadic primitive suitable for selective assignment</td>
    </tr>
    <tr>
      <td>Va</td>
      <td colspan="2">Array Variable</td>
      <td colspan="3">A variable bound to an array</td>
    </tr>
    <tr>
      <td>Vna</td>
      <td colspan="2">Array Variable</td>
      <td colspan="3">A nested array variable expression with no unbound
      variables</td>
    </tr>
    <tr>
      <td>Vi</td>
      <td colspan="2">Illegal Variable</td>
      <td colspan="3">A variable occurring in an illegal context</td>
    </tr>
    <tr>
      <td>Vf</td>
      <td colspan="2">Function Variable</td>
      <td colspan="3">A variable bound to a function</td>
    </tr>
    <tr>
      <td>Vfo</td>
      <td colspan="2">Function/Operator Variable</td>
      <td colspan="3">A variable bound to a function or operator</td>
    </tr>
    <tr>
      <td>Vo[op]</td>
      <td colspan="2">Operator Variable</td>
      <td colspan="3">
        A variable bound to an operator equivalent to
        <varname>op</varname>
      </td>
    </tr>
    <tr>
      <td>Vnu</td>
      <td colspan="2">Unbound Nested Variable</td>
      <td colspan="3">A nested variable expression that has some unbound
      variables</td>
    </tr>
    <tr>
      <td>Vu</td>
      <td colspan="2">Unbound Variable</td>
      <td colspan="3">A variable that has not been bound</td>
    </tr>
  </tbody>
</table>
