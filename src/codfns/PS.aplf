 PS←{IN←⍵ ⋄ A B C E F G K L M N O P S V Z←1+⍳15 ⋄ I←{(⊂⍵)⌷⍺} ⋄ U←{⍵⍵⍣¯1 ⍺⍺ ⍵⍵ ⍵}
   assert←{⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}

   1<≢⍴IN:'PARSER REQUIRES A SCALAR/VECTOR INPUT'⎕SIGNAL 11
   1<≡IN:'PARSER REQUIRES A SIMPLE ARRAY'⎕SIGNAL 11
   0≠10|⎕DR IN:'PARSER REQUIRES A CHARACTER ARRAY'⎕SIGNAL 11

⍝ Group input into lines as a nested vector
   pos←(⍳≢IN)⊆⍨~IN∊CR LF←⎕UCS 13 10

⍝ Identify strings to tokenize them early
   lin←⍸⊃∘⌽¨msk←≠⍀¨''''=IN∘I¨pos

⍝ Make a nice error message if the strings are unbalanced on a line
   0≠≢lin:{
     nos←'[',(⍕1+⍪lin),⍤1⊢'] '
     EM←'SYNTAX ERROR: UNBALANCED STRING',('S'⌿⍨2≤≢lin),CR
     EM,←∊nos,(IN∘I¨pos[lin]),CR,(⊃0⍴⊂nos),(' ▔'∘I¨msk[⍪lin]),CR
     EM ⎕SIGNAL 2}⍬

⍝ Remove comments
   pos msk⌿¨⍨←⊂∧⍀¨(~msk←msk∨¯1⌽¨msk)⍲'⍝'=IN∘I¨pos

⍝ Remove leading and trailing whitespace
   WS←⎕UCS 9 32
   pos msk⌿¨⍨←⊂(∧⍀∨∧⍀U⌽)∘(WS∊⍨IN∘I)¨pos

⍝ We can safely tokenize strings now, introducing pos and end
   pos end←↓⍉↑msk{g←1,2≠⌿⍺ ⋄ ⍪⌿↑(g⊂⍺){∧⌿⍺:(⊣⌿,⊢⌿)⍵ ⋄ ⍵(1+⍵)}¨g⊂⍵}¨pos

⍝ Remove the ⋄ components from lines to make them all separate lines
   pos end{⊃⍪⌿⍵⊆¨⍺}←⊂'⋄'≠IN∘I¨pos

⍝ Introduce typ to distinguish tokens
   typ←{(C×⍵='''')+F×⍵='{'}IN[pos]

⍝ We no longer need nested lines, so flatten and separate with Z type
   typ pos end(∊,∘⍪⍨)←Z(⊃¨pos)(1+⊃¨pos)

⍝ Verify that all open characters are part of the valid character set
   alp←'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'
   alp,←'abcdefghijklmnopqrstuvwxyz'
   alp,←'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝß'
   alp,←'àáâãäåæçèéêëìíîïðñòóôõöøùúûüþ'
   alp,←'∆⍙alp,←'ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ'
   num←⎕D
   synb←'¯[]{}()'':⍺⍵⋄;'
   syna←'⍬⎕⍞∇←→#'
   prmfs←'+-×÷|⌈⌊*⍟○!?~∧∨⍲⍱<≤=>≥≠≡≢⍴,⍪⌽⊖⍉↑↓⊂⊆⊃∊⍷/⌿\⍀∩∪⍳⍸⌷⍋⍒⍎⍕⊥⊤⊣⊢⌹'
   prmos←'¨⍨∘./⌿\⍀⍣&⌶⍠⌸⌺⍤⍥@'
   x←' ',⍨' '@{typ≠0}IN[pos] ⍝ The spaces produce nice invariants
   ~x∊alp,num,syn,prmfs,prmos:'INVALID CHARACTER IN SOURCE'⎕SIGNAL 2

⍝ Tokenize numbers
   _←{dm[⍵]←∧⍀dm[⍵]}¨(dm∨x∊alp)⊆⍳≢dm←x∊num
   dm∨←('.'=x)∧(¯1⌽dm)∨1⌽dm
   dm∨←('¯'=x)∧1⌽dm
   dm∨←(x∊'EeJj')∧(¯1⌽dm)∧1⌽dm
   ∨⌿(typ=0)∧IN[pos]='¯':'ORPHANED ¯'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='j'}¨dp←⎕C¨dm⊆x:'MULTIPLE J IN NUMBER'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='e'}¨dp←⊃⍪/{⍵⊆⍨⍵≠'j'}¨dp:'MULTIPLE E IN NUMBER'⎕SIGNAL 2
   ∨⌿'e'=⊃¨dp:'MISSING MANTISSA'⎕SIGNAL 2
   ∨⌿'e'=⊃∘⌽¨dp:'MISSING EXPONENT'⎕SIGNAL 2
   mn ex←↓⍉↑{2↑(⍵⊆⍵≠'e'),⊂''}¨dp
   ∨⌿{1<+⌿'.'=⍵}¨mn,ex:'MULTIPLE . IN NUMBER'⎕SIGNAL 2
   ∨⌿'.'∊¨ex:'REAL NUMBER IN EXPONENT'⎕SIGNAL 2
   ∨⌿{('¯'∊⍵)∧'¯'≠⊃⍵}¨mn,ex:'MISPLACED ¯'⎕SIGNAL 2
   typ[i←⍸2<⌿0⍪dm]←N ⋄ end[i]←end⌿⍨2>⌿dm⍪0

⍝ Tokenize Variables
   typ[i←⍸2<⌿0⍪vm←(~dm)∧x∊alp,num]←V ⋄ end[i]←end⌿⍨2>⌿vm⍪0

⍝ Tokenize ⍺, ⍵ formals
   fm←{mm←⌽⊃(>∘⊃,⊢)⌿⌽m←⍺=' ',⍵ ⋄ 1↓¨(mm∧~m1)(mm∧m1←1⌽m)}
   am aam←'⍺'fm x ⋄ wm wwm←'⍵'fm x
   ((am∨aam∨wm∨wwm)⌿typ)←P ⋄ ((aam∨wwm)⌿end)←end⌿⍨¯1⌽aam∨wwm

⍝ Tokenize Primitives
   pm←(~dm)∧x∊primfs,primos,syna
   (pm⌿typ)←P

⍝ Compute the depth vector based on { and } dfns, include } as a child
   0≠⊃d←¯1⌽+⍀1 ¯1 0['{}'⍳IN[pos]]:'UNBALANCED DFNS'⎕SIGNAL 2

⍝ Check for out of context dfns formals
   (d=0)∧(typ=P)∧IN[pos]∊'⍺⍵':'DFN FORMAL REFERENCED OUTSIDE DFNS'⎕SIGNAL 2

⍝ Compute trad-fns regions
   ∨⌿Z≠typ⌿⍨1⌽msk←(d=0)∧'∇'=x:'TRAD-FNS START/END LINES MUST BEGIN WITH ∇'⎕SIGNAL 2
   0≠⊃tm←¯1⌽≠⍀(d=0)∧'∇'=x:'UNBALANCED TRAD-FNS'⎕SIGNAL 2
   ∨⌿Z≠typ⌿⍨⊃1 ¯1∨.⌽⊂(2>⌿tm)⍪0:'TRAD-FNS END LINE MUST CONTAIN ∇ ALONE'⎕SIGNAL 2

⍝ Identify Label colons versus others
   typ[⍸tm∧(d=0)∧∊((~⊃)∧(<⍀∨⍀))¨':'=(typ=Z)⊂IN[pos]]←L

⍝ Tokenize Keywords
   ki←⍸(typ=0)∧(d=0)∧(':'=IN[pos])∧1⌽typ=V
   typ[ki]←K ⋄ end[ki]←end[ki+1] ⋄ typ[ki+1]←0
   ERR←'EMPTY COLON IN NON-DFNS CONTEXT, EXPECTED LABEL OR KEYWORD'
   ∨⌿(typ=0)∧(d=0)∧':'=IN[pos]:ERR ⎕SIGNAL 2

⍝ Tokenize System Variables
   si←⍸('⎕'=IN[pos])∧1⌽typ=V
   typ[si]←S ⋄ end[si]←end[si+1] ⋄ typ[si+1]←0

⍝ Delete all characters we no longer need from the tree
   d tm typ pos end(⌿⍨)←⊂(typ≠0)∨x∊'()[]{}:;'

⍝ Tokenize Labels
   ERR←'LABEL MUST CONSIST OF A SINGLE NAME'
   ∨⌿(Z≠typ[li-1])∨(V≠typ[li←⍸1⌽msk←typ=L]):ERR ⎕SIGNAL 2
   typ[li]←L ⋄ end[li]←end[li+1]
   d tm typ pos end(⌿⍨)←⊂~msk

⍝ Now that all compound data is tokenized, reify n field before tree-building
   n←IN∘I¨pos+⍳¨end-pos

⍝ Keywords are case-insensitive
   n←(⊂'')@{typ=Z}1 ⎕C@{typ=K}n

⍝ Verify that keywords and system variables are defined and scoped correctly
   KW←'NAMESPACE' 'ENDNAMESPACE' 'END' 'IF' 'ELSEIF' 'ANDIF' 'ORIF' 'ENDIF'
   KW,←'WHILE' 'ENDWHILE' 'UNTIL' 'REPEAT' 'ENDREPEAT' 'LEAVE' 'FOR' 'ENDFOR'
   KW,←'IN' 'INEACH' 'SELECT' 'ENDSELECT' 'CASE' 'CASELIST' 'ELSE' 'WITH'
   KW,←'ENDWITH' 'HOLD' 'ENDHOLD' 'TRAP' 'ENDTRAP' 'GOTO' 'RETURN' 'CONTINUE'
   KW,←'SECTION' 'ENDSECTION' 'DISPOSABLE' 'ENDDISPOSABLE'
   KW,¨⍨←':'
   msk←~KW∊⍨kws←n⌿⍨km←typ=K
   ∨⌿msk:('UNRECOGNIZED KEYWORD ',kws⊃⍨⊃⍸msk)⎕SIGNAL 2
   msk←kws∊':NAMESPACE' ':ENDNAMESPACE'
   ∨⌿msk∧km⌿tm:'NAMESPACE SCRIPTS MUST APPEAR AT THE TOP LEVEL'⎕SIGNAL 2
   msk←kws∊KW~':NAMESPACE' ':ENDNAMESPACE' ':SECTION' ':ENDSECTION'
   ∨⌿msk∧~km⌿tm:'STRUCTURED STATEMENTS MUST APPEAR WITHIN TRAD-FNS'⎕SIGNAL 2

⍝ Compute parent vector from d
   p←D2P d

⍝ We will often wrap a set of nodes as children under a Z node
   gz←{typ[⍺]←Z ⋄ p[⍵]←⍺ ⋄ pos[⍺]←pos[⊃⍵,⍺] ⋄ end[⍺]←end[⊃⌽⍺,⍵] ⋄ 0}

⍝ Nest top-level root lines as Z nodes
   _←(⊃gz 1↓⊢)¨(typ[i]=Z)⊂i←⍸d=0
   assert typ[⍸p=⍳≢p]=Z:

⍝ Nest all dfns expression bodies as Z nodes
   _←p[i]{end[⍺]←end[⊃⌽⍵] ⋄ (⊃∘⌽gz ¯1↓⊢)¨⍵⊂⍨1,¯1↓typ[⍵]=Z}⌸i←⍸typ[p]=F
   assert typ[⍸typ[p]=F]=Z:

⍝ Drop/eliminate any Z nodes that are empty or blank
   _←p[i]{msk[⍺,⍵]←~∧⌿IN[pos[⍵]]∊WS}⌸i←⍸(typ[p]=Z)∧p≠⍸≢p⊣msk←typ≠Z
   tm n typ pos end(⌿⍨)←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Keyword structures
   nss←n∊⊂':NAMESPACE' ⋄ nse←n∊⊂':ENDNAMESPACE'
   ERR←':NAMESPACE KEYWORD MAY ONLY APPEAR AT BEGINNING OF A LINE
   Z∨.≠typ⌿⍨1⌽nss:ERR ⎕SIGNAL 2
   ERR←'NAMESPACE DECLARATION MAY HAVE ONLY A NAME OR BE EMPTY'
   ∨⌿(Z≠typ⌿⍨¯1⌽nss)∧(V≠typ⌿⍨¯1⌽nss)∨Z≠typ⌿⍨¯2⌽nss:ERR ⎕SIGNAL 2
   ERR←':ENDNAMESPACE KEYWORD MUST APPEAR ALONE ON A LINE'
   ∨⌿Z≠typ⌿⍨⊃1 ¯1∨.⌽⊂nse:ERR ⎕SIGNAL 2
   typ[nsi←⍸1⌽nss]←M ⋄ typ[nei←⍸1⌽nse]←-M
   n[i]←n[1+i←⍸(typ=M)∧V=1⌽typ] ⋄ end[nsi]←end[nei]
   x←⍸p=⍳≢p ⋄ d←+⍀(typ[x]=M)+-typ[x]=-M
   0≠⊃⌽d:':NAMESPACE KEYWORD MISSING :ENDNAMESPACE PAIR'⎕SIGNAL 2
   p[x]←x[D2P ¯1⌽d]

⍝ Delete unnecessary namespace nodes from the tree, leave only M's
   msk←~nss∨((¯1⌽nss)∧typ=V)∨nse∨1⌽nse
   tm n typ pos end(⌿⍨)←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Labels ∘∘∘

⍝ Map guard statements to (G (Z ...) (Z ...))
   _←p[i]{
     0=+⌿m←':'=IN[pos[⍵]]:⍬
     ⊃m:'EMPTY GUARD TEST'⎕SIGNAL 2
     1<+⌿m:'TOO MANY GUARDS'⎕SIGNAL 2
     typ[⍺]←G
     t g c←3↑(⊂⍬)⍪⍨⍵⊂⍨1,m∨¯1⌽m
     g gz t:
     ci←≢p ⋄ typ pos end⍪←0 ⋄ _←ci gz c
   }⌸i←⍸typ[p[p]]=F

⍝ Parse brackets and parentheses into ¯1 and Z nodes
   _←p[i]{
     x←IN[pos[⍵]] ⋄ bd←+⍀bm←(bo←'['=x)+-bc←']'=x ⋄ pd←+⍀pm←(po←'('=x)+-pc←')'=x
     0≠⊃⌽bd:'UNBALANCED BRACKETS'⎕SIGNAL 2
     0≠⊃⌽pd:'UNBALANCED PARENTHESES'⎕SIGNAL 2
     (po⌿bd)∨.≠⌽pc⌿bd:'OVERLAPPING BRACKETS AND PARENTHESES'⎕SIGNAL 2
     p[⍵]←(⍺,⍵)[1+¯1 D2P +⍀¯1⌽bm+pm] ⋄ typ[bo⌿⍵]←¯1 ⋄ typ[po⌿⍵]←Z
     end[⍵⌿⍨po+bo]←end[⌽⍵⌿⍨pc+bc]
   }⌸i←⍸typ[p]=Z
   typ pos end(⌿⍨)←⊂msk←~IN[pos]∊')' ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Convert semi-colon indexing into Z nodes in the ¯1 nodes
   _←p[i]{(⊃∘⌽gz ¯1↓⊢)¨⍵⊂⍨¯1⌽IN[pos[⍵]]∊';]'}⌸i←⍸typ[p]=¯1

⍝ BINDING NODES (NODES THAT INTRODUCE NEW BINDINGS)
⍝ BINDABILITY 
⍝ BINDING TARGETS AND CHILDREN
⍝ FREE VARIABLES
⍝ DFNS TYPING
⍝ INFER BINDING TYPE
⍝ STRANDING/ATOMS
⍝ BRACKET INDEXING
⍝ MUTATION/ASSIGNMENTS
⍝ FUNCTION EXPRESSIONS
⍝ EXPRESSION NODES

   d i←P2D p
   d←d[i] ⋄ t←(F@{typ=M}typ)[i] ⋄ k←(0⍴⍨≢typ)[i] ⋄ pos←pos[i] ⋄ end←end[i]
   sym←∪0(,'⍵')(,'⍺')'⍺⍺' '⍵⍵',n[i]
   (d t k(~sym⍳n)pos end)(⍬⍬)sym IN}
