 PS←{IN←⍵ ⋄ A B C E F G K L M N O P S V Z←1+⍳15 ⋄ types←' ABCEFGKLMNOPSVZ'
   I←{(⊂⍵)⌷⍺} ⋄ U←{0=⎕NC'⍺':⍵⍵⍣¯1 ⍺⍺ ⍵⍵ ⍵ ⋄ ⍵⍵⍣¯1⊢(⍵⍵ ⍺) ⍺⍺ ⍵⍵ ⍵}
   assert←{⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}

   OP.ps ⍵

   1<≢⍴IN:'PARSER REQUIRES A SCALAR/VECTOR INPUT'⎕SIGNAL 11
   2<|≡IN:'PARSER REQUIRES A SIMPLE OR VECTOR OF VECTOR INPUT'⎕SIGNAL 11
   IN←{∊⍵,¨⎕UCS 10}⍣(1<|≡IN)⊢IN
   0≠10|⎕DR IN:'PARSER REQUIRES A CHARACTER ARRAY'⎕SIGNAL 11

⍝ Identify beginnings of lines
   CR LF←⎕UCS 13 10
   linestarts←(⍸1⍪2>⌿IN∊CR LF)⍪≢IN
   quotelines←{
     lines←∪linestarts⍸⍵
     nos←(1 0⍴⍨2×≢lines)⍀'[',(⍕⍪1+lines),⍤1⊢'] '
     beg←linestarts[lines] ⋄ end←linestarts[lines+1]
     m←∊∘⍵¨i←beg+⍳¨end-beg
     ∊nos,(~∘CR LF¨⍪,(IN∘I¨i),⍪' ▔'∘I¨m),CR}

⍝ Group input into lines as a nested vector
   pos←(⍳≢IN)⊆⍨~IN∊CR LF

⍝ Mask strings
   0≠≢lin←⍸⊃∘⌽¨msk←≠⍀¨''''=IN∘I¨pos:{
     EM←'SYNTAX ERROR: UNBALANCED STRING',('S'⌿⍨2≤≢lin),CR
     EM,←quotelines ∊(msk⌿¨pos)[lin]
     EM ⎕SIGNAL 2}⍬

⍝ Remove comments
   pos msk⌿¨⍨←⊂∧⍀¨(~msk←msk∨¯1⌽¨msk)⍲'⍝'=IN∘I¨pos

⍝ Remove leading and trailing whitespace
   WS←⎕UCS 9 32 ⋄ pos msk⌿¨⍨←⊂~(∧⍀∨∧⍀U⌽)∘(WS∊⍨IN∘I)¨pos

⍝ Flatten and separate lines and ⋄ with Z type
   t←⊃0⍴⊂pos ⋄ t pos msk(∊,∘⍪⍨)←Z(⊃¨pos)0 ⋄ t[⍸'⋄'=IN[pos]]←Z

⍝ Tokenize Strings
   end←1+pos ⋄ t[i←⍸2<⌿0⍪msk]←C ⋄ end[i]←end[⍸2>⌿msk⍪0]
   t pos end⌿⍨←⊂(t≠0)∨~msk

⍝ Verify that all open characters are part of the valid character set
   alp←'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
   alp,←'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüþ'
   alp,←'∆⍙ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ'
   num←⎕D
   synb←'¯[]{}()'':⍺⍵⋄;'
   syna←'⍬⎕⍞#'
   prmfs←'+-×÷|⌈⌊*⍟○!?~∧∨⍲⍱<≤=>≥≠≡≢⍴,⍪⌽⊖⍉↑↓⊂⊆⊃∊⍷∩∪⍳⍸⌷⍋⍒⍎⍕⊥⊤⊣⊢⌹∇←→'
   prmdo←'∘.⍣⍠⌺⍤⍥@' ⋄ prmmo←'¨⍨&⌶⌸' ⋄ prmfo←'/⌿\⍀'
   prms←prmfs,prmdo,prmmo,prmfo
   x←' '@{t≠0}IN[pos] ⍝ The spaces produce nice invariants
   ∨⌿msk←~x∊alp,num,syna,synb,prms,WS:{
     EM←'SYNTAX ERROR: INVALID CHARACTER(S) IN SOURCE',CR
     EM,←quotelines ⍸msk
     EM ⎕SIGNAL 2}⍬

⍝ Tokenize numbers
   _←{dm[⍵]←∧⍀dm[⍵]}¨(dm∨x∊alp)⊆⍳≢dm←x∊num
   dm∨←('.'=x)∧(¯1⌽dm)∨1⌽dm
   dm∨←('¯'=x)∧1⌽dm
   dm∨←(x∊'EeJj')∧(¯1⌽dm)∧1⌽dm
   ∨⌿(t=0)∧IN[pos]='¯':'ORPHANED ¯'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='j'}¨dp←⎕C¨dm⊆x:'MULTIPLE J IN NUMBER'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='e'}¨dp←⊃⍪/{⍵⊆⍨⍵≠'j'}¨dp:'MULTIPLE E IN NUMBER'⎕SIGNAL 2
   ∨⌿'e'=⊃¨dp:'MISSING MANTISSA'⎕SIGNAL 2
   ∨⌿'e'=⊃∘⌽¨dp:'MISSING EXPONENT'⎕SIGNAL 2
   mn ex←↓⍉↑{2↑(⍵⊆⍨⍵≠'e'),⊂''}¨dp
   ∨⌿{1<+⌿'.'=⍵}¨mn,ex:'MULTIPLE . IN NUMBER'⎕SIGNAL 2
   ∨⌿'.'∊¨ex:'REAL NUMBER IN EXPONENT'⎕SIGNAL 2
   ∨⌿{('¯'∊⍵)∧'¯'≠⊃⍵}¨mn,ex:'MISPLACED ¯'⎕SIGNAL 2
   t[i←⍸2<⌿0⍪dm]←N ⋄ end[i]←end⌿⍨2>⌿dm⍪0

⍝ Tokenize Variables
   t[i←⍸2<⌿0⍪vm←(~dm)∧x∊alp,num]←V ⋄ end[i]←end⌿⍨2>⌿vm⍪0

⍝ Tokenize ⍺, ⍵ formals
   fm←{mm←⌽⊃(>∘⊃,⊢)⌿⌽m←⍺=' ',⍵ ⋄ 1↓¨(mm∧~m1)(mm∧m1←1⌽m)}
   am aam←'⍺'fm x ⋄ wm wwm←'⍵'fm x
   ((am∨wm)⌿t)←A ⋄ ((aam∨wwm)⌿t)←P ⋄ ((aam∨wwm)⌿end)←end⌿⍨¯1⌽aam∨wwm

⍝ Tokenize Primitives, Atoms
   t[⍸(~dm)∧x∊prms]←P ⋄ t[⍸x∊syna]←A

⍝ Compute dfns regions and type, include } as a child
   t[⍸'{'=x]←F ⋄ 0≠⊃d←¯1⌽+⍀1 ¯1 0['{}'⍳x]:'UNBALANCED DFNS'⎕SIGNAL 2

⍝ Check for out of context dfns formals
   ∨⌿(d=0)∧(t=P)∧IN[pos]∊'⍺⍵':'DFN FORMAL REFERENCED OUTSIDE DFNS'⎕SIGNAL 2

⍝ Compute trad-fns regions
   ∨⌿Z≠t⌿⍨1⌽msk←(d=0)∧'∇'=x:'TRAD-FNS START/END LINES MUST BEGIN WITH ∇'⎕SIGNAL 2
   0≠⊃tm←¯1⌽≠⍀(d=0)∧'∇'=x:'UNBALANCED TRAD-FNS'⎕SIGNAL 2
   ∨⌿Z≠t⌿⍨⊃1 ¯1∨.⌽⊂(2>⌿tm)⍪0:'TRAD-FNS END LINE MUST CONTAIN ∇ ALONE'⎕SIGNAL 2

⍝ Identify Label colons versus others
   t[⍸tm∧(d=0)∧∊((~⊃)∧(<⍀∨⍀))¨':'=(t=Z)⊂IN[pos]]←L

⍝ Tokenize Keywords
   ki←⍸(t=0)∧(d=0)∧(':'=IN[pos])∧1⌽t=V
   t[ki]←K ⋄ end[ki]←end[ki+1] ⋄ t[ki+1]←0
   ERR←'EMPTY COLON IN NON-DFNS CONTEXT, EXPECTED LABEL OR KEYWORD'
   ∨⌿(t=0)∧(d=0)∧':'=IN[pos]:ERR ⎕SIGNAL 2

⍝ Tokenize System Variables
   si←⍸('⎕'=IN[pos])∧1⌽t=V
   t[si]←S ⋄ end[si]←end[si+1] ⋄ t[si+1]←0

⍝ Delete all characters we no longer need from the tree
   d tm t pos end(⌿⍨)←⊂(t≠0)∨x∊'()[]{}:;'

⍝ Tokenize Labels
   ERR←'LABEL MUST CONSIST OF A SINGLE NAME'
   ∨⌿(Z≠t[li-1])∨(V≠t[li←⍸1⌽msk←t=L]):ERR ⎕SIGNAL 2
   t[li]←L ⋄ end[li]←end[li+1]
   d tm t pos end(⌿⍨)←⊂~msk

⍝ Now that all compound data is tokenized, reify n field before tree-building
   n←{1↓⍎¨'0',⍵}@{t=N}(⊂'')@{t=Z}1 ⎕C@{t∊K S}IN∘I¨pos+⍳¨end-pos

⍝ Verify that keywords and system variables are defined and scoped correctly
   KW←'NAMESPACE' 'ENDNAMESPACE' 'END' 'IF' 'ELSEIF' 'ANDIF' 'ORIF' 'ENDIF'
   KW,←'WHILE' 'ENDWHILE' 'UNTIL' 'REPEAT' 'ENDREPEAT' 'LEAVE' 'FOR' 'ENDFOR'
   KW,←'IN' 'INEACH' 'SELECT' 'ENDSELECT' 'CASE' 'CASELIST' 'ELSE' 'WITH'
   KW,←'ENDWITH' 'HOLD' 'ENDHOLD' 'TRAP' 'ENDTRAP' 'GOTO' 'RETURN' 'CONTINUE'
   KW,←'SECTION' 'ENDSECTION' 'DISPOSABLE' 'ENDDISPOSABLE'
   KW,¨⍨←':'
   msk←~KW∊⍨kws←n⌿⍨km←t=K
   ∨⌿msk:('UNRECOGNIZED KEYWORD ',kws⊃⍨⊃⍸msk)⎕SIGNAL 2
   msk←kws∊':NAMESPACE' ':ENDNAMESPACE'
   ∨⌿msk∧km⌿tm:'NAMESPACE SCRIPTS MUST APPEAR AT THE TOP LEVEL'⎕SIGNAL 2
   msk←kws∊KW~':NAMESPACE' ':ENDNAMESPACE' ':SECTION' ':ENDSECTION'
   ∨⌿msk∧~km⌿tm:'STRUCTURED STATEMENTS MUST APPEAR WITHIN TRAD-FNS'⎕SIGNAL 2

⍝ Compute parent vector from d
   p←D2P d

⍝ Compute nameclass of dfns
   k←2×t∊F ⋄ k[∪p⌿⍨(t=P)∧n∊⊂'⍺⍺']←3 ⋄ k[∪p⌿⍨(t=P)∧n∊⊂'⍵⍵']←4

⍝ We will often wrap a set of nodes as children under a Z node
   gz←{z←⍵↑⍨-0≠≢⍵ ⋄ ks←¯1↓⍵
     t[z]←Z ⋄ p[ks]←⊃z ⋄ pos[z]←pos[⊃⍵] ⋄ end[z]←end[⊃⌽z,ks] ⋄ 0}

⍝ Nest top-level root lines as Z nodes
   _←(gz 1⌽⊢)¨(t[i]=Z)⊂i←⍸d=0
   'Non-Z top-level node'assert t[⍸p=⍳≢p]=Z:

⍝ Nest all dfns expression bodies as Z nodes
   _←p[i]{end[⍺]←end[⊃⌽⍵] ⋄ gz¨⍵⊂⍨1,¯1↓t[⍵]=Z}⌸i←⍸t[p]=F
   'Non-Z dfns body node'assert t[⍸t[p]=F]=Z:

⍝ Drop/eliminate any Z nodes that are empty or blank
   _←p[i]{msk[⍺,⍵]←~∧⌿IN[pos[⍵]]∊WS}⌸i←⍸(t[p]=Z)∧p≠⍳≢p⊣msk←t≠Z
   tm n t k pos end(⌿⍨)←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Keyword structures
   nss←n∊⊂':NAMESPACE' ⋄ nse←n∊⊂':ENDNAMESPACE'
   ERR←':NAMESPACE KEYWORD MAY ONLY APPEAR AT BEGINNING OF A LINE'
   Z∨.≠t⌿⍨1⌽nss:ERR ⎕SIGNAL 2
   ERR←'NAMESPACE DECLARATION MAY HAVE ONLY A NAME OR BE EMPTY'
   ∨⌿(Z≠t⌿⍨¯1⌽nss)∧(V≠t⌿⍨¯1⌽nss)∨Z≠t⌿⍨¯2⌽nss:ERR ⎕SIGNAL 2
   ERR←':ENDNAMESPACE KEYWORD MUST APPEAR ALONE ON A LINE'
   ∨⌿Z≠t⌿⍨⊃1 ¯1∨.⌽⊂nse:ERR ⎕SIGNAL 2
   t[nsi←⍸1⌽nss]←M ⋄ t[nei←⍸1⌽nse]←-M
   n[i]←n[1+i←⍸(t=M)∧V=1⌽t] ⋄ end[nsi]←end[nei]
   x←⍸p=⍳≢p ⋄ d←+⍀(t[x]=M)+-t[x]=-M
   0≠⊃⌽d:':NAMESPACE KEYWORD MISSING :ENDNAMESPACE PAIR'⎕SIGNAL 2
   p[x]←x[D2P ¯1⌽d]

⍝ Delete unnecessary namespace nodes from the tree, leave only M's
   msk←~nss∨((¯1⌽nss)∧t=V)∨nse∨1⌽nse
   t k n pos end⌿⍨←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Labels ∘∘∘

⍝ Map guard statements to (G (Z ...) (Z ...))
   ⍝ _←p[i]{
   ⍝   0=+⌿m←':'=IN[pos[⍵]]:⍬
   ⍝   ⊃m:'EMPTY GUARD TEST'⎕SIGNAL 2
   ⍝   1<+⌿m:'TOO MANY GUARDS'⎕SIGNAL 2
   ⍝   t[⍺]←G
   ⍝   gz⊃tx cq←2↑(⊂⍬)⍪⍨⍵⊂⍨1,¯1↓m:
   ⍝   p,←ci←≢p ⋄ t k pos end⍪←0 ⋄ gz cq,ci:
   ⍝ 0}⌸i←⍸t[p[p]]=F

⍝ Parse brackets and parentheses into ¯1 and Z nodes
   _←p[i]{
     x←IN[pos[⍵]] ⋄ bd←+⍀bm←(bo←'['=x)+-bc←']'=x ⋄ pd←+⍀pm←(po←'('=x)+-pc←')'=x
     0≠⊃⌽bd:'UNBALANCED BRACKETS'⎕SIGNAL 2
     0≠⊃⌽pd:'UNBALANCED PARENTHESES'⎕SIGNAL 2
     (po⌿bd)∨.≠⌽pc⌿bd:'OVERLAPPING BRACKETS AND PARENTHESES'⎕SIGNAL 2
     p[⍵]←(⍺,⍵)[1+¯1@{⍵=⍳≢⍵}D2P +⍀¯1⌽bm+pm] ⋄ t[bo⌿⍵]←¯1 ⋄ t[po⌿⍵]←Z
     end[⍵⌿⍨po+bo]←end[⌽⍵⌿⍨pc+bc]
   0}⌸i←⍸(t[p]=Z)∧p≠⍳≢p
   t k n pos end⌿⍨←⊂msk←~IN[pos]∊')' ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Convert semi-colon indexing into Z nodes in the ¯1 nodes
   _←p[i]{gz¨⍵⊂⍨¯1⌽IN[pos[⍵]]∊';]'}⌸i←⍸t[p]=¯1

⍝ Mark bindable nodes
   bm←(t=V)∨(t=A)∧n∊,¨'⎕⍞'
   bm←{bm⊣p[i]{bm[⍺]←(V ¯1≡t[⍵])∨∧⌿bm[⍵]}⌸i←⍸(~bm[p])∧t[p]=Z}⍣≡bm

⍝ Binding nodes
   _←p[i]{
     t[⍵⌿⍨(n[⍵]∊⊂,'←')∧0,¯1↓bm[⍵]]←B
     b v←{(⊃¨x)(1↓¨x←⍵⌿⍨{t[⊃⍵]=B}¨⍵)}¯1⌽¨⍵⊂⍨1,¯1↓t[⍵]∊P B
     ∨⌿~bm[∊v]:'CANNOT BIND ASSIGNMENT VALUE'⎕SIGNAL 2
     p[⍵]←(⍺,b)[0,¯1↓+⍀t[⍵]=B]
     n[b]←n[∊v] ⋄ t[∊v]←¯7
   0}⌸i←⍸(t[p]=Z)∧p≠⍳≢p
   t k n pos end⌿⍨←⊂msk←t≠¯7 ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Anchor variables to earliest binding in matching frame
   rf←p[rz←I@{~(t[⍵]=Z)∧(t[p[⍵]]∊F M)∨p[⍵]=⍵}⍣≡⍨p] ⋄ mk←{⍺[⍵],⍪n[⍵]}
   fr←rf mk⊢fb←fb[⍳⍨rf mk⊢fb←fb I∘(⍳⍨)U⊖rz mk⊢fb←⍸t=B] ⋄ fb,←¯1
   vb←fb[fr⍳rf mk i]@(i←⍸t=V)⊢¯1⍴⍨≢p
   vb[i⌿⍨(rz[i]<rz[b])∨(rz[i]=rz[b])∧i≥b←vb[i←i⌿⍨vb[i]≠¯1]]←¯1
   _←{z/⍨¯1=vb[1⌷z]←fb[fr⍳⍉n I@1⊢z←rf I@0⊢⍵]}⍣≡⍉{rf[⍵],⍪⍵}⍸(t=V)∧vb=¯1
   ∨⌿(t=V)∧vb=¯1:'VALUE ERROR: ALL VARIABLES MUST REFERENCE A BINDING'⎕SIGNAL 6

⍝ Mark unambiguous primitive kinds
   SYSV←,¨'Á' 'A' 'AI' 'AN' 'AV' 'AVU' 'BASE' 'CT' 'D' 'DCT' 'DIV' 'DM'
   SYSV,←,¨'DMX' 'EXCEPTION' 'FAVAIL' 'FNAMES' 'FNUMS' 'FR' 'IO' 'LC' 'LX'
   SYSV,←,¨'ML' 'NNAMES' 'NNUMS' 'NSI' 'NULL' 'PATH' 'PP' 'PW' 'RL' 'RSI'
   SYSV,←,¨'RTL' 'SD' 'SE' 'SI' 'SM' 'STACK' 'TC' 'THIS' 'TID' 'TNAME' 'TNUMS'
   SYSV,←,¨'TPOOL' 'TRACE' 'TRAP' 'TS' 'USING' 'WA' 'WSID' 'WX' 'XSI'
   SYSF←,¨'ARBIN' 'ARBOUT' 'AT' 'C' 'CLASS' 'CLEAR' 'CMD' 'CR' 'CS' 'CSV'
   SYSF,←,¨'CY' 'DF' 'DL' 'DQ' 'DR' 'DT' 'ED' 'EM' 'EN' 'EX' 'EXPORT'
   SYSF,←,¨'FAPPEND' 'FCHK' 'FCOPY' 'FCREATE' 'FDROP' 'FERASE' 'FFT' 'IFFT'
   SYSF,←,¨'FHIST' 'FHOLD' 'FIX' 'FLIB' 'FMT' 'FPROPS' 'FRDAC' 'FRDCI' 'FREAD'
   SYSF,←,¨'FRENAME' 'FREPLACE' 'FRESIZE' 'FSIZE' 'FSTAC' 'FSTIE' 'FTIE'
   SYSF,←,¨'FUNTIE' 'FX' 'INSTANCES' 'JSON' 'KL' 'LOAD' 'LOCK' 'MAP' 'MKDIR'
   SYSF,←,¨'MONITOR' 'NA' 'NAPPEND' 'NC' 'NCOPY' 'NCREATE' 'NDELETE' 'NERASE'
   SYSF,←,¨'NEW' 'NEXISTS' 'NGET' 'NINFO' 'NL' 'NLOCK' 'NMOVE' 'NPARTS'
   SYSF,←,¨'NPUT' 'NQ' 'NR' 'NREAD' 'NRENAME' 'NREPLACE' 'NRESIZE' 'NS'
   SYSF,←,¨'NSIZE' 'NTIE' 'NUNTIE' 'NXLATE' 'OFF' 'OR' 'PFKEY' 'PROFILE'
   SYSF,←,¨'REFS' 'SAVE' 'SH' 'SHADOW' 'SIGNAL' 'SIZE' 'SR' 'SRC' 'STATE'
   SYSF,←,¨'STOP' 'SVC' 'SVO' 'SVQ' 'SVR' 'SVS' 'TCNUMS' 'TGET' 'TKILL' 'TPUT'
   SYSF,←,¨'TREQ' 'TSYNC' 'UCS' 'VR' 'VFI' 'WC' 'WG' 'WN' 'WS' 'XML' 'XT'
   SYSD←,¨'OPT' 'R' 'S'
   k[⍸(t=S)∧n∊'⎕',¨SYSV]←1 ⋄ k[⍸(t=S)∧n∊'⎕',¨SYSF]←2 ⋄ k[⍸(t=S)∧n∊'⎕',¨SYSD]←4
   k[⍸t∊A C N]←1 ⋄ k[⍸n∊,¨prmfs]←2 ⋄ k[⍸n∊,¨prmmo]←3 ⋄ k[⍸n∊,¨prmdo]←4
   k[⍸n∊,¨prmfo]←5
   k[i←⍸msk←(n∊⊂,'∘')∧1⌽n∊⊂,'.']←3 ⋄ end[i]←end[i+1] ⋄ n[i]←⊂,'∘.'
   t k n pos end⌿⍨←⊂msk←~¯1⌽msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p
   t←V@(i←⍸(t=A)∧n∊,¨'⍺⍵')⊢F@{t=M}t ⋄ vb[i]←i

⍝ Infer types of bindings, groups, and variables
   z x←↓⍉p[i]{⍺⍵}⌸i←⍸(t[p]∊B Z)∧p≠⍳≢p
   x←{⍵⌿⍨~∧⍀t[⍵]=¯1}U⌽¨x
   0∨.=≢¨x:'BRACKET SYNTAX REQUIRES FUNCTION OR ARRAY TO ITS LEFT'⎕SIGNAL 2
   _←{
     k[i]←k[vb[i←⍸t=V]]
     k[msk⌿z]←k[x⌿⍨msk←(k[⊃¨x]≠0)∧1=≢¨x] ⋄ z x⌿⍨←⊂~msk
     k[z⌿⍨msk←k[⊃¨x]=4]←3 ⋄ z x⌿⍨←⊂~msk
     k[z⌿⍨msk←{(2 3 5∊⍨k[⊃⍵])∨4=(0⍳⍨∧⍀k[⍵]=1)⌷k,0}∘⌽¨x]←2 ⋄ z x⌿⍨←⊂~msk
     k[z⌿⍨msk←k[⊃∘⌽¨x]=1]←1 ⋄ z x⌿⍨←⊂~msk
   ≢z}⍣(=∨0=⊣)≢z
   'FAILED TO INFER ALL BINDING TYPES'assert 0=≢z:

⍝ SET TYPES FOR VARIABLES

⍝ Strand arrays into atoms
   i←|i⊣km←0<i←i[⍋|(i,⍨←-∪p[i]),p[i←⍸t[p]∊B Z]]
   msk←(t[i]∊C N)∨msk∧⊃1 ¯1∨.⌽⊂msk←km∧(t[i]∊A C N V Z)∧k[i]=1
   np←(≢p)+⍳≢ai←i⌿⍨am←2>⌿msk⍪0 ⋄ p←(np@ai⍳≢p)[p] ⋄ p,←ai ⋄ km←2<⌿0⍪msk
   t k n pos end(⊣,I)←⊂ai ⋄ k[ai]←1 6[∨⌿¨msk⊆t[i]≠N]
   t n pos(⊣@ai⍨)←A(⊂'')(pos[km⌿i]) ⋄ p[msk⌿i]←ai[(msk←msk∧~am)⌿¯1++⍀km]
   i←⍸(t[p]=A)∧(k[p]=6)∧t=N
   p,←i ⋄ t k n pos end(⊣,I)←⊂i ⋄ t k n(⊣@i⍨)←A 1(⊂'')

⍝ PARSE B←D...
⍝ PARSE B←...D

⍝ Group function and value expressions
   i km←⍪⌿p[i]{(⍺⍪⍵)(0,1∨⍵)}⌸i←⍸(t[p]∊B Z)∧(p≠⍳≢p)∧k[p]∊1 2

⍝ Mask and verify dyadic operator right operands
   (dm←¯1⌽k[i]=4)∨.∧(~km)∨k[i]∊0 3 4:'MISSING RIGHT OPERAND'⎕SIGNAL 2

⍝ Refine schizophrenic types
   k[i⌿⍨(k[i]=5)∧dm∨¯1⌽(~km)∨(~dm)∧k[i]∊1 6]←2 ⋄ k[i⌿⍨k[i]=5]←3

⍝ Normalize ∘.
   jm←(t[i]=P)∧n[i]∊⊂,'∘.'
   jm∨.∧1⌽(~km)∨k[i]∊3 4:'MISSING OPERAND TO ∘.'⎕SIGNAL 2
   p←((ji←jm⌿i)@(jj←i⌿⍨¯1⌽jm)⍳≢p)[p] ⋄ t[ji,jj]←t[jj,ji] ⋄ k[ji,jj]←k[jj,ji]
   n[ji,jj]←n[jj,ji] ⋄ pos[ji,jj]←pos[ji,ji] ⋄ end[ji,jj]←end[jj,jj]

⍝ Mask and verify monadic and dyadic operator left operands
   ((2⌽dm)∨1⌽msk←dm∨mm←k[i]=3)∨.∧~km:'MISSING LEFT OPERAND'⎕SIGNAL 2

⍝ Parse function expressions
   np←(≢p)+⍳xc←≢oi←msk⌿i ⋄ p←(np@oi⍳≢p)[p] ⋄ p,←oi ⋄ t k n pos end(⊣,I)←⊂oi
   p[g⌿i]←oi[(g←(~msk)∧(1⌽msk)∨2⌽dm)⌿xc-⌽+⍀⌽msk]
   p[g⌿oi]←(g←msk⌿(1⌽mm)∨2⌽dm)⌿1⌽oi ⋄ t[oi]←O ⋄ n[oi]←⊂''
   pos[oi]←pos[g⌿i][msk⌿¯1++⍀g←(1⌽msk)∧~msk∨1⌽dm]
   k[oi]←3 3⊥↑((msk⌿dm)⍀1+k[dm⌿i]=2)(1+(msk⌿¯1⌽dm)∨k[i⌿⍨(1⌽mm)∨2⌽dm]∊2 3)

⍝ BRACKET INDEXING
⍝ MUTATION/ASSIGNMENTS
⍝ TRAINS

⍝ Parse expression sequences
   i km←⍪⌿p[i]{(⍺⍪⍵)(0,(2≤≢⍵)∧1∨⍵)}⌸i←⍸(t[p]=Z)∧(k[p]=1)∧p≠⍳≢p
   msk←m2∨fm∧~¯1⌽m2←km∧(1⌽km)∧~fm←(t[i]=O)∨(t[i]≠A)∧k[i]=2
   t,←E⍴⍨xc←+⌿msk ⋄ k,←msk⌿msk+m2 ⋄ n,←xc⍴⊂''
   pos,←pos[msk⌿i] ⋄ end,←end[p[msk⌿i]]
   p,←msk⌿¯1⌽(i×~km)+km×x←¯1+(≢p)++⍀msk ⋄ p[km⌿i]←km⌿x

⍝ VERIFY Z/B NODE TYPES MATCH ACTUAL TYPE

⍝ Eliminate Z nodes from the tree
   ERR←'INVARIANT ERROR: Z node with multiple children'
   ERR assert(+⌿(t[p]=Z)∧p≠⍳≢p)=+⌿t=Z:
   zi←p I@{t[p[⍵]]=Z}⍣≡ki←⍸msk←(t[p]=Z)∧t≠Z
   p←(zi@ki⍳≢p)[p] ⋄ t k n pos end(⊣@zi⍨)←t k n pos end I¨⊂ki
   t k n pos end⌿⍨←⊂msk←~msk∨t=Z ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Compute Exports
   msk←(t=B)∧k[I@{t[⍵]≠F}⍣≡⍨p]=0
   xn←msk⌿n ⋄ xt←msk⌿k

   d i←P2D p ⋄ d n t k pos end I∘⊢←⊂i ⋄ sym←∪('')(,'⍵')(,'⍺')'⍺⍺' '⍵⍵',n
   (d t k(-sym⍳n)pos end)(xn xt)sym IN}
