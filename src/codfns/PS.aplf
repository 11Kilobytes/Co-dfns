 PS←{IN←⍵ ⋄ A B C E F G K L M N O P S V Z←1+⍳15 ⋄ types←' ABCEFGKLMNOPSVZ'
   I←{(⊂⍵)⌷⍺} ⋄ U←{⍵⍵⍣¯1 ⍺⍺ ⍵⍵ ⍵}
   assert←{⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}

   1<≢⍴IN:'PARSER REQUIRES A SCALAR/VECTOR INPUT'⎕SIGNAL 11
   1<≡IN:'PARSER REQUIRES A SIMPLE ARRAY'⎕SIGNAL 11
   0≠10|⎕DR IN:'PARSER REQUIRES A CHARACTER ARRAY'⎕SIGNAL 11

⍝ Identify beginnings of lines
   CR LF←⎕UCS 13 10
   linestarts←(⍸1⍪2>⌿IN∊CR LF)⍪≢IN
   quotelines←{
     lines←∪linestarts⍸⍵
     nos←(1 0⍴⍨2×≢lines)⍀'[',(⍕⍪1+lines),⍤1⊢'] '
     beg←linestarts[lines] ⋄ end←linestarts[lines+1]
     m←∊∘⍵¨i←beg+⍳¨end-beg
     ∊nos,(~∘CR LF¨⍪,(IN∘I¨i),⍪' ▔'∘I¨m),CR}

⍝ Group input into lines as a nested vector
   pos←(⍳≢IN)⊆⍨~IN∊CR LF

⍝ Mask strings
   0≠≢lin←⍸⊃∘⌽¨msk←≠⍀¨''''=IN∘I¨pos:{
     EM←'SYNTAX ERROR: UNBALANCED STRING',('S'⌿⍨2≤≢lin),CR
     EM,←quotelines ∊(msk⌿¨pos)[lin]
     EM ⎕SIGNAL 2}⍬

⍝ Remove comments
   pos msk⌿¨⍨←⊂∧⍀¨(~msk←msk∨¯1⌽¨msk)⍲'⍝'=IN∘I¨pos

⍝ Remove leading and trailing whitespace
   WS←⎕UCS 9 32 ⋄ pos msk⌿¨⍨←⊂~(∧⍀∨∧⍀U⌽)∘(WS∊⍨IN∘I)¨pos

⍝ Flatten and separate lines and ⋄ with Z type
   typ←⊃0⍴⊂pos ⋄ typ pos msk(∊,∘⍪⍨)←Z(⊃¨pos)0 ⋄ typ[⍸'⋄'=IN[pos]]←Z

⍝ Tokenize Strings
   end←1+pos ⋄ typ[i←⍸2<⌿0⍪msk]←C ⋄ end[i]←end[⍸2>⌿msk⍪0]
   typ pos end⌿⍨←⊂(typ≠0)∨~msk

⍝ Verify that all open characters are part of the valid character set
   alp←'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
   alp,←'ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüþ'
   alp,←'∆⍙ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ'
   num←⎕D
   synb←'¯[]{}()'':⍺⍵⋄;'
   syna←'⍬⎕⍞#'
   prmfs←'+-×÷|⌈⌊*⍟○!?~∧∨⍲⍱<≤=>≥≠≡≢⍴,⍪⌽⊖⍉↑↓⊂⊆⊃∊⍷/⌿\⍀∩∪⍳⍸⌷⍋⍒⍎⍕⊥⊤⊣⊢⌹∇←→'
   prmos←'¨⍨∘./⌿\⍀⍣&⌶⍠⌸⌺⍤⍥@'
   x←' '@{typ≠0}IN[pos] ⍝ The spaces produce nice invariants
   ∨⌿msk←~x∊alp,num,syna,synb,prmfs,prmos,WS:{
     EM←'SYNTAX ERROR: INVALID CHARACTER(S) IN SOURCE',CR
     EM,←quotelines ⍸msk
     EM ⎕SIGNAL 2}⍬

⍝ Tokenize numbers
   _←{dm[⍵]←∧⍀dm[⍵]}¨(dm∨x∊alp)⊆⍳≢dm←x∊num
   dm∨←('.'=x)∧(¯1⌽dm)∨1⌽dm
   dm∨←('¯'=x)∧1⌽dm
   dm∨←(x∊'EeJj')∧(¯1⌽dm)∧1⌽dm
   ∨⌿(typ=0)∧IN[pos]='¯':'ORPHANED ¯'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='j'}¨dp←⎕C¨dm⊆x:'MULTIPLE J IN NUMBER'⎕SIGNAL 2
   ∨⌿{1<+⌿⍵='e'}¨dp←⊃⍪/{⍵⊆⍨⍵≠'j'}¨dp:'MULTIPLE E IN NUMBER'⎕SIGNAL 2
   ∨⌿'e'=⊃¨dp:'MISSING MANTISSA'⎕SIGNAL 2
   ∨⌿'e'=⊃∘⌽¨dp:'MISSING EXPONENT'⎕SIGNAL 2
   mn ex←↓⍉↑{2↑(⍵⊆⍨⍵≠'e'),⊂''}¨dp
   ∨⌿{1<+⌿'.'=⍵}¨mn,ex:'MULTIPLE . IN NUMBER'⎕SIGNAL 2
   ∨⌿'.'∊¨ex:'REAL NUMBER IN EXPONENT'⎕SIGNAL 2
   ∨⌿{('¯'∊⍵)∧'¯'≠⊃⍵}¨mn,ex:'MISPLACED ¯'⎕SIGNAL 2
   typ[i←⍸2<⌿0⍪dm]←N ⋄ end[i]←end⌿⍨2>⌿dm⍪0

⍝ Tokenize Variables
   typ[i←⍸2<⌿0⍪vm←(~dm)∧x∊alp,num]←V ⋄ end[i]←end⌿⍨2>⌿vm⍪0

⍝ Tokenize ⍺, ⍵ formals
   fm←{mm←⌽⊃(>∘⊃,⊢)⌿⌽m←⍺=' ',⍵ ⋄ 1↓¨(mm∧~m1)(mm∧m1←1⌽m)}
   am aam←'⍺'fm x ⋄ wm wwm←'⍵'fm x
   ((am∨wm)⌿typ)←A ⋄ ((aam∨wwm)⌿typ)←P ⋄ ((aam∨wwm)⌿end)←end⌿⍨¯1⌽aam∨wwm

⍝ Tokenize Primitives, Atoms
   pm←(~dm)∧x∊prmfs,prmos ⋄ (pm⌿typ)←P ⋄ typ[⍸x∊syna]←A

⍝ Compute dfns regions and type, include } as a child
   typ[⍸'{'=x]←F ⋄ 0≠⊃d←¯1⌽+⍀1 ¯1 0['{}'⍳x]:'UNBALANCED DFNS'⎕SIGNAL 2

⍝ Check for out of context dfns formals
   ∨⌿(d=0)∧(typ=P)∧IN[pos]∊'⍺⍵':'DFN FORMAL REFERENCED OUTSIDE DFNS'⎕SIGNAL 2

⍝ Compute trad-fns regions
   ∨⌿Z≠typ⌿⍨1⌽msk←(d=0)∧'∇'=x:'TRAD-FNS START/END LINES MUST BEGIN WITH ∇'⎕SIGNAL 2
   0≠⊃tm←¯1⌽≠⍀(d=0)∧'∇'=x:'UNBALANCED TRAD-FNS'⎕SIGNAL 2
   ∨⌿Z≠typ⌿⍨⊃1 ¯1∨.⌽⊂(2>⌿tm)⍪0:'TRAD-FNS END LINE MUST CONTAIN ∇ ALONE'⎕SIGNAL 2

⍝ Identify Label colons versus others
   typ[⍸tm∧(d=0)∧∊((~⊃)∧(<⍀∨⍀))¨':'=(typ=Z)⊂IN[pos]]←L

⍝ Tokenize Keywords
   ki←⍸(typ=0)∧(d=0)∧(':'=IN[pos])∧1⌽typ=V
   typ[ki]←K ⋄ end[ki]←end[ki+1] ⋄ typ[ki+1]←0
   ERR←'EMPTY COLON IN NON-DFNS CONTEXT, EXPECTED LABEL OR KEYWORD'
   ∨⌿(typ=0)∧(d=0)∧':'=IN[pos]:ERR ⎕SIGNAL 2

⍝ Tokenize System Variables
   si←⍸('⎕'=IN[pos])∧1⌽typ=V
   typ[si]←S ⋄ end[si]←end[si+1] ⋄ typ[si+1]←0

⍝ Delete all characters we no longer need from the tree
   d tm typ pos end(⌿⍨)←⊂(typ≠0)∨x∊'()[]{}:;'

⍝ Tokenize Labels
   ERR←'LABEL MUST CONSIST OF A SINGLE NAME'
   ∨⌿(Z≠typ[li-1])∨(V≠typ[li←⍸1⌽msk←typ=L]):ERR ⎕SIGNAL 2
   typ[li]←L ⋄ end[li]←end[li+1]
   d tm typ pos end(⌿⍨)←⊂~msk

⍝ Now that all compound data is tokenized, reify n field before tree-building
   n←{1↓⍎¨'0',⍵}@{typ=N}(⊂'')@{typ=Z}1 ⎕C@{typ=K}IN∘I¨pos+⍳¨end-pos

⍝ Verify that keywords and system variables are defined and scoped correctly
   KW←'NAMESPACE' 'ENDNAMESPACE' 'END' 'IF' 'ELSEIF' 'ANDIF' 'ORIF' 'ENDIF'
   KW,←'WHILE' 'ENDWHILE' 'UNTIL' 'REPEAT' 'ENDREPEAT' 'LEAVE' 'FOR' 'ENDFOR'
   KW,←'IN' 'INEACH' 'SELECT' 'ENDSELECT' 'CASE' 'CASELIST' 'ELSE' 'WITH'
   KW,←'ENDWITH' 'HOLD' 'ENDHOLD' 'TRAP' 'ENDTRAP' 'GOTO' 'RETURN' 'CONTINUE'
   KW,←'SECTION' 'ENDSECTION' 'DISPOSABLE' 'ENDDISPOSABLE'
   KW,¨⍨←':'
   msk←~KW∊⍨kws←n⌿⍨km←typ=K
   ∨⌿msk:('UNRECOGNIZED KEYWORD ',kws⊃⍨⊃⍸msk)⎕SIGNAL 2
   msk←kws∊':NAMESPACE' ':ENDNAMESPACE'
   ∨⌿msk∧km⌿tm:'NAMESPACE SCRIPTS MUST APPEAR AT THE TOP LEVEL'⎕SIGNAL 2
   msk←kws∊KW~':NAMESPACE' ':ENDNAMESPACE' ':SECTION' ':ENDSECTION'
   ∨⌿msk∧~km⌿tm:'STRUCTURED STATEMENTS MUST APPEAR WITHIN TRAD-FNS'⎕SIGNAL 2

⍝ Compute parent vector from d
   p←D2P d

⍝ We will often wrap a set of nodes as children under a Z node
   gz←{z←⍺↑⍨0≠≢⍵ ⋄ typ[z]←Z ⋄ p[⍵]←z ⋄ pos[z]←pos[⊃⍵,z] ⋄ end[z]←end[⊃⌽z,⍵] ⋄ 0}
   gz←{z←⍵↑⍨-0≠≢⍵ ⋄ k←¯1↓⍵
     typ[z]←Z ⋄ p[k]←⊃z ⋄ pos[z]←pos[⊃⍵] ⋄ end[z]←end[⊃⌽z,k] ⋄ 0}

⍝ Nest top-level root lines as Z nodes
   _←(gz 1⌽⊢)¨(typ[i]=Z)⊂i←⍸d=0
   'Non-Z top-level node'assert typ[⍸p=⍳≢p]=Z:

⍝ Nest all dfns expression bodies as Z nodes
   _←p[i]{end[⍺]←end[⊃⌽⍵] ⋄ gz¨⍵⊂⍨1,¯1↓typ[⍵]=Z}⌸i←⍸typ[p]=F
   'Non-Z dfns body node'assert typ[⍸typ[p]=F]=Z:

⍝ Drop/eliminate any Z nodes that are empty or blank
   _←p[i]{msk[⍺,⍵]←~∧⌿IN[pos[⍵]]∊WS}⌸i←⍸(typ[p]=Z)∧p≠⍳≢p⊣msk←typ≠Z
   tm n typ pos end(⌿⍨)←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Keyword structures
   nss←n∊⊂':NAMESPACE' ⋄ nse←n∊⊂':ENDNAMESPACE'
   ERR←':NAMESPACE KEYWORD MAY ONLY APPEAR AT BEGINNING OF A LINE'
   Z∨.≠typ⌿⍨1⌽nss:ERR ⎕SIGNAL 2
   ERR←'NAMESPACE DECLARATION MAY HAVE ONLY A NAME OR BE EMPTY'
   ∨⌿(Z≠typ⌿⍨¯1⌽nss)∧(V≠typ⌿⍨¯1⌽nss)∨Z≠typ⌿⍨¯2⌽nss:ERR ⎕SIGNAL 2
   ERR←':ENDNAMESPACE KEYWORD MUST APPEAR ALONE ON A LINE'
   ∨⌿Z≠typ⌿⍨⊃1 ¯1∨.⌽⊂nse:ERR ⎕SIGNAL 2
   typ[nsi←⍸1⌽nss]←M ⋄ typ[nei←⍸1⌽nse]←-M
   n[i]←n[1+i←⍸(typ=M)∧V=1⌽typ] ⋄ end[nsi]←end[nei]
   x←⍸p=⍳≢p ⋄ d←+⍀(typ[x]=M)+-typ[x]=-M
   0≠⊃⌽d:':NAMESPACE KEYWORD MISSING :ENDNAMESPACE PAIR'⎕SIGNAL 2
   p[x]←x[D2P ¯1⌽d]

⍝ Delete unnecessary namespace nodes from the tree, leave only M's
   msk←~nss∨((¯1⌽nss)∧typ=V)∨nse∨1⌽nse
   typ n pos end⌿⍨←⊂msk ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Parse Labels ∘∘∘

⍝ Map guard statements to (G (Z ...) (Z ...))
   _←p[i]{
     0=+⌿m←':'=IN[pos[⍵]]:⍬
     ⊃m:'EMPTY GUARD TEST'⎕SIGNAL 2
     1<+⌿m:'TOO MANY GUARDS'⎕SIGNAL 2
     typ[⍺]←G
     t g c←3↑(⊂⍬)⍪⍨⍵⊂⍨1,1↓m∨¯1⌽m
     t c←2↑(⊂⍬)⍪⍨⍵⊂⍨1,¯1↓m
     gz t:
     p,←ci←≢p ⋄ typ pos end⍪←0 ⋄ gz c,ci:
   0}⌸i←⍸typ[p[p]]=F

⍝ Parse brackets and parentheses into ¯1 and Z nodes
   _←p[i]{
     x←IN[pos[⍵]] ⋄ bd←+⍀bm←(bo←'['=x)+-bc←']'=x ⋄ pd←+⍀pm←(po←'('=x)+-pc←')'=x
     0≠⊃⌽bd:'UNBALANCED BRACKETS'⎕SIGNAL 2
     0≠⊃⌽pd:'UNBALANCED PARENTHESES'⎕SIGNAL 2
     (po⌿bd)∨.≠⌽pc⌿bd:'OVERLAPPING BRACKETS AND PARENTHESES'⎕SIGNAL 2
     p[⍵]←(⍺,⍵)[1+¯1@{⍵=⍳≢⍵}D2P +⍀¯1⌽bm+pm] ⋄ typ[bo⌿⍵]←¯1 ⋄ typ[po⌿⍵]←Z
     end[⍵⌿⍨po+bo]←end[⌽⍵⌿⍨pc+bc]
   0}⌸i←⍸typ[p]=Z
   typ n pos end⌿⍨←⊂msk←~IN[pos]∊')' ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Convert semi-colon indexing into Z nodes in the ¯1 nodes
   _←p[i]{gz¨⍵⊂⍨¯1⌽IN[pos[⍵]]∊';]'}⌸i←⍸typ[p]=¯1

⍝ Mark bindable nodes
   bm←(typ=V)∨(typ=A)∧n∊,¨'⎕⍞'
   bm←{bm⊣p[i]{bm[⍺]←(V ¯1≡typ[⍵])∨∧⌿bm[⍵]}⌸i←⍸(~bm[p])∧typ[p]=Z}⍣≡bm

⍝ Binding nodes
   _←p[i]{
     typ[⍵⌿⍨(n[⍵]∊⊂,'←')∧0,¯1↓bm[⍵]]←B
     b t←{(⊃¨x)(1↓¨x←⍵⌿⍨{typ[⊃⍵]=B}¨⍵)}¯1⌽¨⍵⊂⍨1,¯1↓typ[⍵]∊P B
     ∨⌿~bm[∊t]:'CANNOT BIND ASSIGNMENT TARGET'⎕SIGNAL 2
     p[⍵]←(⍺,b)[0,¯1↓+⍀typ[⍵]=B]
     n[b]←n[∊t] ⋄ typ[∊t]←¯7
   0}⌸i←⍸typ[p]=Z
   typ n pos end⌿⍨←⊂msk←typ≠¯7 ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ FREE VARIABLES
⍝ DFNS TYPING

⍝ Infer binding type
   knd←typ∊F P ⋄ _←{knd[x]←knd[y]}⍣{∧⌿=/knd[i]}x y←↓⍉i←p[i],∘⊃∘⌽⌸i←⍸typ[p]∊B Z
   typ←V@{(typ=A)∧n∊,¨'⍺⍵'}F@{typ=M}typ

⍝ Strand arrays into atoms
   i←|i⊣km←0<i←i[⍋|(i,⍨←-∪p[i]),p[i←⍸typ[p]∊B Z]]
   msk←(typ[i]∊C N)∨msk∧⊃1 ¯1∨.⌽⊂msk←km∧(typ[i]∊A C N V Z)∧knd[i]=0
   np←(≢p)+⍳≢ai←i⌿⍨am←2>⌿msk⍪0 ⋄ p←(np@ai⊢⍳≢p)[p] ⋄ p,←ai ⋄ km←2<⌿0⍪msk
   typ knd n pos end(⊣,I)←⊂ai ⋄ knd[ai]←3×∨⌿¨msk⊆typ[i]≠N
   typ n pos(⊣@ai⍨)←A(⊂'')(pos[km⌿i]) ⋄ p[msk⌿i]←ai[(msk←msk∧~am)⌿¯1++⍀km]
   i←⍸(typ[p]=A)∧(knd[p]=3)∧typ=N
   p,←i ⋄ typ knd n pos end(⊣,I)←⊂i ⋄ typ knd n(⊣@i⍨)←A 0(⊂'')

⍝ BRACKET INDEXING
⍝ MUTATION/ASSIGNMENTS
⍝ FUNCTION EXPRESSIONS

⍝ Parse expression sequences
   i←i[⍋|(i,⍨←-∪p[i]),p[i←⍸(typ[p]=Z)∧knd[p]=0]]
   km←km∧⊃1 ¯1∨.⌽⊂km←0<i ⋄ i←|i
   msk←m2∨(knd[i]=1)∧~¯1⌽m2←km∧(1⌽km)∧(knd[i]=0)∨typ[i]=A
   typ,←E⍴⍨xc←+⌿msk ⋄ knd,←msk⌿msk+m2 ⋄ n,←xc⍴⊂''
   pos,←pos[msk⌿i] ⋄ end,←end[p[msk⌿i]]
   p,←msk⌿¯1⌽(i×~km)+km×x←¯1+(≢p)++⍀msk ⋄ p[km⌿i]←km⌿x

⍝ Eliminate Z nodes from the tree
   p[i]←i←⍸(typ[p]=Z)∧p[p]=p ⋄ p[i]←p[p[i←⍸typ[p]=Z]]
   typ knd n pos end⌿⍨←⊂msk←typ≠Z ⋄ p←(⍸~msk)(⊢-1+⍸)msk⌿p

⍝ Compute Exports
   msk←(typ=B)∧knd[I@{typ[⍵]≠F}⍣≡⍨p]=0
   xn←msk⌿n ⋄ xt←msk⌿knd

   d i←P2D p ⋄ d n typ knd pos end I∘⊢←⊂i ⋄ sym←∪('')(,'⍵')(,'⍺')'⍺⍺' '⍵⍵',n
   (d typ knd(-sym⍳n)pos end)(xn xt)sym IN}
