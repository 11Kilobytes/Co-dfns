GC←{
	p t k n fr sl rf fd xi sym←⍵

	⍝ Make sure signal retains the stack
	SIGNAL←{⍎'⍺ ⎕SIGNAL ⍵'}
	
	⍝ Variable generation utilities
	var_ckinds←{
		0∊k←k[⍵]:'STACK VARIABLES HAVE NO C KIND'SIGNAL 99
		('' 'array' 'func' 'moper' 'doper' 'env' 'void')[10||k]
	}
	
	decl_vars←{
		0∊⍺:'CANNOT DECLARE STACK VARIABLE'SIGNAL 99
		1∊|⍺:'CANNOT DECLARE GLOBAL ARRAY'SIGNAL 99
		6∊|⍺:{
			EM←'CANNOT DECLARE AMBIGUOUS GLOBAL'
			EM ⎕SIGNAL 99
		}⍬
		z←'' 'struct cell_'[10≤|⍺]
		z,¨←var_ckinds ⍺
		z,¨←'' '_ptr'[10≥|⍺]
		z,¨←' ' '_box '[¯10≥⍺]
		z,¨←'' '*'[10≤|⍺]
		z,¨←clean_vars sym[|⍵]
		z,¨';'
	}
	
	clean_vars←{
		cequv←'_del_' '_delubar_' 'alpha' 'omega'
		(,¨'∆⍙⍺⍵')⎕R cequv⊢⍵
	}
	
	init_vars←{
		0∊⍺:{
			EM←'CANNOT INITIALIZE STACK VARIABLE'
			EM SIGNAL 99
		}⍬
		(10>|⍺)∧⍺<0:{
			EM←'GLOBAL VARIABLES CANNOT BE MUTABLE'
			EM SIGNAL 99
		}⍬
		z←(≢⍵)⍴⊂⊂''
		i←⍸⍺>0
		z[i]←⊂¨(⍺[i] var_refs ⍵[i]),¨⊂' = NULL;'
		init←{
			z←⊂'err = mk_',⍺,'_box(&',⍵,', NULL);'
			z,←⊂'if (err)'
			z,←⊂TB,'goto fail;'
		z}
		types←var_ckinds ⍺[i]
		names←⍺[i] var_refs ⍵[i]
		z[i]←types init names
		⊃⍪⌿z
	}
	
	var_refs←{
		0∊⍺:{
			EM←'CANNOT REFERENCE STACK VARIABLE'
			EM SIGNAL 99
		}⍬
		z←'' 'loc.' 'lex->' 'dyn->'[⌊10×|⍺]
		z,¨clean_vars sym[|⍵]
	}
	
	var_values←{
		z←'' 'loc.' 'lex->' 'dyn->'[⌊10×|⍺]
		z,¨←clean_vars sym[|⍵]
		z,¨←'' '->value'[⍺<0]
		z[⍸0=⍺]←⊂'*--stkhd'
	z}
	
	kill_vars←{
		type←var_ckinds ⍺
		'release_'∘,¨type,¨'(',¨(⍺ var_refs ⍵),');'
	}

	⍝ All code has an initial prefix
	pref ←⊂'#include "codfns.h"'
	pref,←⊂''
	pref,←⊂'EXPORT int'
	pref,←⊂'DyalogGetInterpreterFunctions(void *p)'
	pref,←⊂'{'
	pref,←⊂'    return set_dwafns(p);'
	pref,←⊂'}'
	pref,←⊂''
	
	⍝ Symbol mapping between primitives and runtime names
	syms ←,¨'+'   '-'   '×'   '÷'   '*'   '⍟'   '|'    '○'     '⌊'    '⌈'   '!'
	nams ←  'add' 'sub' 'mul' 'div' 'exp' 'log' 'res'  'cir'   'min'  'max' 'fac'
	syms,←,¨'<'   '≤'   '='   '≥'   '>'   '≠'   '~'    '∧'     '∨'    '⍲'   '⍱'
	nams,←  'lth' 'lte' 'eql' 'gte' 'gth' 'neq' 'not'  'and'   'lor'  'nan' 'nor'
	syms,←,¨'⌷'   '['   '⍳'   '⍴'   ','   '⍪'   '⌽'    '⍉'     '⊖'    '∊'   '⊃'
	nams,←  'sqd' 'brk' 'iot' 'rho' 'cat' 'ctf' 'rot'  'trn'   'rtf'  'mem' 'dis'
	syms,←,¨'≡'   '≢'   '⊢'   '⊣'   '⊤'   '⊥'   '/'    '⌿'     '\'    '⍀'   '?'
	nams,←  'eqv' 'nqv' 'rgt' 'lft' 'enc' 'dec' 'red'  'rdf'   'scn'  'scf' 'rol'
	syms,←,¨'↑'   '↓'   '¨'   '⍨'   '.'   '⍤'   '⍣'    '∘'     '∪'    '∩'   '←'
	nams,←  'tke' 'drp' 'map' 'com' 'dot' 'rnk' 'pow'  'jot'   'unq'  'int' 'get'
	syms,←,¨'⍋'   '⍒'   '∘.'  '⍷'   '⊂'   '⌹'   '⎕FFT' '⎕IFFT' '%s'   '⊆'   '⎕CONV'
	nams,←  'gdu' 'gdd' 'oup' 'fnd' 'par' 'mdv' 'fft'  'ift'   'scl'  'nst' 'conv'
	syms,←,¨'∇'    ';'    '%u'
	nams,←  'this' 'span' ''
	
	⍝ Convert all primitives to variables
	i←⍸t=P ⋄ t[i]←V ⋄ k[i]←0 ⋄ sym[i]←nams[syms⍳sym[i←|n[i]]]
	
	⍝ We have a vector output for each node in the AST
	z←(≢p)⍴⊂''
	
	⍝ B2: Function bindings
	
	⍝ C2: Closures for functions
	
	⍝ E¯1: Non-returning end of line statement
	
	⍝ E0: Returning end of line statement
	
	⍝ E1: Monadic expression application
	
	⍝ F0: Initialization functions for namespaces
	
	⍝ F2: D-fns functions
	
	⍝ Warn about nodes that appear which we haven't generated
	⎕←(∨⌿msk)↑⍉⍪'Ungenerated nodes: ',⍕,∪(msk←z∊⊂'')⌿N∆[t],∘⍕¨k

	⍝ Assemble all the data together into a single character vector
	∊(pref,⊃⍪⌿z[1⊃P2D p]),¨⊂⎕UCS 13 10
	
	
⍝ Old Stuff

	Zp←{
		n←'fn',⍕⍵
		k[⍵]∊0 2:{
			z ←⊂'int'
			z,←⊂n,'(struct array **z, struct array *l, struct array *r, void *fv[]);'
			z,←⊂''
		z}⍵
		'UNKNOWN FUNCTION TYPE'⎕SIGNAL 16
	}
	Zx←{
		n←sym⊃⍨|n[⍵] ⋄ rid←⍕rf[⍵]
		k[⍵]=0:⊂''
		k[⍵]=1:{
			z ←⊂'struct array *',n,';'
		z}⍵
		k[⍵]=2:{
			z ←⊂'struct closure *',n,';'
			z,←⊂''
			z,←⊂'EXPORT int'
			z,←⊂n,'_dwa(struct localp *zp, struct localp *lp, struct localp *rp)'
			z,←⊂'{'
			z,←⊂'       struct array *z, *l, *r;'
			z,←⊂'       int err;'
			z,←⊂''
			z,←⊂'       l = NULL;'
			z,←⊂'       r = NULL;'
			z,←⊂''
			z,←⊂'       fn',rid,'(NULL, NULL, NULL, NULL);'
			z,←⊂''
			z,←⊂'       err = 0;'
			z,←⊂''
			z,←⊂'       if (lp)'
			z,←⊂'               err = dwa2array(&l, lp->pocket);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);;'
			z,←⊂''
			z,←⊂'       if (rp)'
			z,←⊂'               dwa2array(&r, rp->pocket);'
			z,←⊂''
			z,←⊂'       if (err) {'
			z,←⊂'               release_array(l);'
			z,←⊂'               dwa_error(err);'
			z,←⊂'       }'
			z,←⊂''
			z,←⊂'       err = (',n,'->fn)(&z, l, r, ',n,'->fv);'
			z,←⊂''
			z,←⊂'       release_array(l);'
			z,←⊂'       release_array(r);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);'
			z,←⊂''
			z,←⊂'       err = array2dwa(NULL, z, zp);'
			z,←⊂'       release_array(z);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);'
			z,←⊂''
			z,←⊂'       return 0;'
			z,←⊂'}'
			z,←⊂''
		z}⍵
		⍎'''UNKNOWN EXPORT TYPE''⎕SIGNAL 16'
	}
	Pf←{id←(syms⍳sym[|4⊃⍺])⊃nams
		z ←⊂'*stkhd++ = retain_cell(',id,');'
	z}
	Bf←{id←sym⊃⍨|4⊃⍺
		z ←⊂id,' = retain_cell(stkhd[-1]);'
	z}
	Em←{
		z ←⊂'c = *--stkhd;'
		z,←⊂'w = *--stkhd;'
		z,←⊂'(c->fn)((struct array **)stkhd++, NULL, w, c->fv);'
		z,←⊂'release_cell(c);'
		z,←⊂'release_cell(w);'
	z}
	Cf←{id←⍕4⊃⍺
		z ←⊂'mk_closure((struct closure **)stkhd++, fn',id,', 0);'
	z}
	Ek←{
		z ←⊂'release_cell(*--stkhd);'
		z,←⊂''
	z}
	Er←{
		z ←⊂'*z = *--stkhd;'
		z,←⊂'goto cleanup;'
		z,←⊂''
	z}
	Fn←{id←⍕5⊃⍺ ⋄ x←⍉⊃⍪⌿⍵ ⋄ t←2⌷x ⋄ k←3⌷x
		hsw←(t=O)∨(t=E)∧k∊1 2 ⋄ hsa←((t=E)∧k=2)∨(t=O)∧k∊4 5 7 8
		z ←⊂'int'
		z,←⊂'fn',id,'(struct array **z, '
		z,←⊂'    struct array *l, struct array *r, void *fv[])'
		z,←⊂'{'
		z,←⊂'       void    *stk[128];'
		z,←⊂'       void    **stkhd;'
		z,←hsw⌿⊂' void    *w;'
		z,←hsa⌿⊂' void    *a;'
		z,←hsw⌿⊂' struct  closure *c;'
		z,←⊂''
		z,←⊂'       stkhd = &stk[0];'
		z,←⊂''
		z,← ' ',¨⊃,⌿dis¨⍵
		z,←⊂'       *z = NULL;'
		z,←⊂''
		z,←⊂'cleanup:'
		z,←⊂'       return 0;'
		z,←⊂'}'
		z,←⊂''
	z}
	Fz←{id←⍕5⊃⍺ ⋄ awc←∨⌿(3⌷x){(⍵∊A O)∨(⍵=E)∧⍺>0}2⌷x←⍉⊃⍪⌿⍵
		z ←⊂'int init',id,' = 0;'
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂'init(void)'
		z,←⊂'{'
		z,←⊂' return fn',id,'(NULL, NULL, NULL, NULL);'
		z,←⊂'}'
		z,←⊂''
		z,←⊂'int'
		z,←⊂'fn',id,'(struct array **z, '
		z,←⊂'    struct array *l, struct array *r, void *fv[])'
		z,←⊂'{'
		z,←⊂'       void    *stk[128];'
		z,←⊂'       void    **stkhd;'
		z,← awc⌿⊂'        void    *a, *w;'
		z,← awc⌿⊂'        struct  closure *c;'
		z,←⊂''
		z,←⊂'       if (init',id,')'
		z,←⊂'               return 0;'
		z,←⊂''
		z,←⊂'       stkhd = &stk[0];'
		z,←⊂'       init',id,' = 1;'
		z,←⊂'       cdf_init();'
		z,←⊂''
		z,← ' ',¨⊃,⌿dis¨⍵
		z,←⊂'       return 0;'
		z,←⊂'}'
		z,←⊂''
	z}

	∊,∘(⎕UCS 13 10)¨pref,⊃,⌿(,⌿Zp¨⍸t=F),(,⌿Zx¨xi),(⊂⊂''),dis¨ks ast
}
