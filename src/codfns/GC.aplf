GC←{
	p t k n lx pos end sym IN←⍵

	⍝ Placeholder for mutable values
	mu←(≢p)⍴0

	⍝ Make sure signal retains the stack
	SIGNAL←{⍎'⍺ ⎕SIGNAL ⍵'}

	⍝ Variable generation utilities
	var_ckinds←{
		('' 'array' 'func' 'moper' 'doper' 'env' 'void')[k[⍵]]
	}

	var_names←{
		ceqv←'_del_' '_delubar_' 'alpha' 'omega'
		asym←'∆'     '⍙'         '⍺'     '⍵'
		(,¨asym)⎕R ceqv⊢sym[|n[⍵]]
	}

	var_scopes←{
		'loc.' 'lex->' 'dyn->' 'cdf_prim.' ''[lx[⍵]]
	}

	var_nmvec←{
		0=≢⍵:'wchar_t **',⍺,' = NULL;'
		z←'wchar_t *',⍺,'[] = {'
		z,←⊃{⍺,', ',⍵}⌿'L"'∘,¨sym[|n[⍵]],¨'"'
		z,'};'
	}

	decl_vars←{
		0=≢⍵:0⍴⊂''
		0∊k[⍵]:'CANNOT DECLARE STACK VARIABLE'SIGNAL 99
		∨⌿(k[⍵]=1)∧lx[⍵]>3:'CANNOT DECLARE GLOBAL ARRAY'SIGNAL 99
		∨⌿(k[⍵]=6)∧lx[⍵]>3:'CANNOT DECLARE AMBIGUOUS GLOBAL'SIGNAL 99
		z←'' 'struct cell_'[lx[⍵]<4]
		z,¨←var_ckinds ⍵
		z,¨←'' '_ptr'[lx[⍵]≥4]
		z,¨←' ' '_box '[mu[⍵]]
		z,¨←'' '*'[lx[⍵]<4]
		z,¨←var_names ⍵
		z,¨';'
	}

	init_vars←{
		0=≢⍵:0⍴⊂''
		0∊k[⍵]:'CANNOT INITIALIZE STACK VARIABLE'SIGNAL 99
		z←(≢⍵)⍴⊂''
		i←⍸~mu[⍵] ⋄ z[i],←⊂¨(var_refs ⍵[i]),¨⊂' = NULL;'
		i←⍸mu[⍵]
		z[i],←(var_ckinds ⍵[i]){
			z ←⊂'err = mk_',⍺,'_box(&',⍵,', NULL);'
			z,←⊂'if (err)'
			z,←⊂'	goto cleanup;'
			z,⊂''
		}¨var_refs ⍵[i]
		⊃⍪⌿z
	}

	var_refs←{
		0∊k[⍵]:'CANNOT REFERENCE STACK VARIABLE'SIGNAL 99
		(var_scopes,¨var_names) ⍵
	}

	var_values←{
		z←(var_scopes,¨var_names)⍵
		z,¨←'' '->value'[mu[⍵]]
		z[⍸0=k[,⍵]]←⊂'*--stkhd'
	z}

	⍝ All code has an initial prefix
	pref ←⊂'#include "codfns.h"'
	pref,←⊂''
	pref,←⊂'EXPORT int'
	pref,←⊂'DyalogGetInterpreterFunctions(void *p)'
	pref,←⊂'{'
	pref,←⊂'    return set_dwafns(p);'
	pref,←⊂'}'
	pref,←⊂''

	⍝ We have a vector output for each node in the AST
	zz←(≢p)⍴⊂''

	⍝ B: Function bindings
	i←⍸t[p]=B
	zz[p[i]],←{
		tgt src←var_values p[⍵],⍵
		z ←⊂tgt,' = *stkhd++ = retain_cell(',src,');'
	z}¨i

	⍝ C: Closures for functions
	i←⍸t=C
	zz[i],←{
		id←⊃var_names ⍵
		z ←⊂'err = mk_func((struct cell_func **)stkhd++, ',id,', 0);'
		z,←⊂'if (err)'
		z,←⊂'	goto cleanup;'
		z,⊂''
	}¨i

	⍝ E¯1: Non-returning end of line statement
	i←⍸(t=E)∧k=¯1
	zz[i],←{
		z ←⊂'release_cell(*--stkhd);'
		z,⊂''
	}¨i

	⍝ E0: Returning end of line statement
	i←⍸(t[p]=E)∧k[p]=0
	zz[p[i]],←{
		z ←⊂'*z = retain_cell(',(⊃var_values ⍵),');'
		z,←⊂'goto cleanup;'
		z,⊂''
	}¨i

	⍝ E1: Monadic expression application
	i←⍸(t[p]=E)∧k[p]=1
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		fn arg←var_values ⍵
		z ←⊂'{'
		z,←⊂'	struct cell_func *fn = retain_cell(',fn,');'
		z,←⊂'	struct cell_array *arg = retain_cell(',arg,');'
		z,←⊂''
		z,←⊂'	err = (fn->fptr)((struct cell_array **)stkhd++, NULL, arg, fn);'
		z,←⊂''
		z,←⊂'	release_cell(fn);'
		z,←⊂'	release_cell(arg);'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ E2: Dyadic expression application
	i←⍸(t[p]=E)∧k[p]=2
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		x fn y←var_values ⍵
		z ←⊂'{'
		z,←⊂'	struct cell_array *x = retain_cell(',x,');'
		z,←⊂'	struct cell_func *fn = retain_cell(',fn,');'
		z,←⊂'	struct cell_array *y = retain_cell(',y,');'
		z,←⊂''
		z,←⊂'	err = (fn->ptr)((struct cell_array **)stkhd++, x, y, fn);'
		z,←⊂''
		z,←⊂'	release_cell(x);'
		z,←⊂'	release_cell(fn);'
		z,←⊂'	release_cell(y);'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ G0: Value guards
	i←i[∪⍳⍨p[i←⍸t[p]=G]]
	zz[p[i]],←{
		0=≢i:0⍴⊂''
		test←⊃var_values ⍵
		z ←⊂'{'
		z,←⊂'	struct cell_array *x = ',test,';'
		z,←⊂''
		z,←⊂'	if (array_count(x) != 1) {'
		z,←⊂'		err = 5;'
		z,←⊂'		goto cleanup;'
		z,←⊂'	}'
		z,←⊂''
		z,←⊂'	if (!is_simple(x) || !is_bool(x)) {'
		z,←⊂'		err = 11;'
		z,←⊂'		goto cleanup;'
		z,←⊂'	}'
		z,←⊂''
		z,←⊂'	int t = is_true(x);'
		z,←⊂'	release_cell(x);'⌿⍨0=k[⍵]
		z,←⊂''
		z,←⊂'	if (t) {'
		z,← '		'∘,¨⊃⍪⌿1↓(p[⍵]=p)⌿zz
		z,←⊂'	}'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ F2: D-fns functions
	i←⍸(t=F)∧k=2
	zz[i],←{
		0=≢i:0⍴⊂''
		id←⊃var_names ⍵
		pref,←⊂'int ',id,'(struct cell_array **,'
		pref,←⊂'    struct cell_array *, struct cell_array *,'
		pref,←⊂'    struct cell_func *);'
		z ←⊂'int'
		z,←⊂id,'(struct cell_array **z,'
		z,←⊂'    struct cell_array *alpha, struct cell_array *omega,'
		z,←⊂'    struct cell_func *self)'
		z,←⊂'{'
		z,←⊂''
		z,←⊂'	void *stk[128];'
		z,←⊂'	void **stkhd;'
		z,←⊂'	int err;'
		z,←⊂''
		z,←⊂'	stkhd = &stk[0];'
		z,←⊂'	err = 0;'
		z,←⊂''
		z,← '	',¨⊃⍪⌿(p=⍵)⌿zz
		z,←⊂'cleanup:'
		z,←⊂'	return err;'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ F0: Initialization functions for namespaces
	i←⍸(t=F)∧k=0
	zz[i],←{
		id←⊃var_names ⍵ ⋄ xi←⍸(t=B)∧p=⍵
		z ←⊂'int ',id,'_flag = 0;'
		z,←⊂''
		z,←⊂'EXPORT struct ',id,'_loc {'
		z,←⊂'	int __count;'
		z,←⊂'	wchar_t **__names;'
		z,← '	',¨decl_vars xi
		z,←⊂'} ',id,';'
		z,←⊂''
		z,←⊂(id,'_names')var_nmvec xi
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂id,'_init(void)'
		z,←⊂'{'
		z,←⊂'	struct ',id,'_loc loc;'
		z,←⊂'	void *stk[128];'
		z,←⊂'	void **stkhd;'
		z,←⊂'	int err;'
		z,←⊂''
		z,←⊂'	if (',id,'_flag)'
		z,←⊂'		return 0;'
		z,←⊂''
		z,←⊂'	stkhd = &stk[0];'
		z,←⊂'	',id,'_flag = 1;'
		z,←⊂'	cdf_prim_init();'
		z,←⊂''
		z,←⊂'	loc.__count = ',(⍕≢xi),';'
		z,←⊂'	loc.__names = ',id,'_names;'
		z,← '	',¨init_vars xi
		z,←⊂''
		z,←⊂'	err = 0;'
		z,←⊂''
		z,← '	',¨⊃⍪⌿(p=⍵)⌿zz
		z,←⊂''
		z,←⊂'	',id,' = loc;'
		z,←⊂''
		z,←⊂'cleanup:'
		z,←⊂'	return err;'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ Export functions
	i←⍸(t=B)∧(k=2)∧k[p]=0
	exp←⊃⍪⌿{
		fn ns←var_names ⍵,p[⍵]
		z ←⊂'EXPORT int'
		z,←⊂fn,'(struct cell_array **z, struct cell_array *l, struct cell_array *r)'
		z,←⊂'{'
		z,←⊂'	struct cell_func *self;'
		z,←⊂''
		z,←⊂'	',ns,'_init();'
		z,←⊂''
		z,←⊂'	self = ',ns,'.',fn,';'
		z,←⊂''
		z,←⊂'	return self->fptr(z, l, r, self);'
		z,←⊂'}'
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂fn,'_dwa(void *z, void *l, void *r)'
		z,←⊂'{'
		z,←⊂'	return call_dwa(',fn,', z, l, r);'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ Warn about nodes that appear which we haven't generated
	⎕←(∨⌿msk)↑⍉⍪'Ungenerated nodes: ',⍕,∪(msk←(zz∊⊂'')∧~t∊V)⌿N∆[t],∘⍕¨k

	⍝ Assemble all the data together into a single character vector
	∊(pref,(⊂''),(⊃⍪⌿zz[⍸p=⍳≢p]),exp),¨⊂⎕UCS 13 10
}
