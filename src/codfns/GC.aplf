GC←{
	p t k n fr sl rf fd xi sym←⍵

	syms←0⍴⊂'' ⋄ nams←0⍴⊂''
	syms,←⊂,';' ⋄ nams,←⊂'span'
	syms,←⊂,'←' ⋄ nams,←⊂'get'
	syms,←⊂,'∇' ⋄ nams,←⊂'this'
	syms,←⊂,'+' ⋄ nams,←⊂'add'
	syms,←⊂,'∧' ⋄ nams,←⊂'and'
	syms,←⊂,'[' ⋄ nams,←⊂'brk'
	syms,←⊂,',' ⋄ nams,←⊂'cat'
	syms,←⊂,'⍪' ⋄ nams,←⊂'ctf'
	syms,←⊂,'○' ⋄ nams,←⊂'cir'
	syms,←⊂,'⍨' ⋄ nams,←⊂'com'
	syms,←⊂,'∘' ⋄ nams,←⊂'jot'
	syms,←⊂,'⎕CONV' ⋄ nams,←⊂'conv'
	syms,←⊂,'⊥' ⋄ nams,←⊂'dec'
	syms,←⊂,'⊃' ⋄ nams,←⊂'dis'
	syms,←⊂,'÷' ⋄ nams,←⊂'div'
	syms,←⊂,'↓' ⋄ nams,←⊂'drp'
	syms,←⊂,'¨' ⋄ nams,←⊂'map'
	syms,←⊂,'⊂' ⋄ nams,←⊂'par'
	syms,←⊂,'⊤' ⋄ nams,←⊂'enc'
	syms,←⊂,'=' ⋄ nams,←⊂'eql'
	syms,←⊂,'*' ⋄ nams,←⊂'exp'
	syms,←⊂,'!' ⋄ nams,←⊂'fac'
	syms,←⊂,'⎕FFT' ⋄ nams,←⊂'fft'
	syms,←⊂,'⎕IFFT' ⋄ nams,←⊂'ift'
	syms,←⊂,'⍷' ⋄ nams,←⊂'fnd'
	syms,←⊂,'⍒' ⋄ nams,←⊂'gdd'
	syms,←⊂,'⍋' ⋄ nams,←⊂'gdu'
	syms,←⊂,'>' ⋄ nams,←⊂'gth'
	syms,←⊂,'≥' ⋄ nams,←⊂'gte'
	syms,←⊂,'⌷' ⋄ nams,←⊂'sqd'
	syms,←⊂,'⍳' ⋄ nams,←⊂'iot'
	syms,←⊂,'.' ⋄ nams,←⊂'dot'
	syms,←⊂,'∩' ⋄ nams,←⊂'int'
	syms,←⊂,'⊣' ⋄ nams,←⊂'lft'
	syms,←⊂,'<' ⋄ nams,←⊂'lth'
	syms,←⊂,'≤' ⋄ nams,←⊂'lte'
	syms,←⊂,'⍟' ⋄ nams,←⊂'log'
	syms,←⊂,'≡' ⋄ nams,←⊂'eqv'
	syms,←⊂,'⌹' ⋄ nams,←⊂'mdv'
	syms,←⊂,'⌈' ⋄ nams,←⊂'max'
	syms,←⊂,'∊' ⋄ nams,←⊂'mem'
	syms,←⊂,'⌊' ⋄ nams,←⊂'min'
	syms,←⊂,'×' ⋄ nams,←⊂'mul'
	syms,←⊂,'⊆' ⋄ nams,←⊂'nst'
	syms,←⊂,'~' ⋄ nams,←⊂'not'
	syms,←⊂,'⍲' ⋄ nams,←⊂'nan'
	syms,←⊂,'≠' ⋄ nams,←⊂'neq'
	syms,←⊂,'≢' ⋄ nams,←⊂'nqv'
	syms,←⊂,'⍱' ⋄ nams,←⊂'nor'
	syms,←⊂,'∨' ⋄ nams,←⊂'lor'
	syms,←⊂,'∘.' ⋄ nams,←⊂'oup'
	syms,←⊂,'⍣' ⋄ nams,←⊂'pow'
	syms,←⊂,'⍤' ⋄ nams,←⊂'rnk'
	syms,←⊂,'/' ⋄ nams,←⊂'red'
	syms,←⊂,'⌿' ⋄ nams,←⊂'rdf'
	syms,←⊂,'?' ⋄ nams,←⊂'rol'
	syms,←⊂,'⌽' ⋄ nams,←⊂'rot'
	syms,←⊂,'⊖' ⋄ nams,←⊂'rtf'
	syms,←⊂,'|' ⋄ nams,←⊂'res'
	syms,←⊂,'⊢' ⋄ nams,←⊂'rgt'
	syms,←⊂,'%s' ⋄ nams,←⊂'scl'
	syms,←⊂,'\' ⋄ nams,←⊂'scn'
	syms,←⊂,'⍀' ⋄ nams,←⊂'scf'
	syms,←⊂,'⍴' ⋄ nams,←⊂'rho'
	syms,←⊂,'-' ⋄ nams,←⊂'sub'
	syms,←⊂,'↑' ⋄ nams,←⊂'tke'
	syms,←⊂,'⍉' ⋄ nams,←⊂'trn'
	syms,←⊂,'∪' ⋄ nams,←⊂'unq'
	
	gck←0⍴⊂0 0 ⋄ gcv←0⍴⊂''
	gck,←(A 1)(A 6)
	gcv,←'Aa' 'As'
	gck,←(P 0)(P 1)(P 2)(P 3)(P 4)
	gcv,←'Pv' 'Pv' 'Pf' 'Po' 'Po'
	gck,←⊂E 6
	gcv,←⊂'Ei'
	gck,←(B 1)(B 2)(B 3)(B 4)
	gcv,←'Bv' 'Bf' 'Bo' 'Bo'
	gck,←⊂E 4
	gcv,←⊂'Eb'
	gck,←(E 1)(E 2)
	gcv,←'Em' 'Ed'
	gck,←(O 1)(O 2)(O 4) (O 5) (O 7) (O 8)
	gcv,←'Ov' 'Of' 'Ovv' 'Ofv' 'Ovf' 'Off'
	gck,←(E ¯1)(E 0)
	gcv,←'Ek'  'Er' 
	gck,←(C 1)(C 2)(F 2)(F 3)(F 4)
	gcv,←'Ca' 'Cf' 'Fn' 'Fm' 'Fd'
	gck,←⊂G 0
	gcv,←⊂'Gd'
	gck,←⊂F 0
	gcv,←⊂'Fz'

	pref ←⊂'#include "codfns.h"'
	pref,←⊂''
	pref,←⊂'EXPORT int'
	pref,←⊂'DyalogGetInterpreterFunctions(void *p)'
	pref,←⊂'{'
	pref,←⊂'    return set_dwafns(p);'
	pref,←⊂'}'
	pref,←⊂''

	var_ckinds←{
		0∊⍵:'STACK VARIABLES HAVE NO C KIND'⎕SIGNAL 99
		types←'' 'array' 'func' 'moper' 'doper'
		types,←'env' 'void'
		types[10||⍵]
	}
	decl_vars←{
		0∊⍺:'CANNOT DECLARE STACK VARIABLE'⎕SIGNAL 99
		1∊|⍺:'CANNOT DECLARE GLOBAL ARRAY'⎕SIGNAL 99
		6∊|⍺:{
			EM←'CANNOT DECLARE AMBIGUOUS GLOBAL'
			EM ⎕SIGNAL 99
		}⍬
		z←'' 'struct cell_'[10≤|⍺]
		z,¨←var_ckinds ⍺
		z,¨←'' '_ptr'[10≥|⍺]
		z,¨←' ' '_box '[¯10≥⍺]
		z,¨←'' '*'[10≤|⍺]
		z,¨←clean_vars sym[|⍵]
		z,¨';'
	}
	clean_vars←{
		cequv←'_del_' '_delubar_' 'alpha' 'omega'
		(,¨'∆⍙⍺⍵')⎕R cequv⊢⍵
	}
	init_vars←{
		0∊⍺:{
			EM←'CANNOT INITIALIZE STACK VARIABLE'
			EM ⎕SIGNAL 99
		}⍬
		(10>|⍺)∧⍺<0:{
			EM←'GLOBAL VARIABLES CANNOT BE MUTABLE'
			EM ⎕SIGNAL 99
		}⍬
		z←(≢⍵)⍴⊂⊂''
		i←⍸⍺>0
		z[i]←⊂¨(⍺[i] var_refs ⍵[i]),¨⊂' = NULL;'
		init←{
			z←⊂'err = mk_',⍺,'_box(&',⍵,', NULL);'
			z,←⊂'if (err)'
			z,←⊂TB,'goto fail;'
		z}
		types←var_ckinds ⍺[i]
		names←⍺[i] var_refs ⍵[i]
		z[i]←types init names
		⊃⍪⌿z
	}
	var_refs←{
		0∊⍺:{
			EM←'CANNOT REFERENCE STACK VARIABLE'
			EM ⎕SIGNAL 99
		}⍬
		z←'' 'loc.' 'lex->' 'dyn->'[⌊10×|⍺]
		z,¨clean_vars sym[|⍵]
	}
	var_values←{
		z←'' 'loc.' 'lex->' 'dyn->'[⌊10×|⍺]
		z,¨←clean_vars sym[|⍵]
		z,¨←'' '->value'[⍺<0]
		z[⍸0=⍺]←⊂'*--stkhd'
	z}
	kill_vars←{
		type←var_ckinds ⍺
		'release_'∘,¨type,¨'(',¨(⍺ var_refs ⍵),');'
	}
	Zp←{
		n←'fn',⍕⍵
		k[⍵]∊0 2:{
			z ←⊂'int'
			z,←⊂n,'(struct array **z, struct array *l, struct array *r, void *fv[]);'
			z,←⊂''
		z}⍵
		'UNKNOWN FUNCTION TYPE'⎕SIGNAL 16
	}
	Zx←{
		n←sym⊃⍨|n[⍵] ⋄ rid←⍕rf[⍵]
		k[⍵]=0:⊂''
		k[⍵]=1:{
			z ←⊂'struct array *',n,';'
		z}⍵
		k[⍵]=2:{
			z ←⊂'struct closure *',n,';'
			z,←⊂''
			z,←⊂'EXPORT int'
			z,←⊂n,'_dwa(struct localp *zp, struct localp *lp, struct localp *rp)'
			z,←⊂'{'
			z,←⊂'       struct array *z, *l, *r;'
			z,←⊂'       int err;'
			z,←⊂''
			z,←⊂'       l = NULL;'
			z,←⊂'       r = NULL;'
			z,←⊂''
			z,←⊂'       fn',rid,'(NULL, NULL, NULL, NULL);'
			z,←⊂''
			z,←⊂'       err = 0;'
			z,←⊂''
			z,←⊂'       if (lp)'
			z,←⊂'               err = dwa2array(&l, lp->pocket);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);;'
			z,←⊂''
			z,←⊂'       if (rp)'
			z,←⊂'               dwa2array(&r, rp->pocket);'
			z,←⊂''
			z,←⊂'       if (err) {'
			z,←⊂'               release_array(l);'
			z,←⊂'               dwa_error(err);'
			z,←⊂'       }'
			z,←⊂''
			z,←⊂'       err = (',n,'->fn)(&z, l, r, ',n,'->fv);'
			z,←⊂''
			z,←⊂'       release_array(l);'
			z,←⊂'       release_array(r);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);'
			z,←⊂''
			z,←⊂'       err = array2dwa(NULL, z, zp);'
			z,←⊂'       release_array(z);'
			z,←⊂''
			z,←⊂'       if (err)'
			z,←⊂'               dwa_error(err);'
			z,←⊂''
			z,←⊂'       return 0;'
			z,←⊂'}'
			z,←⊂''
		z}⍵
		⍎'''UNKNOWN EXPORT TYPE''⎕SIGNAL 16'
	}
	Pf←{id←(syms⍳sym[|4⊃⍺])⊃nams
		z ←⊂'*stkhd++ = retain_cell(',id,');'
	z}
	Bf←{id←sym⊃⍨|4⊃⍺
		z ←⊂id,' = retain_cell(stkhd[-1]);'
	z}
	Em←{
		z ←⊂'c = *--stkhd;'
		z,←⊂'w = *--stkhd;'
		z,←⊂'(c->fn)((struct array **)stkhd++, NULL, w, c->fv);'
		z,←⊂'release_cell(c);'
		z,←⊂'release_cell(w);'
	z}
	Cf←{id←⍕4⊃⍺
		z ←⊂'mk_closure((struct closure **)stkhd++, fn',id,', 0);'
	z}
	Ek←{
		z ←⊂'release_cell(*--stkhd);'
		z,←⊂''
	z}
	Er←{
		z ←⊂'*z = *--stkhd;'
		z,←⊂'goto cleanup;'
		z,←⊂''
	z}
	Fn←{id←⍕5⊃⍺ ⋄ x←⍉⊃⍪⌿⍵ ⋄ t←2⌷x ⋄ k←3⌷x
		hsw←(t=O)∨(t=E)∧k∊1 2 ⋄ hsa←((t=E)∧k=2)∨(t=O)∧k∊4 5 7 8
		z ←⊂'int'
		z,←⊂'fn',id,'(struct array **z, '
		z,←⊂'    struct array *l, struct array *r, void *fv[])'
		z,←⊂'{'
		z,←⊂'       void    *stk[128];'
		z,←⊂'       void    **stkhd;'
		z,←hsw⌿⊂' void    *w;'
		z,←hsa⌿⊂' void    *a;'
		z,←hsw⌿⊂' struct  closure *c;'
		z,←⊂''
		z,←⊂'       stkhd = &stk[0];'
		z,←⊂''
		z,← ' ',¨⊃,⌿dis¨⍵
		z,←⊂'       *z = NULL;'
		z,←⊂''
		z,←⊂'cleanup:'
		z,←⊂'       return 0;'
		z,←⊂'}'
		z,←⊂''
	z}
	Fz←{id←⍕5⊃⍺ ⋄ awc←∨⌿(3⌷x){(⍵∊A O)∨(⍵=E)∧⍺>0}2⌷x←⍉⊃⍪⌿⍵
		z ←⊂'int init',id,' = 0;'
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂'init(void)'
		z,←⊂'{'
		z,←⊂' return fn',id,'(NULL, NULL, NULL, NULL);'
		z,←⊂'}'
		z,←⊂''
		z,←⊂'int'
		z,←⊂'fn',id,'(struct array **z, '
		z,←⊂'    struct array *l, struct array *r, void *fv[])'
		z,←⊂'{'
		z,←⊂'       void    *stk[128];'
		z,←⊂'       void    **stkhd;'
		z,← awc⌿⊂'        void    *a, *w;'
		z,← awc⌿⊂'        struct  closure *c;'
		z,←⊂''
		z,←⊂'       if (init',id,')'
		z,←⊂'               return 0;'
		z,←⊂''
		z,←⊂'       stkhd = &stk[0];'
		z,←⊂'       init',id,' = 1;'
		z,←⊂'       cdf_init();'
		z,←⊂''
		z,← ' ',¨⊃,⌿dis¨⍵
		z,←⊂'       return 0;'
		z,←⊂'}'
		z,←⊂''
	z}

	d i←P2D p ⋄ ast←(⍉↑d p t k n(⍳≢p)fr sl fd)[i;] ⋄ ks←{⍵⊂[0]⍨(⊃⍵)=⍵[;0]}
	NOTFOUND←{('[GC] UNSUPPORTED NODE TYPE ',N∆[⊃⍵],⍕⊃⌽⍵)⎕SIGNAL 16}
	dis←{0=2⊃h←,1↑⍵:'' ⋄ (≢gck)=i←gck⍳⊂h[2 3]:NOTFOUND h[2 3] ⋄ h(⍎i⊃gcv)ks 1↓⍵}
	∊,∘(⎕UCS 13 10)¨pref,⊃,⌿(,⌿Zp¨⍸t=F),(,⌿Zx¨xi),(⊂⊂''),dis¨ks ast
}
