GC←{
	p t k n lx mu lv fv pos end sym IN←⍵

	⍝ Make sure signal retains the stack
	SIGNAL←{⍎'⍺ ⎕SIGNAL ⍵'}
	
	⍝ Text utilities
	csep←{¯2↓⊃,⌿(⍕¨⍵),¨⊂', '}

	⍝ Variable generation utilities
	var_ckinds←{
		('' 'array' 'func' 'moper' 'doper' 'env' 'void')[k[⍵]]
	}

	var_names←{
		ceqv←'_del_' '_delubar_' 'alpha' 'omega'
		asym←'∆'     '⍙'         '⍺'     '⍵'
		(,¨asym)⎕R ceqv⊢sym[|n[⍵]]
	}

	var_scopes←{
		(0⍴⊂''),'loc->' 'lex->' 'dyn->' 'cdf_prim.' '' ''[lx[⍵]]
	}

	var_nmvec←{
		0=≢⍵:'wchar_t **',⍺,' = NULL;'
		z←'wchar_t *',⍺,'[] = {'
		z,←⊃{⍺,', ',⍵}⌿'L"'∘,¨sym[|n[⍵]],¨'"'
		z,'};'
	}

	decl_vars←{
		0=≢⍵:0⍴⊂''
		0∊k[⍵]:'CANNOT DECLARE STACK VARIABLE'SIGNAL 99
		∨⌿(k[⍵]=1)∧lx[⍵]>3:'CANNOT DECLARE GLOBAL ARRAY'SIGNAL 99
		∨⌿(k[⍵]=6)∧lx[⍵]>3:'CANNOT DECLARE AMBIGUOUS GLOBAL'SIGNAL 99
		z  ←'' 'extern '[lx[⍵]=5]
		z,¨←'' 'struct cell_'[lx[⍵]≠4]
		z,¨←var_ckinds ⍵
		z,¨←'' '_ptr'[lx[⍵]=4]
		z,¨←' ' '_box '[mu[⍵]]
		z,¨←'' '*'[lx[⍵]≠4]
		z,¨←var_names ⍵
		z,¨';'
	}

	init_vars←{
		0=≢⍵:0⍴⊂''
		0∊k[⍵]:'CANNOT INITIALIZE STACK VARIABLE'SIGNAL 99
		z←(≢⍵)⍴⊂''
		i←⍸~mu[⍵] ⋄ z[i],←⊂¨(var_refs ⍵[i]),¨⊂' = NULL;'
		i←⍸mu[⍵]
		z[i],←(var_ckinds ⍵[i]){
			z ←⊂'err = mk_',⍺,'_box(&',⍵,', NULL);'
			z,←⊂'if (err)'
			z,←⊂'	goto cleanup;'
			z,⊂''
		}¨var_refs ⍵[i]
		⊃⍪⌿z
	}

	var_refs←{
		0∊k[⍵]:'CANNOT REFERENCE STACK VARIABLE'SIGNAL 99
		(var_scopes,¨var_names) ⍵
	}

	var_values←{
		z←(var_scopes,¨var_names)⍵
		z,¨←'' '->value'[mu[⍵]]
		z[⍸0=k[,⍵]]←⊂'*--stkhd'
	z}

	⍝ All code has an initial prefix
	pref ←⊂'#include "codfns.h"'
	pref,←⊂''
	pref,←⊂'EXPORT int'
	pref,←⊂'DyalogGetInterpreterFunctions(void *p)'
	pref,←⊂'{'
	pref,←⊂'    return set_dwafns(p);'
	pref,←⊂'}'
	pref,←⊂''
	
	⍝ We declare all external variables in the prefix
	pref,←decl_vars ⍸(t=V)∧lx=5
	pref,←⊂''

	⍝ We have a vector output for each node in the AST
	zz←(≢p)⍴⊂''
	
	⍝ Z¯N: Error nodes
	i←⍸(t=Z)∧k<0
	zz[i],←{
		z ←⊂'err = ',(⍕|k[⍵]),';'
		z,←⊂'goto cleanup;'
		z,⊂''
	}¨i
	
	⍝ A1: Simple arrays
	i←⍸(t=A)∧k=1
	atypes←'BOOL' 'SINT'    'SINT'    'INT'     'DBL'    'CMPX' 
	ctypes←'char' 'int16_t' 'int16_t' 'int32_t' 'double' 'struct apl_cmpx'
	drtypes←11     83        163       323       645      1289
	atypes,←'CHAR8'   'CHAR16'   'CHAR32'
	ctypes,←'uint8_t' 'uint16_t' 'uint32_t'
	drtypes,←80        160        320
	zz[i],←{
		rnk←≢shp←⍴dat←(|n[⍵])⊃sym ⋄ dri←drtypes⍳⎕DR dat
		atp←dri⊃atypes ⋄ ctp←dri⊃ctypes
		dat←'¯'⎕R'-'∘⍕¨⎕UCS⍣(0=10|⎕DR dat)⊃⍣(0=≢,dat)⊢dat
		z ←⊂'{'
		z,←⊂'	struct cell_array *arr;'
		z,←⊂''
		z,←⊂'	enum array_type typ = ARR_',atp,';'
		z,←⊂'	unsigned int rnk = ',(⍕rnk),';'
		z,←⊂'	',ctp,' dat[] = {',(csep dat),'};'
		z,←⊂''
		z,←⊂'	err = mk_array(&arr, typ, STG_HOST, rnk);'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,← '	',¨shp{'arr->shape[',(⍕⍵),'] = ',(⍕⍺),';'}¨⍳≢shp
		z,←⊂''
		z,←⊂'	err = fill_array(arr, dat);'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	*stkhd++ = arr;'
		z,⊂'}'
	}¨i
	
	⍝ A7: Stranded Arrays
	i←⍸(t[p]=A)∧k[p]=7
	zz[∪p[i]],←p[i]{
		vs←var_values ⍵
		z ←⊂'{'
		z,←⊂'	struct cell_array *arr, **dat;'
		z,←⊂''
		z,←⊂'	unsigned int rnk = 1;'
		z,←⊂'	size_t shp[] = {',(⍕≢vs),'};'
		z,←⊂''
		z,←⊂'	err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	arr->shape[0] = ',(⍕≢vs),';'
		z,←⊂''
		z,←⊂'	dat = arr->values;'
		z,←⊂''
		z,←vs{'	dat[',(⍕⍵),'] = ',⍺,';'}¨⍳≢⍵
		z,←⊂''
		z,←{'	retain_cell(',⍵,');'}¨vs⌿⍨k[⍵]≠0
		z,←⊂''
		z,←⊂'	*stkhd++ = arr;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ B: Function bindings
	i←⍸t[p]=B
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		tgt src←var_values ⍵
		⊂⊂tgt,' = *stkhd++ = retain_cell(',src,');'
	}⌸i

	⍝ C: Closures for functions
	i←⍸t[p]=C
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		ctyp←'func' 'func' 'func' 'moper' 'doper'⊃⍨k[⍺]
		vc←(≢⍵)-fc←0 1 2 4 8[k[⍺]]
		fs vs←{(fc↑⍵)(fc↓⍵)}⍵
		fids←var_refs fs
		vids←var_refs vs[⍋n[vs]]
		z ←⊂'{'
		z,←⊂'	struct cell_',ctyp,' *k;'
		z,←⊂''
		z,←⊂'	err = mk_',ctyp,'(&k, ',(csep fids),', ',(⍕vc),');'
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,← '	k->fv['∘,¨(⍕¨⍳vc),¨'] = retain_cell('∘,¨vids,¨⊂');'
		z,←(⊂'')⌿⍨1⌊vc
		z,←⊂'	*stkhd++ = k;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ E¯1: Non-returning end of line statement
	i←⍸(t=E)∧k=¯1
	zz[i],←{
		z ←⊂'release_cell(*--stkhd);'
		z,⊂''
	}¨i

	⍝ E0: Returning end of line statement
	i←⍸(t[p]=E)∧k[p]=0
	zz[p[i]],←{
		id←⊃var_values ⍵
		z ←⊂'*z = ',id,';'
		z,←(⊂'retain_cell(',id,');')⌿⍨0≠k[⍵]
		z,←⊂'goto cleanup;'
		z,⊂''
	}¨i
	
	⍝ E1/2: Expression application
	i←⍸(t[p]=E)∧k[p]∊1 2
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		x fn y←var_values⊢xi fi yi←¯3↑⍵
		z ←⊂'{'
		z,←(⊂'	struct cell_array *x = ',x,';')⌿⍨k[⍺]=2
		z,←⊂'	struct cell_func *fn = ',fn,';'
		z,←⊂'	struct cell_array *y = ',y,';'
		z,←⊂'	struct cell_array *dst;'
		z,←⊂''
		z,←(⊂'	err = (fn->fptr_mon)(&dst, y, fn);')⌿⍨k[⍺]=1
		z,←(⊂'	err = (fn->fptr_dya)(&dst, x, y, fn);')⌿⍨k[⍺]=2
		z,←(⊂'')⌿⍨0∊k[⍵]
		z,←(⊂'	release_array(x);')⌿⍨(0=k[xi])∧k[⍺]=2
		z,←(⊂'	release_func(fn);')⌿⍨0=k[fi]
		z,←(⊂'	release_array(y);')⌿⍨0=k[yi]
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	*stkhd++ = dst;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i
	
	⍝ E4: Modified Assignment
	i←⍸(t[p]=E)∧k[p]=4
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		tgt←⊃var_refs 1↑⍵
		fn src←var_values ¯2↑⍵
		z ←⊂'{'
		z,←⊂'	struct cell_array_box *bx = ',tgt,';'
		z,←⊂'	struct cell_func *fn = ',fn,';'
		z,←⊂'	struct cell_array *y = ',src,';'
		z,←⊂'	struct cell_array *x = bx->value;'
		z,←⊂''
		z,←⊂'	err = (fn->fptr_dya)(&bx->value, x, y, fn);'
		z,←(⊂'')⌿⍨0=k[⍵[1]]
		z,←('	release_func(fn);')⌿⍨0=k[⍵[1]]
		z,←⊂''
		z,←⊂'	if (err) {'
		z,←(⊂'		release_array(y);')⌿⍨0=k[⍵[1]]
		z,←⊂'		goto cleanup;'
		z,←⊂'	}'
		z,←⊂''
		z,←⊂'	release_array(x);'
		z,←⊂''
		z,←(⊂'	*stkhd++ = y;')⌿⍨0=k[⍵[2]]
		z,←(⊂'	*stkhd++ = retain_cell(y);')⌿⍨0≠k[⍵[2]]
		z,←⊂'}'
		⊂z,⊂''
	}⌸i
	
	⍝ Om: Monadic operands
	i←⍸(t[p]=O)∧k[p]∊1 2
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		lop op←var_values ⍵
		ltyp←'array' 'func'⊃⍨k[⍺]=2
		fns←csep 'op->fptr_'∘,¨(⊃ltyp),¨'md'
		z ←⊂'{'
		z,←⊂'	struct cell_',ltyp,' *x = ',lop,';'
		z,←⊂'	struct cell_moper *op = ',op,';'
		z,←⊂'	struct cell_func *dst;'
		z,←⊂''
		z,←⊂'	err = apply_mop(&dst, op, ',fns,', x);'
		z,←⊂''
		z,←(⊂'	release_',ltyp,'(x);')⌿⍨0=k[⍵[0]]
		z,←(⊂'	release_moper(op);')⌿⍨0=k[⍵[1]]
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	*stkhd++ = dst;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i
	
	⍝ Od: Dyadic operands
	i←⍸(t[p]=O)∧k[p]∊4 5 7 8
	zz[∪p[i]],←p[i]{
		0=≢⍵:⊂0⍴⊂''
		lop op rop←var_values ⍵
		ltyp←'array' 'func'⊃⍨k[⍺]∊5 8
		rtyp←'array' 'func'⊃⍨k[⍺]∊7 8
		fns←csep 'op->fptr_'∘,¨(⊃rtyp),¨(⊃ltyp),¨'md'
		z ←⊂'{'
		z,←⊂'	struct cell_',ltyp,' *x = ',lop,';'
		z,←⊂'	struct cell_doper *op = ',op,';'
		z,←⊂'	struct cell_',rtyp,' *y = ',rop,';'
		z,←⊂'	struct cell_func *dst;'
		z,←⊂''
		z,←⊂'	err = apply_dop(&dst, op, ',fns,', x, y);'
		z,←⊂''
		z,←(⊂'	release_',ltyp,'(x);')⌿⍨0=k[⍵[0]]
		z,←(⊂'	release_doper(op);')⌿⍨0=k[⍵[1]]
		z,←(⊂'	release_',rtyp,'(y);')⌿⍨0=k[⍵[2]]
		z,←⊂''
		z,←⊂'	if (err)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	*stkhd++ = dst;'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ G0: Value guards
	i←i[∪⍳⍨p[i←⍸t[p]=G]]
	zz[p[i]],←{
		0=≢i:0⍴⊂''
		test←⊃var_values ⍵
		z ←⊂'{'
		z,←⊂'	struct cell_array *x = ',test,';'
		z,←⊂''
		z,←⊂'	err = guard_check(x);'
		z,←⊂''
		z,←(⊂'	release_array(x);')⌿⍨0=k[⍵]
		z,←⊂''
		z,←⊂'	if (err > 0)'
		z,←⊂'		goto cleanup;'
		z,←⊂''
		z,←⊂'	if (!err) {'
		z,← '		'∘,¨⊃⍪⌿1↓(p[⍵]=p)⌿zz
		z,←⊂'		err = -1;'
		z,←⊂'		goto cleanup;'
		z,←⊂'	}'
		z,←⊂''
		z,←⊂'	err = 0;'
		z,←⊂'}'
		z,⊂''
	}¨i
	
	decl_lex←{
		0=≢v←{⍵[⍋n[⍵]]}⊃fv[⍵]:0⍴⊂''
		z ←⊂'struct lex_vars {'
		z,←'	',¨decl_vars v
		z,←⊂'} *lex;'
		z,←⊂''
		z,←⊂'lex = (struct lex_vars *)',⍺,'->fv;'
		z,⊂''
	}
	
	decl_loc←{
		0=≢v←⊃lv[⍵]:0⍴⊂''
		z ←⊂'struct {'
		z,←'	',¨decl_vars v
		z,←⊂'} loc_frm, *loc;'
		z,←⊂''
		z,←⊂'loc = &loc_frm;'
		z,⊂''
	}
	
	⍝ FN: Non-zero functions
	i←⍸(t=F)∧k≠0
	zz[i],←{
		0=≢i:0⍴⊂''
		id←⊃var_values ⍵
		atyp←'array' 'func'⊃⍨k[⍵]∊3 6 9 12 15 18 21
		ddtyp←'' 'moper' 'doper'⊃⍨0 5 11⍸k[⍵]
		aatyp←'array' 'func'⊃⍨k[⍵]∊8 9 10 14 15 16 20 21 22
		wwtyp←'array' 'func'⊃⍨k[⍵]∊17 18 19 20 21 22
		ism←k[⍵]∊2 3 5 6 8 9 11 12 14 15 17 18 20 21
		isop←k[⍵]≥5
		isdop←k[⍵]≥11
		pref,←⊂'int ',id,'(struct cell_array **,'
		pref,←(⊂'    struct cell_array *,')⌿⍨~ism
		pref,←⊂'    struct cell_array *,'
		pref,←⊂'    struct cell_func *);'
		z ←⊂'int'
		z,←⊂id,'(struct cell_array **z,'
		z,←(⊂'    struct cell_array *alpha,')⌿⍨~ism
		z,←⊂'    struct cell_array *omega,'
		z,←⊂'    struct cell_func *self)'
		z,←⊂'{'
		z,←⊂'	void *stk[128];'
		z,←⊂'	void **stkhd;'
		z,←⊂'	int err;'
		z,←(⊂'	struct cell_',atyp,' *alpha;')⌿⍨ism
		z,←(⊂'	struct cell_',ddtyp,' *deldel;')⌿⍨isop
		z,←(⊂'	struct cell_',aatyp,' *alphaalpha;')⌿⍨isop
		z,←(⊂'	struct cell_',wwtyp,' *omegaomega;')⌿⍨isdop
		z,←⊂''
		z,←(⊂'	alpha = NULL;')⌿⍨ism
		z,←(⊂'	deldel = self->fv[0];')⌿⍨isop
		z,←(⊂'	alphaalpha = self->fv[1];')⌿⍨isop
		z,←(⊂'	omegaomega = self->fv[2];')⌿⍨isdop
		z,←⊂''
		z,←'	',¨(decl_loc,('self' 'deldel'⊃⍨isop)∘decl_lex)⍵
		z,←'	',¨init_vars ⊃lv[⍵]
		z,←⊂'	err = 0;'
		z,←⊂'	stkhd = &stk[0];'
		z,←⊂''
		z,← '	',¨⊃⍪⌿(p=⍵)⌿zz
		z,←⊂'	err = -1;'
		z,←⊂''
		z,←⊂'cleanup:'
		z,←⊂'	release_env(stk, stkhd);'
		z,←(⊂'	release_env((void **)loc, (void **)(loc + 1));')⌿⍨0≠≢⊃lv[⍵]
		z,←(⊂'	release_',atyp,'(alpha);')⌿⍨ism
		z,←⊂'	return err;'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ F0: Initialization functions for namespaces
	i←⍸(t=F)∧k=0
	zz[i],←{
		id←⊃var_names ⍵
		z ←⊂'int ',id,'_flag = 0;'
		z,←⊂''
		z,←⊂'EXPORT struct ',id,'_loc {'
		z,←⊂'	unsigned int __count;'
		z,←⊂'	wchar_t **__names;'
		z,← '	',¨decl_vars ⊃lv[⍵]
		z,←⊂'} ',id,';'
		z,←⊂''
		z,←⊂(id,'_names')var_nmvec ⊃lv[⍵]
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂id,'_init(void)'
		z,←⊂'{'
		z,←⊂'	struct ',id,'_loc *loc;'
		z,←⊂'	void *stk[128];'
		z,←⊂'	void **stkhd;'
		z,←⊂'	int err;'
		z,←⊂''
		z,←⊂'	if (',id,'_flag)'
		z,←⊂'		return 0;'
		z,←⊂''
		z,←⊂'	stkhd = &stk[0];'
		z,←⊂'	',id,'_flag = 1;'
		z,←⊂'	cdf_prim_init();'
		z,←⊂''
		z,←⊂'	loc = &',id,';'
		z,←⊂'	loc->__count = ',(⍕≢⊃lv[⍵]),';'
		z,←⊂'	loc->__names = ',id,'_names;'
		z,← '	',¨init_vars ⊃lv[⍵]
		z,←⊂''
		z,←⊂'	debug_info = NULL;'
		z,←⊂'	err = 0;'
		z,←⊂''
		z,← '	',¨⊃⍪⌿(p=⍵)⌿zz
		z,←⊂''
		z,←⊂'cleanup:'
		z,←⊂'	release_env(stk, stkhd);'
		z,←⊂'	return err;'
		z,←⊂'}'
		z,⊂''
	}¨i

	⍝ Export functions
	i←⍸(t[p]=B)∧(k[p]=2)∧k[p[p]]=0
	exp←⊃⍪⌿p[i]{
		tgt←⊃⍵
		fn ns←var_names tgt,p[p[tgt]]
		z ←⊂'EXPORT int'
		z,←⊂fn,'(struct cell_array **z, struct cell_array *l, struct cell_array *r)'
		z,←⊂'{'
		z,←⊂'	struct cell_func *self;'
		z,←⊂''
		z,←⊂'	',ns,'_init();'
		z,←⊂''
		z,←⊂'	self = ',ns,'.',fn,';'
		z,←⊂''
		z,←⊂'	if (l == NULL)'
		z,←⊂'		return self->fptr_mon(z, r, self);'
		z,←⊂'	else'
		z,←⊂'		return self->fptr_dya(z, l, r, self);'
		z,←⊂'}'
		z,←⊂''
		z,←⊂'EXPORT int'
		z,←⊂fn,'_dwa(void *z, void *l, void *r)'
		z,←⊂'{'
		z,←⊂'	return call_dwa(',fn,', z, l, r);'
		z,←⊂'}'
		⊂z,⊂''
	}⌸i

	⍝ Warn about nodes that appear which we haven't generated
	⍞←(∨⌿msk)↑⍉⍪'Ungenerated nodes: ',⍕,∪(msk←(zz∊⊂'')∧~t∊V)⌿N∆[t],∘⍕¨k

	⍝ Assemble all the data together into a single character vector
	∊(pref,(⊂''),(⊃⍪⌿zz[⍸p=⍳≢p]),exp),¨⊂⎕UCS 13 10
}
