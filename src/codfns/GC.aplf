 GC←{
   p t k n fr sl rf fd xi sym←⍵ ⋄ A B C E F G K L M N O P S V Z←1+⍳15
   I←{(⊂⍵)⌷⍺} ⋄ com←{⊃{⍺,',',⍵}/⍵}
   ks←{⍵⊂[0]⍨(⊃⍵)=⍵[;0]} ⋄ nam←{'∆'⎕R'__'∘⍕¨sym[|⍵]}

   syms ←,¨'+'    '-'    '×'   '÷'   '*'   '⍟'   '|'    '○'     '⌊'    '⌈'   '!'
   nams ←  'add'  'sub'  'mul' 'div' 'exp' 'log' 'res'  'cir'   'min'  'max' 'fac'
   syms,←,¨'<'    '≤'    '='   '≥'   '>'   '≠'   '~'    '∧'     '∨'    '⍲'   '⍱'
   nams,←  'lth'  'lte'  'eql' 'gte' 'gth' 'neq' 'not'  'and'   'lor'  'nan' 'nor'
   syms,←,¨'⌷'    '['    '⍳'   '⍴'   ','   '⍪'   '⌽'    '⍉'     '⊖'    '∊'   '⊃'
   nams,←  'sqd'  'brk'  'iot' 'rho' 'cat' 'ctf' 'rot'  'trn'   'rtf'  'mem' 'dis'
   syms,←,¨'≡'    '≢'    '⊢'   '⊣'   '⊤'   '⊥'   '/'    '⌿'     '\'    '⍀'   '?'
   nams,←  'eqv'  'nqv'  'rgt' 'lft' 'enc' 'dec' 'red'  'rdf'   'scn'  'scf' 'rol'
   syms,←,¨'↑'    '↓'    '¨'   '⍨'   '.'   '⍤'   '⍣'    '∘'     '∪'    '∩'   '←'
   nams,←  'tke'  'drp'  'map' 'com' 'dot' 'rnk' 'pow'  'jot'   'unq'  'int' 'get'
   syms,←,¨'⍋'    '⍒'    '∘.'  '⍷'   '⊂'   '⌹'   '⎕FFT' '⎕IFFT' '%s'   '⊆'   '⎕CONV'
   nams,←  'gdu'  'gdd'  'oup' 'fnd' 'par' 'mdv' 'fft'  'ift'   'scl'  'nst' 'conv'
   syms,←,¨'∇'    ';'    '⍺'   '⍵'   '⍺⍺'  '⍵⍵'  '%u'
   nams,←  'this' 'span' 'l'   'r'   'aa'  'ww'  ''

   gck← (A 1)(A 6)
   gcv← 'Aa' 'As'
   gck,←(B 1)(B 2)(B 3)(B 4)
   gcv,←'Bv' 'Bf' 'Bo' 'Bo'
   gck,←(C 1)(C 2)
   gcv,←'Ca' 'Cf'
   gck,←(E ¯2)(E ¯1)(E 0)(E 1)(E 2)(E 4)(E 6)
   gcv,←'Ec'  'Ek'  'Er' 'Em' 'Ed' 'Eb' 'Ei'
   gck,←(F 0)(F 2)(F 3)(F 4)
   gcv,←'Fz' 'Fn' 'Fm' 'Fd'
   gck,←(G 0)(N 1)
   gcv,←'Gd' 'Na'
   gck,←(O 1)(O 2)(O 4) (O 5) (O 7) (O 8)
   gcv,←'Ov' 'Of' 'Ovv' 'Ofv' 'Ovf' 'Off'
   gck,←(P 0)(P 1)(P 2)(P 3)(P 4)
   gcv,←'Pv' 'Pv' 'Pf' 'Po' 'Po'
   gck,←(V 0)(V 1)(V 2)(V 3)(V 4)
   gcv,←'Va' 'Va' 'Vf' 'Vo' 'Vo'
   gcv,←⊂'{''/* Unhandled '',(⍕⍺),'' */'',NL}'
   NL←⎕UCS 13 10

   pref ←⊂'#include "codfns.h"'
   pref,←⊂''
   pref,←⊂'EXPORT int'
   pref,←⊂'DyalogGetInterpreterFunctions(void *p)'
   pref,←⊂'{'
   pref,←⊂'	return set_dwafns(p);'
   pref,←⊂'}'
   pref,←⊂''

   Bf←{id←sym⊃⍨|4⊃⍺
     z ←⊂id,' = retain_cell(stkhd[-1]);'
   z}

   Cf←{id←⍕4⊃⍺
     z ←⊂'mk_closure((struct closure **)stkhd++, fn',id,', 0);'
   z}

   Ek←{
     z ←⊂'release_cell(*--stkhd);'
     z,←⊂''
   z}

   Em←{
     z ←⊂'c = *--stkhd;'
     z,←⊂'w = *--stkhd;'
     z,←⊂'(c->fn)((struct array **)stkhd++, NULL, w, c->fv);'
     z,←⊂'release_cell(c);'
     z,←⊂'release_cell(w);'
   z}

   Er←{
     z ←⊂'*z = *--stkhd;'
     z,←⊂'goto cleanup;'
     z,←⊂''
   z}

   Fn←{id←⍕5⊃⍺ ⋄ x←⍉⊃⍪⌿⍵ ⋄ t←2⌷x ⋄ k←3⌷x
     hsw←(t=O)∨(t=E)∧k∊1 2 ⋄ hsa←((t=E)∧k=2)∨(t=O)∧k∊4 5 7 8
     z ←⊂'int'
     z,←⊂'fn',id,'(struct array **z, struct array *l, struct array *r, void *fv[])'
     z,←⊂'{'
     z,←⊂'	void	*stk[128];'
     z,←⊂'	void	**stkhd;'
     z,←hsw⌿⊂'	void	*w;'
     z,←hsa⌿⊂'	void	*a;'
     z,←hsw⌿⊂'	struct	closure *c;'
     z,←⊂''
     z,←⊂'	stkhd = &stk[0];'
     z,←⊂''
     z,← '	',¨⊃,⌿dis¨⍵
     z,←⊂'	*z = NULL;'
     z,←⊂''
     z,←⊂'cleanup:'
     z,←⊂'	return 0;'
     z,←⊂'}'
     z,←⊂''
   z}

   Fz←{id←⍕5⊃⍺ ⋄ awc←∨⌿(3⌷x){(⍵∊A O)∨(⍵=E)∧⍺>0}2⌷x←⍉⊃⍪⌿⍵
     z ←⊂'int init',id,' = 0;'
     z,←⊂''
     z,←⊂'EXPORT int'
     z,←⊂'init(void)'
     z,←⊂'{'
     z,←⊂'	return fn',id,'(NULL, NULL, NULL, NULL);'
     z,←⊂'}'
     z,←⊂''
     z,←⊂'int'
     z,←⊂'fn',id,'(struct array **z, struct array *l, struct array *r, void *fv[])'
     z,←⊂'{'
     z,←⊂'	void	*stk[128];'
     z,←⊂'	void	**stkhd;'
     z,←awc⌿⊂'	void	*a, *w;'
     z,←awc⌿⊂'	struct	closure *c;'
     z,←⊂''
     z,←⊂'	if (init',id,')'
     z,←⊂'		return 0;'
     z,←⊂''
     z,←⊂'	stkhd = &stk[0];'
     z,←⊂'	init',id,' = 1;'
     z,←⊂'	cdf_init();'
     z,←⊂''
     z,← '	',¨⊃,⌿dis¨⍵
     z,←⊂'	return 0;'
     z,←⊂'}'
     z,←⊂''
   z}

   Pf←{id←(syms⍳sym[|4⊃⍺])⊃nams
     z ←⊂'*stkhd++ = retain_cell(',id,');'
   z}

   Va←{id←(|4⊃⍺)⊃'' 'r' 'l' 'aa' 'ww',5↓sym
     z ←⊂'*stkhd++ = retain_cell(',id,');'
   z}

   Zp←{n←'fn',⍕⍵
     k[⍵]∊0 2:{
       z ←⊂'int'
       z,←⊂n,'(struct array **z, struct array *l, struct array *r, void *fv[]);'
       z,←⊂''
     z}⍵
     'UNKNOWN FUNCTION TYPE'⎕SIGNAL 16
   }

   Zx←{n←sym⊃⍨|n[⍵] ⋄ rid←⍕rf[⍵]
     k[⍵]=0:⊂''
     k[⍵]=1:{
       z ←⊂'struct array *',n,';'
     z}⍵
     k[⍵]=2:{
       z ←⊂'struct closure *',n,';'
       z,←⊂''
       z,←⊂'EXPORT int'
       z,←⊂n,'_dwa(struct localp *zp, struct localp *lp, struct localp *rp)'
       z,←⊂'{'
       z,←⊂'	struct array *z, *l, *r;'
       z,←⊂'	int err;'
       z,←⊂''
       z,←⊂'	l = NULL;'
       z,←⊂'	r = NULL;'
       z,←⊂''
       z,←⊂'	fn',rid,'(NULL, NULL, NULL, NULL);'
       z,←⊂''
       z,←⊂'	err = 0;'
       z,←⊂''
       z,←⊂'	if (lp)'
       z,←⊂'		err = dwa2array(&l, lp->pocket);'
       z,←⊂''
       z,←⊂'	if (err)'
       z,←⊂'		dwa_error(err);;'
       z,←⊂''
       z,←⊂'	if (rp)'
       z,←⊂'		dwa2array(&r, rp->pocket);'
       z,←⊂''
       z,←⊂'	if (err) {'
       z,←⊂'		release_array(l);'
       z,←⊂'		dwa_error(err);'
       z,←⊂'	}'
       z,←⊂''
       z,←⊂'	err = (',n,'->fn)(&z, l, r, ',n,'->fv);'
       z,←⊂''
       z,←⊂'	release_array(l);'
       z,←⊂'	release_array(r);'
       z,←⊂''
       z,←⊂'	if (err)'
       z,←⊂'		dwa_error(err);'
       z,←⊂''
       z,←⊂'	err = array2dwa(NULL, z, zp);'
       z,←⊂'	release_array(z);'
       z,←⊂''
       z,←⊂'	if (err)'
       z,←⊂'		dwa_error(err);'
       z,←⊂''
       z,←⊂'	return 0;'
       z,←⊂'}'
       z,←⊂''
     z}⍵
     ⍎'''UNKNOWN EXPORT TYPE''⎕SIGNAL 16'
   }

   d i←P2D p ⋄ ast←(⍉↑d p t k n(⍳≢p)fr sl fd)[i;]
   NOTFOUND←{('[GC] UNSUPPORTED NODE TYPE ',N∆[⊃⍵],⍕⊃⌽⍵)⎕SIGNAL 16}
   dis←{0=2⊃h←,1↑⍵:'' ⋄ (≢gck)=i←gck⍳⊂h[2 3]:NOTFOUND h[2 3] ⋄ h(⍎i⊃gcv)ks 1↓⍵}
   z←∊,∘NL¨pref,⊃,⌿(,⌿Zp¨⍸t=F),(,⌿Zx¨xi),(⊂⊂''),dis¨ks ast
   z}
