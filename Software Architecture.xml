<?xml version="1.0" encoding="utf-8" ?>

<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Co-Dfns Software Architecture</title>
    <author><personname>Aaron W. Hsu</personname></author>
    <date>Monday, October 7th, 2013</date>
  </info>
  <simpara>
    This document describes the high-level system architecture of the
    Co-Dfns compiler at the module and top levels. This includes the
    high-level design of passes and their box-based specifications,
    the programming approach used to develop each of the passes and
    the methodology of handling state-box specifications.
  </simpara>
  <simpara>
    The methodology for handling the state-based specifications are
    different and differ from the practices found in normal
    box-structure methods. This is because the overal design favors a
    pure-functional approach, or one that is externally functional for
    any given level of abstraction. This necessitates no change in the
    clear or black box specifications, but requires a different
    approach for state-based structured specification and design. The
    <citetitle>Cleanroom Engineering Guide</citetitle> documents this
    new approach for those who wish to understand it in more detail as
    it is understood within the scope of this project.
  </simpara>
  <simpara>
    After reading this document, the approach, design, and structure
    of the compiler should be evident, and it should be possible to
    navigate source files without difficulty or to understand the
    reasoning behind the creation of certain essential functions or
    how they fit together. The dependencies, orderings, and
    relationships between functions and elements should be clear, as
    should be the expectations and implied elements not clearly
    documented in the source code itself. Developers who wish to
    understand the source code should rely heavily on this document as
    the main document that guides the structure and implementation of
    the compiler.
  </simpara>
  <section>
    <title>Asset Analysis</title>
    <simpara>
      The <citetitle>Software Development Plan</citetitle> identifies
      four to five major influences on the Software architecture:
      LLVM, MiniKanren, Nanopass, and prototypes implemented in C,
      C++, and Dyalog APL. MiniKanren is a specific implementation
      suggestion for a specific component of the compiler, and as such
      plays a less significant role in the Software Architecture. The
      other components, however, play a very significant role in the
      design of the software, and this section documents the analysis
      of these elements as they relate to the design of the
      system. There is a sub-section dedicated to each of these assets
      as well as specific sections to deal with analysis of the
      <citetitle>Function Specification</citetitle> and other
      miscellaneous assets.
    </simpara>
    <itemizedlist spacing="compact">
      <title>Summary of Analysis</title>
      <listitem>
        <simpara>[NanoPass] Compiler should use a single unified
        grammar</simpara>
      </listitem>
      <listitem>
        <simpara>[NanoPass] Use a formal verification of the
        correctness of each compiler pass</simpara>
      </listitem>
      <listitem>
        <simpara>[NanoPass] Use small, numerous compiler passes rather
        than large, monolithic passes</simpara>
      </listitem>
      <listitem>
        <simpara>[NanoPass] Use aggregate, pure-functional programming
        as much as possible</simpara>
      </listitem>
      <listitem>
        <simpara>[NanoPass] Global state is okay, but should remain
        immutable throughout a given compiler invocation</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] Most of the parsing of Co-Dfns is regular</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] There are specific cases of necessary recursions</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] There are simple, but necessary needs for
        muli-pass refinements of the parsing</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] The parser must use passes to extract type
        information for variables in order to eliminate most
        ambiguity</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] Some instance of ambiguity will remain</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] The grammar will need to take into account
        those instances of ambiguity that cannot be
        eliminated</simpara>
      </listitem>
      <listitem>
        <simpara>[Parsing] Most of the parser should be able to use
        aggregate style programming to express the parsing stages
        clearly</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] Runtime should provide facilities for array class promotion</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] It might make sense to have individual scalar operations in C</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] Scalar functions are probably best implemented in Co-Dfns</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] Most of the primitive functions and
        operators should be implemented in Co-Dfns, not in the
        runtime</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] Implementation language of the core runtime should be C</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] Runtime should take cache behavior into account</simpara>
      </listitem>
      <listitem>
        <simpara>[Runtime] The compiler should try to mitigate the cost of a function call</simpara>
      </listitem>
      <listitem>
        <simpara>
          [Benchmark] Scalar fusion is a significant opportunity for
          performance increase and is the primary bottleneck in Dyalog
          APL interpretation based strategies
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Benchmark] Many optimization transformation conducted by
          hand on Dyalog code had to do with copy avoidance
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Benchmark] Avoiding garbage collection and providing
          predictable allocation behavior is a win
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Benchmark] Cache behavior is one of the key performance
          killers in the existing system, and a core target for
          optimization in the compiler
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Benchmark] A specialized runtime can keep up with other
          code in most cases when the above conditions are not
          affecting the performance.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Tokenization scheme is suggested by the abstract stimuli chosen
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Recursions inherent in the problem are indicated by the recursive stimuli
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Recursive stimuli suggest a decomposition and grammar for the AST
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Many stimuli lend themselves to aggregate analysis
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Variables and their relation to primitives
          is very complex and should be handled carefully in the AST
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] The AST should allow for easy analysis of
          primitive values, whatever they are named
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Atom-level elements of the AST are suggested
          by the stimuli sets and scheme in general
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Specification] Function expressions are the most
          state-heavy elements due to the number of classes of
          operator behavior and the supporting of nested behavior
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          [Language Reference] The Language Reference should be used
          to provide detailed behavior of the primitives and the
          nature of promotion
        </simpara>
      </listitem>
      <listitem>
        <simpara>[LLVM] Most of the IR is unnecessary for this level of optimizations</simpara>
      </listitem>
      <listitem>
        <simpara>[LLVM] The C interface is the best to use right now</simpara>
      </listitem>
      <listitem>
        <simpara>
          [LLVM] We should have handles to control the prefixes used
          for variables and runtime values to ensure that we can
          self-host our runtime if necessary.
        </simpara>
      </listitem>
    </itemizedlist>
    <section>
      <title>Analysis: Nanopass</title>
      <simpara>
        The NanoPass compiler framework is a Scheme eDSL designed to
        make it easier to write compilers by using a series of small
        compiler passes over a series of ASTs that are all related to
        one another. A compiler pass in the NanoPass framework
        consists of an input and output grammar for the language being
        transformed, and the code that described the transformation
        from the old grammar into the new grammar.
      </simpara>
      <simpara>
        Andy Keep demonstrated in his dissertation that the NanoPass
        framework scaled to commercial compiler enterprises
        effectively. However, the framework itself does not fit with
        the requirement to have a self-hosting compiler. The overall
        approach can be kept the same, and indeed, the NanoPass style
        is probably best for lifting out the salient features of the
        compiler and making the compiler easier to modify and to
        understand.
      </simpara>
      <simpara>
        Adapting the NanoPass framework to Co-Dfns will require a few
        changes. Namely, it is slightly more difficult to do careful
        checking of error conditions on grammars, which the NanoPass
        framework gives by default. This will require either explicit
        checking or adaptation in terms of the grammars used. One
        approach would be to use a single unified grammar rather than
        many smaller grammars, and then make adjustments based on
        this. This has the benefits of making the definition of the
        AST simpler, and could simplify some of the code, but will
        require the use of more rigorous development processes to
        offset potential problems with verification of the output of
        each pass.
      </simpara>
      <simpara>
        The NanoPass framework also encourages a pure functional,
        compositional approach to pass development, and this is a very
        good practice. Thus, state should, in general, not be shared
        across passes, and the overall design of the compiler should
        be as state-free as can be managed. Mutation, if used, should
        be isolated to a single scope and depth for any given mutation
        over any given object. Global state may be used, but should
        remain fixed for any given run of the compiler and should not
        change from one pass to the next.
      </simpara>
      <simpara>
        A final insight from the NanoPass framework is the benefit of
        thinking in terms of a series of global transformations over
        an object, rather than on local iterations over the same
        space. We can scale this even further to encourage programming
        in the aggregate as much as possible for clarity. This means
        that we should avoid as much as possible iterations and
        recursions that cannot be expressed as a simple aggregate
        transformation. Where recursion is inherent in the problem,
        then it makes sense to use recursion where expected but
        otherwise, we should hope to avoid the use of unnecessary
        control structures where aggregate operations can more
        succinctly express the problem. This has benefits both in
        terms of potential performance and in terms of problem
        decomposition. This decomposition is the primary concern of
        our state-box design methodology that we use to replace the
        traditional box-structure method of doing state-box design.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of NanoPass Insights</title>
        <listitem>
          <simpara>Compiler should use a single unified grammar</simpara>
        </listitem>
        <listitem>
          <simpara>Use a formal verification of the correctness of each compiler pass</simpara>
        </listitem>
        <listitem>
          <simpara>Use small, numerous compiler passes rather than large, monolithic passes</simpara>
        </listitem>
        <listitem>
          <simpara>Use aggregate, pure-functional programming as much as possible</simpara>
        </listitem>
        <listitem>
          <simpara>Global state is okay, but should remain immutable
          throughout a given compiler invocation</simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: LLVM</title>
      <simpara>
        LLVM is the target language to which the Co-DFns compiler
        compiles. It's a rather sophisticated VM and it has a number
        of interesting quirks. However, it's fairly easy to use, and
        the C interface is very nice. The C interface is the best one
        to use for our system as it will integrate well with the FFI
        available in Dyalog. We consider the LLVM system as something
        of an internal module that has external software boundaries,
        so we do not want to spend too much time on architecting a
        large LLVM library to handle things. Instead, an ad hoc
        interface as needed will be best.
      </simpara>
      <simpara>
        The LLVM system as it stands has a number of useful types and
        tricks to allow for good performance characteristics, but
        these are not good initial targets for the compiler. Instead,
        the compiler should aim to target a simple subset of LLVM and
        introduce these optimization types and other features later in
        the system. It will not be necessary to leverage the LLVM
        performance tweaks to get the main benefits of the
        optimizations planned for the first version. This may change
        as further optimizations are planned.
      </simpara>
      <simpara>
        The grammar of the compiler needs to be able to express the
        important elements that will allow us to get to the LLVM
        Grammar. By the time LLVM code needs to be generated, it
        should be a simple transformation from the ASt to the LLVM
        IR. At this stage of the compiler design, the LLVM IR has many
        things that are not needed, including most of the instruction
        set. Most of what will be used in this version of the compiler
        is the function call semantics.
      </simpara>
      <simpara>
        When working with the runtime environment, however, we need a
        way to encode the names down to the LLVM equivalents, which
        means that we need to make sure to have a way to specifying
        prefixes for the runtime names versus other names to avoid
        clashes, but also have a way of self-hosting our own runtime
        for when many of the primitives are written in Co-Dfns.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of LLVM Insights</title>
        <listitem>
          <simpara>Most of the IR is unnecessary for this level of optimizations</simpara>
        </listitem>
        <listitem>
          <simpara>The C interface is the best to use right now</simpara>
        </listitem>
        <listitem>
          <simpara>
            We should have handles to control the prefixes used for
            variables and runtime values to ensure that we can
            self-host our runtime if necessary.
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Parsing Prototypes</title>
      <simpara>
        Three main parsing prototypes have been created, each using a
        different parsing technology.  These were implemented in three
        different languages: C, C++, and Dyalog. The C version used
        the Peg(1) parser generator, while the C++ version used the
        Boost Spirit parser combinators. The Dyalog version was an
        attempt to move the parser generator style based on
        combinators into the Dyalog framework.
      </simpara>
      <simpara>
        The peg(1) based parsers all suffered from a single major
        flaw: difficulty in threading state information up and down
        the channels of parsing. In other words, the Co-Dfns language
        has a few places where ambiguity exist and require information
        about the bindings in the environment to disambiguate. In
        particular, it is important to know whether a variable is
        bound to a value, a function, or a monadic or dyadic operator,
        and if it is some sort of operator, what operator it is.
      </simpara>
      <simpara>
        The interpreter gets around this by leaving some of this
        ambiguity around until runtime, but it also interleaves
        evaluation with parsing, so that parsing already has some
        environmental information ahead of time. The compiler will not
        have this luxury. Instead, it seems necessary to have a series
        of passes specifically for the parser to enable it to extract
        the important information ahead of time without requiring all
        of the elements to be parsed.
      </simpara>
      <simpara>
        The Boost C++ parser was the most successful attempt, and the
        boost system does in fact have facilities for parsing while
        threading information through the system. It became clear,
        however, that the clarity of the code was beginning to suffer
        through the system, and the approach still resulted in the
        need to have a multi-phase parser that would have looked
        slightly convoluted in the Spirit combinators, despite their
        capacity.
      </simpara>
      <simpara>
        The vast majority of parsing in Co-Dfns is very simple, or at
        least, regular in description. It is possible to use state
        machines to describe most of the behavior of the system (see
        the analysis of <citetitle>Function Specification</citetitle>)
        with only very specific instances of needing recursion. This
        leads to the general conclusion that a traditional in-code
        parser written using aggregate operators on top of a decent
        tokenization will lead to better results and a more readable
        solution, allowing the code to match very closely the regular
        and recursive elements and keeping the code much more compact
        than would have arisen with the use of a parser library.
      </simpara>
      <simpara>
        Even if most of the instances of ambiguity are removed through
        the use of a multi-stage parser, there are specific instances
        in the case of operators with the <literal>⍺⍺</literal> and
        <literal>⍵⍵</literal> types and the ambivalent assignment of
        <literal>⍺</literal> that result in ambiguities which cannot
        be easily removed. Thus, the grammar will need to be able to
        take into account different compilation strategies for
        different versions.  Fortunately, the potential differences
        are isolated and contained within a single scope and do not
        extend across scopes.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of Parsing Prototypes Insights</title>
        <listitem>
          <simpara>Most of the parsing of Co-Dfns is regular</simpara>
        </listitem>
        <listitem>
          <simpara>There are specific cases of necessary recursions</simpara>
        </listitem>
        <listitem>
          <simpara>There are simple, but necessary needs for muli-pass
          refinements of the parsing</simpara>
        </listitem>
        <listitem>
          <simpara>The parser must use passes to extract type
          information for variables in order to eliminate most
          ambiguity</simpara>
        </listitem>
        <listitem>
          <simpara>Some instance of ambiguity will remain</simpara>
        </listitem>
        <listitem>
          <simpara>The grammar will need to take into account those
          instances of ambiguity that cannot be eliminated</simpara>
        </listitem>
        <listitem>
          <simpara>Most of the parser should be able to use aggregate
          style programming to express the parsing stages
          clearly</simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Runtime Prototypes</title>
      <simpara>
        There were two runtimes created, one in C and one in
        Java. Comparing their behavior to existing systems and to each
        other, it is clear that runtimes written in either of these
        languages will create some limitations for the compiler. In
        particular, benchmarking reveals that fusion will be a major
        factor, as will good cache behavior. However, the runtimes
        created in either of these languages, if they encompass many
        of the primitives, will not be able to easily leverage cache
        or fusion optimizations in the compiler, and will operate more
        or less independently of one another.
      </simpara>
      <simpara>
        The general conclusion to this is that the runtime should be
        mostly written in Co-Dfns itself.  However, there is a
        trade-off in compilation complexity. When most of the runtime
        is in the C or Java side, it is possible for us to avoid the
        need to destruct arrays. We can keep them as opaque things and
        not worry about what is inside them during compilation. If
        elements of the compiler are lifted out of that, then it will
        be necessary for us to handle the internals of arrays directly
        in the compiler. However, having a small runtime that handles
        certain things for us directly, without requiring additional
        work, will make it easier to do the compiler things, without
        introducing significant overhead issues. Thus, a minimal
        runtime environment will be helpful, but most of the
        primitives should be implemented in Co-Dfns.
      </simpara>
      <simpara>
        Comparing the C and Java prototypes, Java has some clear
        advantages, but also some serious disadvantages. Since the
        target of the system is in fact the LLVM system, C has much
        better integration with the system, and has better
        opportunities to leverage existing libraries for
        multi-programming to scale things into the large and
        especially distributed computing.  C also allows for better
        control over the calling conventions, which may improve the
        ability to do fast execution with minimal hackery.
      </simpara>
      <simpara>
        An additional interesting issue related to the semantics of
        the runtime system is the promotion semantics. In Dyalog, a
        given value might be promoted to another class if its value
        exceeds a certain amount. This would include going from an
        integer to a floating point number when the number exceeds the
        bounds of the integer size. The runtime needs to provide a
        good facility for handling these sorts of promotions in a way
        that is fast.
      </simpara>
      <simpara>
        The handling of scalar operations is interesting in light of
        the desire to implement fusioning.  Given the nature of
        promotion mentioned above, scalar operations could have a
        potentially complex internal element to them, while
        additionally having the opportunity for better cache behavior
        if the scalar operations can be fused into a single loop. This
        fusing should be accomplished through the compiler, but that
        still leaves to question the behavior of the individual scalar
        operations.  These are potentially good targets to have in the
        runtime, provided that the compiler mitigates the cost of a
        function call to these individual operations.
      </simpara>
      <simpara>
        Ideally speaking, despite the requirement that we might have
        to be able to get to the internals of the array structure, it
        is beneficial if we an avoid worrying about the internals of
        the array structure as much as possible in the compiler. Thus,
        it might make sense to have runtime helpers that will destruct
        and manage the array structure in an efficient way without
        requiring the compiler to have explicit knowledge of the data
        structures used for the arrays. If the compiler is unaware of
        the underlying structure, it can make it easier to make some
        changes without affecting the compiler directly. This needs to
        be balanced with the ability of the compiler to make
        interesting optimizations happen.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of Runtime Prototype Insights</title>
        <listitem>
          <simpara>Runtime should provide facilities for array class promotion</simpara>
        </listitem>
        <listitem>
          <simpara>It might make sense to have individual scalar operations in C</simpara>
        </listitem>
        <listitem>
          <simpara>Scalar functions are probably best implemented in Co-Dfns</simpara>
        </listitem>
        <listitem>
          <simpara>Most of the primitive functions and operators
          should be implemented in Co-Dfns, not in the
          runtime</simpara>
        </listitem>
        <listitem>
          <simpara>Implementation language of the core runtime should be C</simpara>
        </listitem>
        <listitem>
          <simpara>Runtime should take cache behavior into account</simpara>
        </listitem>
        <listitem>
          <simpara>The compiler should try to mitigate the cost of a function call</simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Performance Benchmarks</title>
      <simpara>
        A series of benchmarks, mostly taken from the NAS Parallel
        Benchmarks suite were implemented in Dyalog APL.  These were
        compared against the reference versions in Fortran and C
        provided by the NPB. Analysis of these benchmarks verified
        some initial expectations of the compiler, but also revealed
        that certain issues would not be relevant.
      </simpara>
      <simpara>
        In particular, the benchmarks revealed that cache behavior
        played a very significant role in the relative performance of
        the two systems. Where the cache behavior of Dyalog was not
        friendly, then we saw 10 times or worse slow downs compared to
        the reference implementations. However, where this was not an
        issue, the Dyalog system could keep up with the reference
        implementations nearly tit for tat, though in some versions it
        was around 2 or 3 times slower.
      </simpara>
      <simpara>
        The use of specific, optimized runtime elements gets good
        results in many cases, but the case of strings of scalar
        functions on large arrays is a clear bottleneck for the Dyalog
        interpreter which likely cannot be easily handled using just
        the interpreter technology without significant
        effort. Additionally, memory usage is a concern, and garbage
        collection can present some limitations. Thus, it is
        beneficial if the language can be implemented without the need
        for garbage collection and in a predictable, allocation
        friendly way. There are man opportunities for optimization in
        these cases.
      </simpara>
      <simpara>
        Finally, significant optimization focused transformations
        needed to be applied to the simpler Dyalog code in order to
        get it to go fastest, including some optimizations which were
        not obvious or that obfuscated the code somewhat. Many of
        these optimizations were for the sake of memory allocation or
        copying costs.  The compiler, then, has a great opportunity to
        improve this behavior by using a cost-effective strategy for
        allocation and avoding copying if it can, while still keeping
        the code simple, and not requiring excessive massaging to get
        the code into a copy-friendly state.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of Benchmarking Insights</title>
        <listitem>
          <simpara>
            Scalar fusion is a significant opportunity for performance
            increase and is the primary bottleneck in Dyalog APL
            interpretation based strategies
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Many optimization transformation conducted by hand on
            Dyalog code had to do with copy avoidance
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Avoiding garbage collection and providing predictable
            allocation behavior is a win
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Cache behavior is one of the key performance killers in
            the existing system, and a core target for optimization in
            the compiler
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A specialized runtime can keep up with other code in most
            cases when the above conditions are not affecting the
            performance.
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Function Specification</title>
      <simpara>
        The <citetitle>Function Specification</citetitle> is a work
        product of our development process and includes the detailed
        specification of the compiler behavior as an external Black
        Box definition.  A number of interesting elements came out of
        this effort.
      </simpara>
      <simpara>
        The first advantage is a clear identification of the sort of
        tokens that matter most and their classifications. These are
        mostly abstract, but serve as an useful initial guide for the
        tokenization effort as well as for the definition of the
        Grammar.  Secondly, the specification divides the complexity
        of the system into four classes of entities in the system,
        which informs the grammar. Furthermore, these classes identify
        the only places where recursion is inherent in the problem.
        Examining the specification, many of the stimuli lend
        themselves to aggregate examination and processing without
        requiring iteration through the tokens.
      </simpara>
      <simpara>
        Variables are one of the most complex stimuli in the
        specification, as expected, since they can hold so many
        different values. It will be helpful to link the variable and
        primitive functions in such a way that one can identity all of
        the instances of a primitive, regardless of its
        name. Additionally, the grammar should make sure to clearly
        identify the class or type of a variable.
      </simpara>
      <simpara>
        Each of the classes of recursive stimuli which partition the
        various values also suggests an implementation strategy for
        the various sub-classes of these recursions. In particular, it
        suggests that we should attribute the various types to the
        stimuli in the expression to ensure that we can handle them
        either as a group or specifically. It also suggests that we
        can create the grammar at least partially from the core
        stimuli and then the recursive stimuli, which will not be
        atomic.  The stimuli are abstract enough to suggest a possible
        atom-level vocabulary for the grammar and AST of the compiler.
      </simpara>
      <simpara>
        The specification quite unexpectedly reveals that the most
        complex component of the parser and likely of the system in
        general, at least in terms of state-space, is the function
        expressions, and not anything else.  In fact, there is a huge
        difference in terms of the state-space of the function
        expressions as compared to anything else. Further analysis
        reveals that the reason for this massive explosion of state
        compared to the other systems is the different classifications
        and results of the various operators, together with the
        requisite handling of these operators under the presence of
        parentheses. Handling these nested cases results in a
        significant amount of complexity to ensure that parentheses
        don't get in the way, and map accurately to the concepts
        contained by them.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of Function Specification Insights</title>
        <listitem>
          <simpara>
            Tokenization scheme is suggested by the abstract stimuli chosen
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Recursions inherent in the problem are indicated by the recursive stimuli
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Recursive stimuli suggest a decomposition and grammar for the AST
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Many stimuli lend themselves to aggregate analysis
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Variables and their relation to primitives is very complex
            and should be handled carefully in the AST
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            The AST should allow for easy analysis of primitive
            values, whatever they are named
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Atom-level elements of the AST are suggested by the
            stimuli sets and scheme in general
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Function expressions are the most state-heavy elements due
            to the number of classes of operator behavior and the
            supporting of nested behavior
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Language Reference</title>
      <simpara>
        In general, most of the information that can be gleaned from
        the Language Reference is embedded in the <citetitle>Function
        Specification</citetitle> or some other element, including the
        prototypes. However, the language reference remains the only
        place to get a clear view of the semantics of each individual
        primitive, and it generally does a good job of defining this
        behavior. It also is the place to locate the information about
        how promotion works in detail, which is outside of the scope
        of detail in the <citetitle>Function
        Specification</citetitle>. While little can be extracted from
        the reference, it should be used as the means to define the
        behaviors of some of the more detailed elements of the runtime
        system when that time comes.
      </simpara>
      <itemizedlist spacing="compact">
        <title>Summary of Language Reference Insights</title>
        <listitem>
          <simpara>
            The Language Reference should be used to provide detailed
            behavior of the primitives and the nature of promotion
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Analysis: Miscellaneous Observations</title>
      <simpara>
        There is a parsing by twos paper that gives a classic way of
        parsing APL using a two-lookahead table based approach, but
        this approach doesn't scale to the entire system, only smaller
        parts of the system, which we can pretty easily parse
        anyways. Thus, it's not likely to net us very much to go with
        this approach.
      </simpara>
      <simpara>
        Getting an exact 1-1 correspondence in the namespace behavior
        is going to be hard, but I think it can be done. One thing
        that we will have to make sure to realize is that an online
        compiled system is *not* going to be available the next time
        that we run the namespace, so we may have to compile
        namespaces fresh each time unless we have a means of linking
        them in with a static file that is already compiled. There
        might be some way to ensure that we can do the online
        compilation automatically in the presence of such a file.
      </simpara>
      <simpara>
        Since this compiler is meant to be easily extended and
        modified, and this should mean that it is easy to introspect,
        it makes sense to have an easy to way plug in with any given
        pass. If the passes output their languages and accept their
        languages in a format that matches the format of the
        <function>⎕XML</function> function, it will be possible to
        easily output XML and read in XML versions of the AST for any
        given element, which makes it easy for other tools and other
        systems to work on and analyze the code. This increases the
        overall usefulness of the compiler significantly.
      </simpara>
    </section>
  </section>
  <section>
    <title>Software Strategy</title>
    <simpara>
      Following the NanoPass style, we divide the compiler problem
      into a series of functional, independent passes that have a
      defined input and output grammar. There are five different types
      of passes.
    </simpara>
    <variablelist>
      <title>Types of Passes</title>
      <varlistentry>
        <term>Entry</term>
        <listitem>
          <simpara>A pass that is taking in data and transforming it into the AST</simpara>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Exit</term>
        <listitem>
          <simpara>A pass that is taking an AST and transforming it
          into some sort of external data</simpara>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Verification</term>
        <listitem>
          <simpara>
            A pass that does not alter the contents of the AST and
            just passes it along, but that might potentially signal an
            error if some invariant is broken along the way. These
            passes are used to check properties and ensure the correct
            operation of the compiler.
          </simpara>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Standard</term>
        <listitem>
          <simpara>
            Normal passes take an AST and return a modified AST based
            on whatever intended function defines the pass.
          </simpara>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Optimization</term>
        <listitem>
          <simpara>
            And optimization pass is a pass that does not change the
            invariants on the AST, like what might happen with a
            normal pass, but instead returns something of the same
            AST, but with some sort of optimization or other
            transformation that does not affect the grammar or AST
            invariants.
          </simpara>
        </listitem>
      </varlistentry>
    </variablelist>
    <simpara>
      In the design of the system, because we are aiming as much as
      possible for aggregation, there are a few notes of
      design. Firstly, we will keep all of the functions at the
      top-level if possible, and avoid over-nesting of
      elements. Additionally, we will try to aim for simple, concise
      expressions of the solution, and avoid explicit iteration or
      recursion where possible. We should avoid the use of branching
      and conditionals where possible as well to simplify the code
      flow.
    </simpara>
    <simpara>
      The ASTs will be encoded into the <function>⎕XML</function>
      format for easy use. In these cases, there are a few things that
      are easy to get to in bulk, such as a single column with some
      content or the like. Thus, we should try to make certain bulk
      queries easy in the design of the ASTs, so that while things may
      be different in one access, if they share some similar aspect,
      they are easily identified as a class without excessive
      computation.
    </simpara>
    <simpara>
      We should avoid unnecessary complication in the AST if it is
      possible. Thus, if some information is local to a given pass and
      it is possible to keep it that way, we should avoid storing that
      information in the AST, but rather, keep it in local
      information.
    </simpara>
    <simpara>
      A single AST definition should be sufficient to describe the
      entire compiler languages. The input and output invariants of a
      given pass can be defined in terms of invariants on this single
      AST definition.
    </simpara>
    <simpara>
      We should clearly identify the intended function and the
      properties of each pass in a manner that allows for verification
      during the clear-box design.
    </simpara>
  </section>
  <section>
    <title>Top-level Structure</title>
    <simpara>
      This section details the refinement of the <citetitle>Function
      Specification</citetitle> into a suitable design at the top
      level. We divide this operation into a series of passes, and
      then detail the behavior of these passes and how they need to be
      used. This includes a complete specification of the AST to be
      used in the compiler as well as the black-box view of each pass.
    </simpara>
    <table frame="void" rules="rows">
      <caption>Pass Overview</caption>
      <thead>
        <tr>
          <th>Name</th>
          <th>Class</th>
          <th colspan="3">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Tokenize</td>
          <td>Entry</td>
          <td colspan="3">
            Takes in the initial right argument of the Fix function
            and tokenizes it into its various components
          </td>
        </tr>
        <tr>
          <td>Parse</td>
          <td>Standard</td>
          <td colspan="3">
            Takes the result of <function>Tokenize</function> and produces a standard AST
          </td>
        </tr>
        <tr>
          <td>KillLines</td>
          <td>Standard</td>
          <td colspan="3">
            Eliminates useless or semantically irrelevant nodes from the AST
          </td>
        </tr>
        <tr>
          <td>DropUnmd</td>
          <td>Standard</td>
          <td colspan="3">
            Eliminates unamed functions or expressions at the top-level
          </td>
        </tr>
        <tr>
          <td>FuseScalars</td>
          <td>Optimization</td>
          <td colspan="3">
            Fuse Scalar expressions together
          </td>
        </tr>
        <tr>
          <td>FindMutated</td>
          <td>Standard</td>
          <td colspan="3">
            Mark the arrays that are mutated in some way
          </td>
        </tr>
        <tr>
          <td>IntroCopies</td>
          <td>Standard</td>
          <td colspan="3">
            Introduce array copying to preserve semantics when necessary
          </td>
        </tr>
        <tr>
          <td>IntroFrees</td>
          <td>Standard</td>
          <td colspan="3">
            Introduce array free statements as necessary
          </td>
        </tr>
        <tr>
          <td>IntroSetps</td>
          <td>Standard</td>
          <td colspan="3">
            Introduce cells for mutable variables
          </td>
        </tr>
        <tr>
          <td>ConvAssgn</td>
          <td>Standard</td>
          <td colspan="3">
            Convert assignments into normal expressions
          </td>
        </tr>
        <tr>
          <td>LiftConsts</td>
          <td>Standard</td>
          <td colspan="3">
            Lift all constant expressions to the top-level
          </td>
        </tr>
        <tr>
          <td>ElimFVs</td>
          <td>Standard</td>
          <td colspan="3">
            Eliminate all the free variables in functions
          </td>
        </tr>
        <tr>
          <td>LiftFuncs</td>
          <td>Standard</td>
          <td colspan="3">
            Lift all Functions to the top-level
          </td>
        </tr>
        <tr>
          <td>ExposeBBs</td>
          <td>Standard</td>
          <td colspan="3">
            Convert function bodies into basic blocks
          </td>
        </tr>
        <tr>
          <td>ConvNames</td>
          <td>Standard</td>
          <td colspan="3">
            Convert all names into valid output names, including the primitives
          </td>
        </tr>
        <tr>
          <td>GenLLVM</td>
          <td>Exit</td>
          <td colspan="3">
            Takes the AST massaged for LLVM generation and generates the LLVM module
          </td>
        </tr>
      </tbody>
    </table>
    <section>
      <title>AST Definition</title>
      <simpara>
        Our AST encapsulates all of the data structures that we might want to use in the 
        transfer of information two and from one pass to another. This includes the output 
        of the <function>Tokenize</function> pass.
      </simpara>
      <simpara>
        There are two valid root nodes: <varname>Tokens</varname> and <varname>Namespace</varname>.
      </simpara>
      <table frame="void" rules="rows">
        <caption>AST Elements/Nodes</caption>
        <thead>
          <tr>
            <th>Name</th>
            <th>Attributes</th>
            <th colspan="2">Content</th>
            <th colspan="2">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Tokens</td>
            <td></td>
            <td colspan="2">Line</td>
            <td colspan="2">A series of lines consisting of tokens</td>
          </tr>
          <tr>
            <td>Namespace</td>
            <td>name</td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Line</member>
                <member>Expression</member>
                <member>Function</member>
                <member>FuncExpr</member>
              </simplelist>
            </td>
            <td colspan="2">A possibly named namespace of code</td>
          </tr>
          <tr>
            <td>Line</td>
            <td>comment</td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Token</member>
                <member>Primitive</member>
                <member>Number</member>
                <member>String</member>
                <member>Variable</member>
              </simplelist>
            </td>
            <td colspan="2">A line of tokens</td>
          </tr>
          <tr>
            <td>Ambiguous</td>
            <td></td>
            <td colspan="2">
              <simplelist type="inline">
                <member>FuncExpr</member>
                <member>Expression</member>
              </simplelist>
            </td>
            <td colspan="2">
              A set of possible parsings
            </td>
          </tr>
          <tr>
            <td>Expression</td>
            <td>
              <simplelist type="inline">
                <member>class</member>
                <member>name</member>
                <member>comment</member>
              </simplelist>
            </td>
            <td colspan="2">
              <simplelist type="inline">
                <member>FuncExpr</member>
                <member>Expression</member>
                <member>Variable</member>
                <member>Number</member>
                <member>String</member>
              </simplelist>
            </td>
            <td colspan="2">An expression</td>
          </tr>
          <tr>
            <td>Function</td>
            <td>
              <simplelist type="inline">
                <member>class</member>
                <member>name</member>
                <member>comment</member>
              </simplelist>
            </td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Expression</member>
                <member>FuncExpr</member>
                <member>Condition</member>
                <member>Guard</member>
              </simplelist>
            </td>
            <td colspan="2">An user-defined function or operator</td>
          </tr>
          <tr>
            <td>FuncExpr</td>
            <td>
              <simplelist type="inline">
                <member>name</member>
                <member>class</member>
                <member>equiv</member>
                <member>comment</member>
              </simplelist>
            </td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Primitive</member>
                <member>Expression</member>
                <member>Function</member>
                <member>FuncExpr</member>
              </simplelist>
            </td>
            <td colspan="2">A function valued expression</td>
          </tr>
          <tr>
            <td>Condition</td>
            <td>comment</td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Expression</member>
              </simplelist>
            </td>
            <td colspan="2">Conditional statement in a function</td>
          </tr>
          <tr>
            <td>Guard</td>
            <td>comment</td>
            <td colspan="2">
              <simplelist type="inline">
                <member>Expression</member>
              </simplelist>
            </td>
            <td colspan="2">Guard statement in a function</td>
          </tr>
          <tr>
            <td>Token</td>
            <td>
              <simplelist type="inline">
                <member>name</member>
                <member>class</member>
              </simplelist>
            </td>
            <td colspan="2"></td>
            <td colspan="2">A token not meant to exist in the normal AST</td>
          </tr>
          <tr>
            <td>Primitive</td>
            <td>
              <simplelist type="inline">
                <member>name</member>
                <member>class</member>
              </simplelist>
            </td>
            <td colspan="2"></td>
            <td colspan="2">A primitive function or operator</td>
          </tr>
          <tr>
            <td>Number</td>
            <td>
              <simplelist type="inline">
                <member>value</member>
                <member>class</member>
              </simplelist>
            </td>
            <td colspan="2"></td>
            <td colspan="2">A literal number</td>
          </tr>
          <tr>
            <td>String</td>
            <td></td>
            <td colspan="2">
              <simplelist type="inline">
                <member>text</member>
              </simplelist>
            </td>
            <td colspan="2">A literal string</td>
          </tr>
          <tr>
            <td>Variable</td>
            <td>
              <simplelist type="inline">
                <member>name</member>
                <member>class</member>
                <member>equiv</member>
              </simplelist>
            </td>
            <td colspan="2"></td>
            <td colspan="2">A single variable</td>
          </tr>
        </tbody>
      </table>
      <table frame="void" rules="rows">
        <caption>Element Attributes</caption>
        <thead>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>name</td>
            <td>string</td>
            <td colspan="3">The name of an element, multi-purpose</td>
          </tr>
          <tr>
            <td>class</td>
            <td>string</td>
            <td colspan="3">The class of an element, multi-purpose</td>
          </tr>
          <tr>
            <td>comment</td>
            <td>string</td>
            <td colspan="3">The comment on a given line</td>
          </tr>
          <tr>
            <td>equiv</td>
            <td>string</td>
            <td colspan="3">The equivalence <quote>class</quote> of a thing</td>
          </tr>
          <tr>
            <td>value</td>
            <td>numeric</td>
            <td colspan="3">A numeric value</td>
          </tr>
        </tbody>
      </table>
      <section>
        <title>Element: Tokens</title>
        <simpara>
          The <varname>Tokens</varname> element encapsulates a set of
          lines that contain tokens.  It is designed for the output of
          the <function>Tokenize</function> pass, and sets everything
          up for the initial transformations. This is one of two
          possible root elements.
        </simpara>
        <formalpara>
          <title>Tokens Content</title>
          <para>
            The body of a <varname>Tokens</varname> element is a
            sequence of zero or more <varname>Line</varname> elements.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Namespace</title>
        <simpara>
          This is the main root element of most of the passes. It is
          designed to contain both tokens and regular code.
        </simpara>
        <formalpara>
          <title>Namespace Content</title>
          <para>
            A namespace can contain any number of
            <varname>Line</varname>, <varname>Expression</varname>,
            <varname>Function</varname>, or
            <varname>FuncExpr</varname> elements in any order.
          </para>
        </formalpara>
        <formalpara>
          <title>Namespace Attributes</title>
          <para>
            The <varname>name</varname> attribute should contain the
            value, if any, of the name of the namespace listed in the
            program.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Line</title>
        <simpara>
          The <varname>Line</varname> element encapsulates sets of
          tokens on a line, together with the comment on the line if
          available.
        </simpara>
        <formalpara>
          <title>Line Contents</title>
          <para>
            Lines consist of any of the following in any order in any amount:
            <simplelist type="inline">
              <member><varname>Token</varname></member>
              <member><varname>Primitive</varname></member>
              <member><varname>Number</varname></member>
              <member><varname>String</varname></member>
              <member><varname>Variable</varname></member>
              </simplelist>.
          </para>
        </formalpara>
        <formalpara>
          <title>Line Attributes</title>
          <para>
            The <parameter>comment</parameter> is used to store the
            comment string that appears on a line or is empty
            otherwise.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Ambiguous</title>
        <simpara>
          There are some cases where a given expression may be
          ambiguous with the information that we have now. In order to
          move forward, we allow for a given parsing to have ambiguous
          expression parses when the correct information cannot be
          determined.
        </simpara>
        <formalpara>
          <title>Ambiguous contents</title>
          <para>
            The contents of a <varname>Ambiguous</varname> element is
            one or more <varname>FuncExpr</varname> or
            <varname>Expression</varname> elements.
          </para>
        </formalpara>
        <formalpara>
          <title>Ambiguous attributes</title>
          <para>
            There are no attributes for the <varname>Ambiguous</varname> element.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Expression</title>
        <simpara>
          The <varname>Expression</varname> element contains the
          various types of expressions we can see in our program, and
          is a direct derivation of the <token>E</token> recursive
          stimuli. We must make sure that we have a way to represent
          ambiguous parsings that cannot be eliminated through the
          basic type inference.
        </simpara>
        <formalpara>
          <title>Expression contents</title>
          <para>
            The contents of an <varname>Expression</varname> element
            depend on its <parameter>class</parameter>.  For each
            class there is a specific pattern of elements taken from
            the following set:
            <simplelist type="inline">
              <member><varname>FuncExpr</varname></member>
              <member><varname>Expression</varname></member>
              <member><varname>Variable</varname></member>
              <member><varname>Number</varname></member>
              <member><varname>String</varname></member>
              </simplelist>.
          </para>
        </formalpara>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th colspan="3">Contents</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>atomic</td>
              <td colspan="3">(Variable | Number | String | Expression)+</td>
            </tr>
            <tr>
              <td>monadic</td>
              <td colspan="3">FuncExpr Expression</td>
            </tr>
            <tr>
              <td>dyadic</td>
              <td colspan="3">FuncExpr Expression Expression</td>
            </tr>
            <tr>
              <td>index</td>
              <td colspan="3">Expression Expression*</td>
            </tr>
            <tr>
              <td>assignment</td>
              <td colspan="3">Expression Expression | FuncExpr Expression Expression</td>
            </tr>
          </tbody>
        </informaltable>
        <formalpara>
          <title>Expression attributes</title>
          <para>
            The <parameter>name</parameter> attribute can be used to
            identify that an expression is being given a name
            explicitly through an assignment. In the case where an
            expression may have more than one name, such as in the
            case of multiple assignments of the same value, then the
            <parameter>name</parameter> attribute can have more than
            one name separate by spaces.  The
            <parameter>class</parameter> attribute is one or more of
            the following values, subject to some restrictions, which
            correspond directly to the type of expressions we can
            encounter:
            <simplelist type="inline">
              <member><literal>selective</literal></member>
              <member><literal>atomic</literal></member>
              <member><literal>monadic</literal></member>
              <member><literal>dyadic</literal></member>
              <member><literal>index</literal></member>
              <member><literal>assignment</literal></member>
              </simplelist>. 
              The <parameter>comment</parameter>
              attribute may also be used to indicate the comment that
              appears on the same line as the expression.
          </para>
        </formalpara>
        <simpara>
          The <literal>selective</literal> tag may appear together
          with the other tags, but all other tags are mutually
          exclusive with one another and must not appear together in a
          single <parameter>class</parameter> attribute.
        </simpara>
      </section>
      <section>
        <title>Element: Function</title>
        <simpara>
          The <varname>Function</varname> element encapsulates
          user-defined functions and operators. It consists of a body
          of expressions and bindings to functions.
        </simpara>
        <formalpara>
          <title>Function content</title>
          <para>
            The <varname>Function</varname> body contains zero or more of the following:
            <simplelist type="inline">
              <member><varname>Expression</varname></member>
              <member><varname>FuncExpr</varname></member>
              <member><varname>Condition</varname></member>
              <member><varname>Guard</varname></member>
              </simplelist>. 
              They may appear in any order and in any number.
          </para>
        </formalpara>
        <formalpara>
          <title>Function attributes</title>
          <para>
            The <parameter>name</parameter> attribute is the same as in 
            the <varname>Expression</varname> element, containing one 
            or more names separate by spaces to indicate the names 
            that are given to this function. 
            The <parameter>class</parameter> attribute gives the type of the function,
            which is one of the following:
            <simplelist type="inline">
              <member>ambivalent</member>
              <member>monadic</member>
              <member>dyadic</member> </simplelist>. These correspond
              directly to the three classes of Fn stimuli that we have
              in our <citetitle>Function Specification</citetitle>.
              We also have the <parameter>comment</parameter>
              attribute which should appear if there is a comment on
              the same line as the first line of the definition of a
              function that has no expression or other body element on
              it.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: FuncExpr</title>
        <simpara>
          The <varname>FuncExpr</varname> element encapsulates the behavior of the 
          Fe recursive stimuli in the <citetitle>Function Specification</citetitle>, which 
          are values which return either operators or functions. 
        </simpara>
        <formalpara>
          <title>FuncExpr contents</title>
          <para>
            The contents of a <varname>FuncExpr</varname> element follow some specific 
            patterns based on the type of the function. These correspond to how the 
            function expression is created.
          </para>
        </formalpara>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Form</th>
              <th colspan="2">Pattern</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Function</td>
              <td colspan="2">Function | Primitive | Variable</td>
            </tr>
            <tr>
              <td>Monadic Operator</td>
              <td colspan="2">(FuncExpr | Expression) FuncExpr</td>
            </tr>
            <tr>
              <td>Dyadic Operator</td>
              <td colspan="2">(FuncExpr | Expression) FuncExpr (FuncExpr | Expression)</td>
            </tr>
          </tbody>
        </informaltable>
        <formalpara>
          <title>FuncExpr attributes</title>
          <para>
            The attribute <parameter>name</parameter> works as it does
            for the <varname>Expression</varname> and the
            <varname>Function</varname> elements. The
            <parameter>equiv</parameter> attribute contains either the
            primitive function or operator to which the expression is
            equivalent, or it contains one of
            <literal>ambivalent</literal>, <literal>monadic</literal>,
            or <literal>dyadic</literal>.  Which correspond to the
            three values and classes of user-defined functions and
            operators.  The <parameter>class</parameter> attribute
            identifies the major classes of function expressions, and
            can be one of the following:
            <simplelist type="inline">
              <member><literal>ambivalent</literal></member>
              <member><literal>monadic</literal></member>
              <member><literal>dyadic</literal></member>
              </simplelist>.
              This corresponds to the three large classes of function expressions without regard to 
              the axis specification in the <citetitle>Function Specification</citetitle>.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Condition</title>
        <simpara>
          This is a container for a line in a function body that defines a conditional 
          expression.
        </simpara>
        <formalpara>
          <title>Condition contents</title>
          <para>
            The contents of a <varname>Condition</varname> element should be a pair of Expressions 
            where the first expression is the condition and the second the consequence.
          </para>
        </formalpara>
        <formalpara>
          <title>Condition attributes</title>
          <para>
            The <varname>Condition</varname> element takes a single <parameter>comment</parameter> 
            attribute indicating the comment on the given line.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Guard</title>
        <simpara>
          The <varname>Guard</varname> element is the exact same in
          behavior and specification as the
          <varname>Condition</varname> element except that it
          indicates when an error guard has been introduced instead of
          a conditional.
        </simpara>
      </section>
      <section>
        <title>Element: Token</title>
        <simpara>
          The <varname>Token</varname> element is a body-less element
          that represents a single token which is a symbol or element
          in the tokenizer that does not or need not appear in the
          final AST because it is subsumed by the structured nature of
          the document. In other words, it represents some character
          or element in the serialization of the syntax that controls
          the structure of the code.
        </simpara>
        <formalpara>
          <title>Token contents</title>
          <para>
            The <varname>Token</varname> element does not contain any
            body elements and should be empty.
          </para>
        </formalpara>
        <formalpara>
          <title>Token attributes</title>
          <para>
            The <parameter>name</parameter> attribute is the value of the token, or indicates the 
            literal token value. The <parameter>class</parameter> indicates the kind of token 
            which it is, this would be one of the following: 
            <simplelist type="inline">
              <member><literal>delimiter</literal></member>
              <member><literal>separator</literal></member>
              <member><literal>function</literal></member>
              </simplelist>.  The last member,
              <literal>function</literal>, indicates that the token is
              a part of the function notation. The
              <literal>delimiter</literal> class contains all of the
              tokens that are paired up with one another in one form
              or another. The <literal>sepraator</literal> class
              indicates those tokens that are used to separate strings
              or arrays of things, which can be repeated more than
              once between more than two items if need be. This would
              include things like the statement separator and the
              index axis separator, the semi-colon.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Primitive</title>
        <simpara>
          The <varname>Primitive</varname> element is a single
          built-in primitive function or operator.  It has no body
          contents.
        </simpara>
        <formalpara>
          <title>Primitive contents</title>
          <para>
            No contents are given for this element.
          </para>
        </formalpara>
        <formalpara>
          <title>Primitive attributes</title>
          <para>
            The <parameter>name</parameter> attribute contains the
            literal value of the primitive.  The
            <parameter>class</parameter> indicates the type of
            primitive that it is, taken directly from the
            <citetitle>Function Specification</citetitle>. These can
            be one of the following:
            <simplelist type="inline">
              <member><literal>operator</literal></member>
              <member><literal>monadic</literal></member>
              <member><literal>dyadic</literal></member>
              </simplelist>.  Either <literal>axis</literal> or
              <literal>selective</literal> may be added as additional
              tags to indicate their class in either of these cases.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Number</title>
        <simpara>
          A number is some literal numeric value.
        </simpara>
        <formalpara>
          <title>Number contents</title>
          <para>
            The content of a number element is empty.
          </para>
        </formalpara>
        <formalpara>
          <title>Number attributes</title>
          <para>
            The <parameter>value</parameter> attribute should contain
            the literal syntax of the number.  The
            <parameter>class</parameter> attribute should indicate the
            general type of the number, from among the following:
            <simplelist type="inline">
              <member><literal>int</literal></member>
              <member><literal>float</literal></member>
              <member><literal>complex</literal></member>
              <member><literal>big</literal></member>
              </simplelist>.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: String</title>
        <simpara>
          This is a simple container to hold a string value.
        </simpara>
        <formalpara>
          <title>String contents</title>
          <para>
            A string should contain just normal textual data.
          </para>
        </formalpara>
        <formalpara>
          <title>String attributes</title>
          <para>
            There are no attributes for the <varname>String</varname> element.
          </para>
        </formalpara>
      </section>
      <section>
        <title>Element: Variable</title>
        <simpara>
          The <varname>Variable</varname> element encapsulates the
          core atomic value of a variable name of some sort.
        </simpara>
        <formalpara>
          <title>Variable contents</title>
          <para>
            There are no elements or contents belonging to a <varname>Variable</varname> element.
          </para>
        </formalpara>
        <formalpara>
          <title>Variable attributes</title>
          <para>
            The <parameter>name</parameter> attribute gives the
            literal value of the variable.  The
            <parameter>class</parameter> indicates whether it is a
            <literal>function</literal>, <literal>operator</literal>,
            or <literal>array</literal> value.  The
            <parameter>equiv</parameter> indicates what equivalent
            function, operator, or array exists to this one. In this
            case there is some leeway, and there is not always
            precision here, but we match the precision level of the
            <citetitle>Function Specification</citetitle>.  Possible
            values for the <parameter>equiv</parameter> attribute are
            as follows:
            <simplelist type="inline">
              <member><literal>Fnm</literal></member>
              <member><literal>Fn</literal></member>
              <member><literal>Fnd</literal></member>
              <member>Any function or operator primitive</member>
            </simplelist>
          </para>
        </formalpara>
      </section>
    </section>
    <section>
      <title>Pass Specifications</title>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Entry pass: Tokenize</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended Function</td>
            <td colspan="3">
              Convert a vector of character vectors or scalars to a valid
              AST with a Tokens root that is lexically equivalent modulo spaces.
            </td>
          </tr>
          <tr>
            <td>Right Argument</td>
            <td colspan="3">
              <varname>⍵</varname> of
              <function>Fix</function>
            </td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">AST with a
            <varname>Tokens</varname> root
            </td>
          </tr>
        </tbody>
      </informaltable>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Standard pass: Parse</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended function</td>
            <td colspan="3">
              Convert a Tokens AST to a Namespace AST that is structurally equivalent 
              and that preserves comments and line counts.
            </td>
          </tr>
          <tr>
            <td>Right argument</td>
            <td colspan="3">The result of <function>Tokenize</function></td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">
              <simplelist type="vert">
                <member>AST with a <varname>Namespace</varname> root</member>
                <member>Name bindings from global name to type</member>
              </simplelist>
            </td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              The result of the Parser should be able to reconstruct the 
              exact structure of the original code modulo inter-token spacing.
            </td>
          </tr>
        </tbody>
      </informaltable>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Standard pass: KillLines</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended function</td>
            <td colspan="3">
              Eliminate all semantically irrelevant lines from AST to create an 
              AST suitable for compiling.
            </td>
          </tr>
          <tr>
            <td>Right argument</td>
            <td colspan="3">The AST result of <function>Parse</function></td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">AST with a <varname>Namespace</varname> root</td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              The result should contain no more <varname>Line</varname> elements.
            </td>
          </tr>
        </tbody>
      </informaltable>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Standard pass: DropUnmd</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended Function</td>
            <td colspan="3">
              Drop all unnamed expressions or functions from the top-level
            </td>
          </tr>
          <tr>
            <td>Right Argument</td>
            <td colspan="3">A valid <classname>Namespace</classname> AST</td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">A valid <classname>Namespace</classname> AST</td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              All <classname>FuncExpr</classname> and <classname>Expression</classname> 
              nodes at the top-level have a non-empty, valid <property>name</property>
              attribute upon output.
            </td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              All top-level nodes are either FuncExpr or Expresssion
              nodes; particularly, there are no Line nodes.
            </td>
          </tr>
        </tbody>
      </informaltable>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Standard pass: LiftConsts</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended function</td>
            <td colspan="3">
              Remove all constants from all depths to ensure that there exist constant 
              values only at the top level.
            </td>
          </tr>
          <tr>
            <td>Right argument</td>
            <td colspan="3">A valid <varname>Namespace</varname> AST</td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">A valid <varname>Namespace</varname> AST</td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              The depth of any constant expression should always be 1.
            </td>
          </tr>
        </tbody>
      </informaltable>
      <informaltable frame="void" rules="rows">
        <thead>
          <tr>
            <th colspan="4">Exit pass: GenLLVM</th>
          </tr>
          <tr>
            <th>Type</th>
            <th colspan="3">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Intended Function</td>
            <td colspan="3">
              Take a namespace and convert it to an LLVM Module that is 
              semantically equivalent.
            </td>
          </tr>
          <tr>
            <td>Input</td>
            <td colspan="3">A <classname>Namespace</classname> AST</td>
          </tr>
          <tr>
            <td>Output</td>
            <td colspan="3">An LLVM Module</td>
          </tr>
          <tr>
            <td>Invariant</td>
            <td colspan="3">
              The output LLVM Module should be operationally
              equivalent to the incoming namespace as when
              <function>⎕FIX</function> is used on the same input.
            </td>
          </tr>
        </tbody>
      </informaltable>
      <section>
        <title>Optimization Pass: FuseScalars</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td>Should handle any arbitrary Namespace</td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Scalar Expressions</td>
              <td>Fuse</td>
              <td>
                Each scalar expression, which is a series of scalar 
                operations should be rewritten so that the primitives 
                only operate on a single scalar value at a time.
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: There is more to document here, including the overall 
          transformation and the code that is used to replace things.
        </simpara>
      </section>
      <section>
        <title>Standard Pass: FindMutated</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Variable</td>
              <td>Introduce mutated attribute</td>
              <td>
                Add a mutated attribute to those arrays that are assigned
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: Need more detail about this.
        </simpara>
      </section>
      <section>
        <title>Standard Pass: IntroCopies</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td>Should handle any arbitrary Namespace</td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Primitive</td>
              <td>Introduce Copy</td>
              <td>
                Introduce copies where necessary or important to preserve the 
                semantics of the program.
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: This needs more detail about what this actually means.
        </simpara>
      </section>
      <section>
        <title>Standard Pass: IntroFrees</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Primitive</td>
              <td>Introduce Free</td>
              <td>
                Introduce frees to ensure that the program does not leave 
                dangling elements.
              </td>
            </tr>
          </tbody>
        </informaltable>
      </section>
      <section>
        <title>Standard Pass: IntroSetps</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Variable</td>
              <td>Convert</td>
              <td>
                Convert assignments to mutated variables and their references to 
                boxed values
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
      <section>
        <title>Standard Pass: ConvAssgn</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Indexed Assignment</td>
              <td>Convert to Call</td>
              <td>
                Convert indexed assignments of one form or the other to 
                some sort of assignment operation, either in LLVM or 
                the runtime.
              </td>
            </tr>
            <tr>
              <td>Selective Assignment</td>
              <td>Convert to Call</td>
              <td>
                Convert selective assignments of one form or the other to 
                some sort of assignment operation, either in LLVM or 
                the runtime.
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
      <section>
        <title>Standard Pass: ElimFVs</title>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Class</th>
              <th>Type/Action</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Input</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Output Root Element</td>
              <td>Namespace</td>
              <td></td>
            </tr>
            <tr>
              <td>Variable</td>
              <td>Convert if Free</td>
              <td>
                If there is a variable reference in a function that is free, 
                then convert it to a reference into the global environment and 
                adjust assignments to said variable as appropriate to also assign 
                the global environment.
              </td>
            </tr>
          </tbody>
        </informaltable>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
      <section>
        <title>Standard Pass: LiftFuncs</title>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
      <section>
        <title>Standard Pass: ExposeBBs</title>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
      <section>
        <title>Standard Pass: ConvNames</title>
        <simpara>
          XXX: Need more information here
        </simpara>
      </section>
    </section>
    <section>
      <title>Runtime Design</title>
      <section>
        <title>Representing Arrays</title>
        <simpara>
          The array data structure is the most critical structure in
          the system, and deserves careful consideration. The
          following table details the fields of the array structure
          and all the elements necessary to construct a valid array
          structure.
        </simpara>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Width (Bits)</th>
              <th colspan="2">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Rank</td>
              <td>
                <simplelist type="horiz">
                  <member>unsigned</member>
                  <member>integer</member>
                </simplelist>
              </td>
              <td>16</td>
              <td colspan="2">The count of the dimensions of the array</td>
            </tr>
            <tr>
              <td>Size</td>
              <td>
                <simplelist type="horiz">
                  <member>unsigned</member>
                  <member>integer</member>
                </simplelist>
              </td>
              <td>64</td>
              <td colspan="2">The count of the elements in the array</td>
            </tr>
            <tr>
              <td>Type</td>
              <td>
                <simplelist type="horiz">
                  <member>unsigned</member>
                  <member>integer</member>
                </simplelist>
              </td>
              <td>8</td>
              <td colspan="2">The type of the array elements</td>
            </tr>
            <tr>
              <td>Shape</td>
              <td>Pointer</td>
              <td>N/A</td>
              <td colspan="2">A pointer to the dimensions; each
              dimension is a 32-bit unsigned integer</td>
            </tr>
            <tr>
              <td>Elements</td>
              <td>Pointer</td>
              <td>N/A</td>
              <td colspan="2">A pointer to the buffer containing the
              elements; the nature of the elements is dependent on the
              Type</td>
            </tr>
            <tr>
              <td>Kinds</td>
              <td>Pointer</td>
              <td>N/A</td>
              <td colspan="2">A pointer to the types of the elements
              in a mixed array; only necessary for mixed arrays</td>
            </tr>
          </tbody>
        </informaltable>
      </section>
      <section>
        <title>Representing Scalars</title>
        <simpara>
          Each array has a buffer pointing to a set of elements. How these elements are 
          arrayed in the buffer depends on the type of the scalar. The following table 
          details the types of scalars, and their structures.
        </simpara>
        <informaltable frame="void" rules="rows">
          <thead>
            <tr>
              <th>#</th>
              <th colspan="2">Name</th>
              <th colspan="2">Type</th>
              <th colspan="2">Width (Bits)</th>
              <th colspan="3">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td colspan="2">Boolean</td>
              <td colspan="2">
                <simplelist type="horiz">
                  <member>unsigned</member>
                  <member>integer</member>
                </simplelist>
              </td>
              <td colspan="2">1</td>
              <td colspan="3">A single boolean value; used to compress a bitvector</td>
            </tr>
            <tr>
              <td>2</td>
              <td colspan="2">Integer</td>
              <td colspan="2">
                <simplelist type="horiz">
                  <member>signed</member>
                  <member>integer</member>
                </simplelist>
              </td>
              <td colspan="2">64</td>
              <td colspan="3">A signed integer value</td>
            </tr>
            <tr>
              <td>3</td>
              <td colspan="2">Floating</td>
              <td colspan="2">IEEE Float</td>
              <td colspan="2">64</td>
              <td colspan="3">A floating point value</td>
            </tr>
            <tr>
              <td>4</td>
              <td colspan="2">Character</td>
              <td colspan="2">UCS-4/UTF-32</td>
              <td colspan="2">32</td>
              <td colspan="3">A single Unicode Character</td>
            </tr>
            <tr>
              <td>5</td>
              <td colspan="2">Complex</td>
              <td colspan="2">{3, 3}</td>
              <td colspan="2">128</td>
              <td colspan="3">A complex number represented as a pair of floating point values</td>
            </tr>
            <tr>
              <td>6</td>
              <td colspan="2">Mixed</td>
              <td colspan="2">Varied</td>
              <td colspan="2">Varied</td>
              <td colspan="3">Any scalar value, whose type is indicated by an auxiliary vector</td>
            </tr>
            <tr>
              <td>7</td>
              <td colspan="2">Nested</td>
              <td colspan="2">Array</td>
              <td colspan="2">sizeof(Array)</td>
              <td colspan="3">An array header representing an element in a nested array</td>
            </tr>
          </tbody>
        </informaltable>
      </section>
    </section>
  </section>
</article>
