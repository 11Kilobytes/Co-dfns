<?xml version="1.0" encoding="utf-8" ?>

<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <author>Aaron W. Hsu</author>
    <date>Monday, October 7th, 2013</date>
  </info>
  <section>
    <title>Co-Dfns Software Architecture</title>
    <simpara>
      This document describes the high-level system architecture of the 
      Co-Dfns compiler at the module and top levels. This includes the 
      high-level design of passes and their box-based specifications, the 
      programming approach used to develop each of the passes and the 
      methodology of handling state-box specifications.
    </simpara>
    <simpara>
      The methodology for handling the state-based specifications are 
      different and differ from the practices found in normal box-structure 
      methods. This is because the overal design favors a pure-functional 
      approach, or one that is externally functional for any given level 
      of abstraction. This necessitates no change in the clear or black 
      box specifications, but requires a different approach for state-based 
      structured specification and design. The <citetitle>Cleanroom Engineering Guide</citetitle>
      documents this new approach for those who wish to understand it in more 
      detail as it is understood within the scope of this project.
    </simpara>
    <simpara>
      After reading this document, the approach, design, and structure of the compiler 
      should be evident, and it should be possible to navigate source files without 
      difficulty or to understand the reasoning behind the creation of certain essential 
      functions or how they fit together. The dependencies, orderings, and relationships 
      between functions and elements should be clear, as should be the expectations and 
      implied elements not clearly documented in the source code itself. Developers who 
      wish to understand the source code should rely heavily on this document as the 
      main document that guides the structure and implementation of the compiler. 
    </simpara>
    <section>
      <title>Asset Analysis</title>
      <simpara>
        The <citetitle>Software Development Plan</citetitle> identifies four to five 
        major influences on the Software architecture: LLVM, MiniKanren, Nanopass, and 
        prototypes implemented in C, C++, and Dyalog APL. MiniKanren is a specific implementation 
        suggestion for a specific component of the compiler, and as such plays a less 
        significant role in the Software Architecture. The other components, however, play 
        a very significant role in the design of the software, and this section documents 
        the analysis of these elements as they relate to the design of the system. There 
        is a sub-section dedicated to each of these assets as well as specific sections to 
        deal with analysis of the <citetitle>Function Specification</citetitle> and other 
        miscellaneous assets.
      </simpara>
      <section>
        <title>Analysis: Nanopass</title>
        <simpara>
          The NanoPass compiler framework is a Scheme eDSL designed to make it easier to write 
          compilers by using a series of small compiler passes over a series of ASTs that are 
          all related to one another. A compiler pass in the NanoPass framework consists of 
          an input and output grammar for the language being transformed, and the code that 
          described the transformation from the old grammar into the new grammar. 
        </simpara>
        <simpara>
          Andy Keep demonstrated in his dissertation that the NanoPass framework scaled to 
          commercial compiler enterprises effectively. However, the framework itself does not 
          fit with the requirement to have a self-hosting compiler. The overall approach can be 
          kept the same, and indeed, the NanoPass style is probably best for lifting out the 
          salient features of the compiler and making the compiler easier to modify and to 
          understand. 
        </simpara>
        <simpara>
          Adapting the NanoPass framework to Co-Dfns will require a few changes. Namely, it is 
          slightly more difficult to do careful checking of error conditions on grammars, which 
          the NanoPass framework gives by default. This will require either explicit checking 
          or adaptation in terms of the grammars used. One approach would be to use a single
          unified grammar rather than many smaller grammars, and then make adjustments based on 
          this. This has the benefits of making the definition of the AST simpler, and could 
          simplify some of the code, but will require the use of more rigorous development 
          processes to offset potential problems with verification of the output of each 
          pass.
        </simpara>
        <simpara>
          The NanoPass framework also encourages a pure functional, compositional approach to 
          pass development, and this is a very good practice. Thus, state should, in general, not 
          be shared across passes, and the overall design of the compiler should be as state-free 
          as can be managed. Mutation, if used, should be isolated to a single scope and depth for 
          any given mutation over any given object. Global state may be used, but should remain 
          fixed for any given run of the compiler and should not change from one pass to the next.
        </simpara>
        <simpara>
          A final insight from the NanoPass framework is the benefit of thinking in terms of a series 
          of global transformations over an object, rather than on local iterations over the same 
          space. We can scale this even further to encourage programming in the aggregate as much as 
          possible for clarity. This means that we should avoid as much as possible iterations and 
          recursions that cannot be expressed as a simple aggregate transformation. Where recursion is 
          inherent in the problem, then it makes sense to use recursion where expected but otherwise, 
          we should hope to avoid the use of unnecessary control structures where aggregate operations 
          can more succinctly express the problem. This has benefits both in terms of potential 
          performance and in terms of problem decomposition. This decomposition is the primary concern 
          of our state-box design methodology that we use to replace the traditional box-structure 
          method of doing state-box design.
        </simpara>
        <itemizedlist spacing="compact">
          <title>Summary of NanoPass Insights</title>
          <listitem>
            <simpara>Compiler should use a single unified grammar</simpara>
          </listitem>
          <listitem>
            <simpara>Use a formal verification of the correctness of each compiler pass</simpara>
          </listitem>
          <listitem>
            <simpara>Use small, numerous compiler passes rather than large, monolithic passes</simpara>
          </listitem>
          <listitem>
            <simpara>Use aggregate, pure-functional programming as much as possible</simpara>
          </listitem>
          <listitem>
            <simpara>Global state is okay, but should remain immutable throughout a given compiler invocation</simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Analysis: LLVM</title>
      </section>
      <section>
        <title>Analysis: Parsing Prototypes</title>
      </section>
      <section>
        <title>Analysis: Runtime Prototypes</title>
      </section>
      <section>
        <title>Analysis: Performance Benchmarks</title>
      </section>
      <section>
        <title>Analysis: Function Specification</title>
      </section>
      <section>
        <title>Analysis: Language Reference</title>
      </section>
      <section>
        <title>Analysis: Miscellaneous Observations</title>
      </section>
    </section>
    <section>
      <title>Software Strategy</title>
    </section>
    <section>
      <title>Top-level Structure</title>
      <section>
        <title>AST Definition</title>
      </section>
      <section>
        <title>Pass Overview</title>
      </section>
      <section>
        <title>Pass Specifications</title>
      </section>
    </section>
  </section>
</article>