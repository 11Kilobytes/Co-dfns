<?xml version="1.0" encoding="utf-8" ?>

<article xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <author>Aaron W. Hsu</author>
    <date>Thursday, July 18th, 2013</date>
  </info>
  <section>
    <title>Function Specification</title>
    <section>
      <title>Overview</title>
      <simpara>
        The complete functional specification of the Co-Dfns compiler can be 
        found in this document. The compiler is designed and specified using 
        a black-box method, specifying the behavior in terms of input 
        and stimulus histories and responses. Because we are writing a 
        compiler and not some other system, the actual user facing toggles 
        on the system are surprisingly small, despite the large potential 
        for behavior. This is because the majority of input comes in the 
        forms of programs. Therefore, in specification, it is critical to 
        specify not only the normal user behaviors, but also the behaviors 
        on critical abstractions of program input and form. 
      </simpara>
      <simpara>
        The compiler itself also has a tendency towards sparse responses. 
        In traditional program design, the responses of the system would 
        come in the form of textual, GUI, or hardware responses that had a 
        very user visible form. In contrast, the majority of software "states" 
        that the user can consider, when correct input is entered, should 
        respond with no output and no response. These states are there 
        conceptually or abstractly, rather than displaying specific 
        outputs whenever they are entered. They cannot be elided from the 
        function specification, however, because when input is 
        <emphasis>not</emphasis> correct, then these states represent 
        the set of possible error responses and the types of reporting that 
        will be given in the cases where the system does not receive the 
        intended input. Thus, these states can be considered No-op responses 
        unless errors need to be considered or handled. Indeed, the majority 
        of user visible responses in the compiler take the form of error 
        handling responses, and the compiler is at its most quiet when 
        all things are going as planned.
      </simpara>
      <simpara>
        The approach to black box specification here will take this form 
        and the nature of the visible interface of a compiler into account. 
        We encode the input of the system at an abstraction level that lets 
        use encode the appropriate error responses of the system and all 
        <emphasis>potential</emphasis> user visible behavior of the system 
        in response to any user alterable or user derived input, even though 
        the majority of the time, the compiler might be quite silent. This 
        requires an abstraction level that allows us to talk about the 
        structure and form of the programs that are given as input into the 
        program, but because of the nature of program text, we have chosen 
        an abstraction level only deep enough to accurately reflect all of 
        the possible compiler responses, and no deeper. Entering in any 
        more precisely would defeat the purpose of the black box abstraction 
        and would complicate the specification process beyond feasibility. 
      </simpara>
      <simpara>
        In this same vein, the abstraction of the compiler responses goes 
        only so far as to accurately reflect the paths that may lead to 
        semantically valuable user visible changes in response to new 
        inputs. Responses, therefore, are equally abstract, and represent 
        only the sufficiently clear class of errors and conceptual states 
        that reflect the useful and meaningful external behavior of the 
        system. 
      </simpara>
      <simpara>
        Despite the relative abstractness of this specification, however, 
        normal, standard black box abstraction techniques and specification 
        methods provide the same level of rigor and usefulness to the 
        task. The methods and approaches themselves are as little refined 
        or modified as possible, in order to make these specifications as 
        easy to understand and as rigorous as possible, without requiring 
        a significant programmer overhead for developing a mathematical 
        semantics that far exceeds the desired scope of the compiler 
        project. 
      </simpara>
    </section>
    <section>
      <title>Software Boundaries</title>
      
    </section>
    <section>
      <title>Stimuli and Responses</title>
      
    </section>
    <section>
      <title>Sequence Enumeration</title>
      
    </section>
    <section>
      <title>Derived Requirements</title>
      
    </section>
    <section>
      <title>Canonical Sequence Analysis</title>
      
    </section>
    <section>
      <title>Specification Functions</title>
      
    </section>
    <section>
      <title>Black Box Definitions</title>
      
    </section>
  </section>
</article>