#include "codfns.h"

EXPORT int
DyalogGetInterpreterFunctions(void *p)
{
    return set_dwafns(p);
}

extern struct cell_func *q_signal_ibeam;
extern struct cell_func *q_dr_ibeam;
extern struct cell_moper *q_veach_ibeam;
extern struct cell_doper *q_ambiv_ibeam;
extern struct cell_func *squeeze_ibeam;
extern struct cell_func *is_simple_ibeam;
extern struct cell_func *is_numeric_ibeam;
extern struct cell_func *is_integer_ibeam;
extern struct cell_func *max_shp_ibeam;
extern struct cell_func *has_nat_vals_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *shape_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *same_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_gen_vec;
extern struct cell_func *index_gen_vec;
extern struct cell_func *disclose_ibeam;
extern struct cell_func *conjugate_vec;
extern struct cell_func *conjugate_vec;
extern struct cell_func *add_vec_ibeam;
extern struct cell_func *sub_vec_ibeam;
extern struct cell_func *mul_vec_ibeam;
extern struct cell_func *div_vec_ibeam;
extern struct cell_func *exp_vec_ibeam;
extern struct cell_func *pow_vec_ibeam;

int ptr2424(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2425(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2426(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2427(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2428(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2429(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2430(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2431(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2432(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2433(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2434(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2435(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2436(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2437(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2438(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2439(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2440(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2441(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2442(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2443(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2444(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2445(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2446(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2447(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2448(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2449(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2450(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2451(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2452(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2453(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2454(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2455(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2456(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2457(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2458(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2459(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2460(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2461(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2462(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2463(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2464(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2465(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2466(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2467(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2468(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2469(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2470(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2471(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2472(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2473(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2474(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2475(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2476(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2477(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2478(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2479(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2480(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2481(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2482(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2483(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2484(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2485(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2486(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2487(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2488(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2489(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2490(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2491(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2492(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2493(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2494(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2495(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2496(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2497(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2498(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2499(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2500(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2501(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2502(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2503(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2504(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2505(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2506(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2507(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2508(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2509(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2510(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2511(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2512(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2513(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2514(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2515(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2516(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2517(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2518(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2519(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2520(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2521(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2522(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2523(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2524(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2525(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2526(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2527(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2528(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2529(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2530(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2531(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2532(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2533(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2534(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2535(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);

int cdf_prim_flag = 0;

EXPORT struct cdf_prim_loc {
	unsigned int __count;
	wchar_t **__names;
	struct cell_func *q_signal;
	struct cell_func *q_dr;
	struct cell_moper *q_veach;
	struct cell_doper *q_ambiv;
	struct cell_func *squeeze;
	struct cell_func *is_simple;
	struct cell_func *is_numeric;
	struct cell_func *is_integer;
	struct cell_func *max_shp;
	struct cell_func *has_nat_vals;
	struct cell_func *chk_scl;
	struct cell_func *chk_valid_shape;
	struct cell_func *both_simple;
	struct cell_func *both_numeric;
	struct cell_moper *numeric;
	struct cell_moper *scalar;
	struct cell_func *rgt;
	struct cell_func *lft;
	struct cell_func *reshape;
	struct cell_func *rho;
	struct cell_func *cat;
	struct cell_func *eqv;
	struct cell_func *nqv;
	struct cell_func *materialize;
	struct cell_func *index;
	struct cell_func *sqd;
	struct cell_func *index_gen;
	struct cell_func *index_of;
	struct cell_func *iot;
	struct cell_func *dis;
	struct cell_func *par;
	struct cell_func *conjugate;
	struct cell_func *add;
	struct cell_func *negate;
	struct cell_func *sub;
	struct cell_func *sign;
	struct cell_func *mul;
	struct cell_func *recip;
	struct cell_func *div;
	struct cell_func *exp;
	struct cell_func *split;
	struct cell_func *drop;
	struct cell_func *drp;
	struct cell_func *reverse_last;
	struct cell_func *rotate_last;
	struct cell_func *rot;
	struct cell_func *map_monadic;
	struct cell_moper *map_dyadic;
	struct cell_moper *map;
	struct cell_moper *rdf;
	struct cell_func *rpf;
	struct cell_doper *dot;
	struct cell_doper *pow;
} cdf_prim;

wchar_t *cdf_prim_names[] = {L"q_signal", L"q_dr", L"q_veach", L"q_ambiv", L"squeeze", L"is_simple", L"is_numeric", L"is_integer", L"max_shp", L"has_nat_vals", L"chk_scl", L"chk_valid_shape", L"both_simple", L"both_numeric", L"numeric", L"scalar", L"rgt", L"lft", L"reshape", L"rho", L"cat", L"eqv", L"nqv", L"materialize", L"index", L"sqd", L"index_gen", L"index_of", L"iot", L"dis", L"par", L"conjugate", L"add", L"negate", L"sub", L"sign", L"mul", L"recip", L"div", L"exp", L"split", L"drop", L"drp", L"reverse_last", L"rotate_last", L"rot", L"map_monadic", L"map_dyadic", L"map", L"rdf", L"rpf", L"dot", L"pow"};

EXPORT int
cdf_prim_init(void)
{
	struct cdf_prim_loc *loc;
	void *stk[128];
	void **stkhd;
	int err;

	if (cdf_prim_flag)
		return 0;

	stkhd = &stk[0];
	cdf_prim_flag = 1;
	cdf_prim_init();

	loc = &cdf_prim;
	loc->__count = 53;
	loc->__names = cdf_prim_names;
	loc->q_signal = NULL;
	loc->q_dr = NULL;
	loc->q_veach = NULL;
	loc->q_ambiv = NULL;
	loc->squeeze = NULL;
	loc->is_simple = NULL;
	loc->is_numeric = NULL;
	loc->is_integer = NULL;
	loc->max_shp = NULL;
	loc->has_nat_vals = NULL;
	loc->chk_scl = NULL;
	loc->chk_valid_shape = NULL;
	loc->both_simple = NULL;
	loc->both_numeric = NULL;
	loc->numeric = NULL;
	loc->scalar = NULL;
	loc->rgt = NULL;
	loc->lft = NULL;
	loc->reshape = NULL;
	loc->rho = NULL;
	loc->cat = NULL;
	loc->eqv = NULL;
	loc->nqv = NULL;
	loc->materialize = NULL;
	loc->index = NULL;
	loc->sqd = NULL;
	loc->index_gen = NULL;
	loc->index_of = NULL;
	loc->iot = NULL;
	loc->dis = NULL;
	loc->par = NULL;
	loc->conjugate = NULL;
	loc->add = NULL;
	loc->negate = NULL;
	loc->sub = NULL;
	loc->sign = NULL;
	loc->mul = NULL;
	loc->recip = NULL;
	loc->div = NULL;
	loc->exp = NULL;
	loc->split = NULL;
	loc->drop = NULL;
	loc->drp = NULL;
	loc->reverse_last = NULL;
	loc->rotate_last = NULL;
	loc->rot = NULL;
	loc->map_monadic = NULL;
	loc->map_dyadic = NULL;
	loc->map = NULL;
	loc->rdf = NULL;
	loc->rpf = NULL;
	loc->dot = NULL;
	loc->pow = NULL;

	err = 0;

	loc->q_signal = *stkhd++ = retain_cell(q_signal_ibeam);
	release_cell(*--stkhd);
	
	loc->q_dr = *stkhd++ = retain_cell(q_dr_ibeam);
	release_cell(*--stkhd);
	
	loc->q_veach = *stkhd++ = retain_cell(q_veach_ibeam);
	release_cell(*--stkhd);
	
	loc->q_ambiv = *stkhd++ = retain_cell(q_ambiv_ibeam);
	release_cell(*--stkhd);
	
	loc->squeeze = *stkhd++ = retain_cell(squeeze_ibeam);
	release_cell(*--stkhd);
	
	loc->is_simple = *stkhd++ = retain_cell(is_simple_ibeam);
	release_cell(*--stkhd);
	
	loc->is_numeric = *stkhd++ = retain_cell(is_numeric_ibeam);
	release_cell(*--stkhd);
	
	loc->is_integer = *stkhd++ = retain_cell(is_integer_ibeam);
	release_cell(*--stkhd);
	
	loc->max_shp = *stkhd++ = retain_cell(max_shp_ibeam);
	release_cell(*--stkhd);
	
	loc->has_nat_vals = *stkhd++ = retain_cell(has_nat_vals_ibeam);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2424, ptr2425, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->chk_scl = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2426, ptr2431, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	loc->chk_valid_shape = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2436, ptr2437, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	loc->both_simple = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2438, ptr2439, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	loc->both_numeric = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		err = mk_moper(&k, ptr2440, ptr2441, ptr2442, ptr2443, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	loc->numeric = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		err = mk_moper(&k, ptr2444, ptr2445, ptr2446, ptr2447, 3);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->both_simple);
		k->fv[1] = retain_cell(loc->chk_scl);
		k->fv[2] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->scalar = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2448, ptr2449, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->rgt = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2450, ptr2451, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->lft = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2452, ptr2453, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->reshape = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = shape_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->reshape;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rho = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2454, ptr2455, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = ravel_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->cat = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2456, ptr2457, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = same_ibeam;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->eqv = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2460, ptr2461, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2458, ptr2459, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(x);
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->nqv = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2462, ptr2463, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->materialize = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2464, ptr2467, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->index = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->materialize;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->index;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->sqd = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2470, ptr2471, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->index_gen = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2472, ptr2473, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->index_of = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->index_gen;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->index_of;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->iot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2474, ptr2475, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = disclose_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->dis = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2478, ptr2479, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2476, ptr2477, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(x);
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->par = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2480, ptr2481, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	loc->conjugate = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = add_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->conjugate;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->add = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2482, ptr2483, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->negate = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = sub_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->negate;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->sub = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2484, ptr2485, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->sign = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = mul_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->sign;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->mul = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2486, ptr2487, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->recip = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = div_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->recip;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->div = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = pow_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = exp_vec_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->exp = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2488, ptr2489, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->split = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2490, ptr2491, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->drop = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->split;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->drop;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->drp = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2492, ptr2493, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->reverse_last = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2494, ptr2495, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->rotate_last = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->reverse_last;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->rotate_last;
		struct cell_func *dst;
	
		err = apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2496, ptr2497, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->map_monadic = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		err = mk_moper(&k, ptr2498, ptr2499, ptr2500, ptr2501, 2);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->chk_scl);
		k->fv[1] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->map_dyadic = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		err = mk_moper(&k, ptr2502, ptr2503, ptr2504, ptr2505, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->map_dyadic);
	
		*stkhd++ = k;
	}
	
	loc->map = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		err = mk_moper(&k, ptr2506, ptr2509, ptr2512, ptr2515, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->rdf = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2518, ptr2519, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->rpf = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		err = mk_doper(&k, ptr2520, ptr2521, ptr2522, ptr2523, ptr2524, ptr2525, ptr2526, ptr2527, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->dot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		err = mk_doper(&k, ptr2528, ptr2529, ptr2530, ptr2531, ptr2532, ptr2533, ptr2534, ptr2535, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	loc->pow = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2424(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2425(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2426(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2427, ptr2428, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2429, ptr2430, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2427(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2428(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2429(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2430(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2431(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2432, ptr2433, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2434, ptr2435, 1);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2432(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2433(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2434(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2435(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2436(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_simple;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2437(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_simple;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2438(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_numeric;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_numeric;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2439(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_numeric;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_numeric;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2440(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 3;
			
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2441(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 3;
			
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2442(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2443(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2444(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 3;
			
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2445(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 3;
			
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2446(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2447(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2448(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2449(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2450(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	*z = alpha;
	retain_cell(alpha);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2451(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	*z = alpha;
	retain_cell(alpha);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2452(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = reshape_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2453(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = reshape_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2454(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2455(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2456(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2457(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2458(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2459(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2460(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2461(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2462(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2463(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2464(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->idx = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = lex->is_integer;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2465, ptr2466, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = loc->idx;
		struct cell_func *fn = index_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2465(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2466(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2467(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->idx = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = lex->is_integer;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2468, ptr2469, 0);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = loc->idx;
		struct cell_func *fn = index_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2468(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2469(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2470(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 0;
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.par;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = index_gen_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2471(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
				arr->shape[0] = 0;
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.par;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = index_gen_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2472(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2473(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2474(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2475(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2476(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2477(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2478(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2479(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2480(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->squeeze;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.q_dr;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = conjugate_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2481(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->squeeze;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.q_dr;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = conjugate_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2482(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2483(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2484(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2485(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2486(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2487(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2488(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2489(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2490(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2491(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2492(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2493(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2494(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2495(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2496(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2497(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2498(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2499(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2500(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2501(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2502(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2503(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2504(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2505(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2506(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	err = mk_array_box(&loc->z, NULL);
	if (err)
		goto cleanup;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2507, ptr2508, 2);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2507(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2508(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2509(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	err = mk_array_box(&loc->z, NULL);
	if (err)
		goto cleanup;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2510, ptr2511, 2);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2510(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2511(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2512(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	err = mk_array_box(&loc->z, NULL);
	if (err)
		goto cleanup;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2513, ptr2514, 2);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2513(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2514(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2515(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	err = mk_array_box(&loc->z, NULL);
	if (err)
		goto cleanup;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				err = mk_array(&arr, typ, STG_HOST, rnk);
			
				if (err)
					goto cleanup;
			
			
				err = fill_array(arr, dat);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				err = (fn->fptr_mon)(&dst, y, fn);
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				err = (fn->fptr_dya)(&dst, x, y, fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		err = mk_func(&k, ptr2516, ptr2517, 2);
	
		if (err)
			goto cleanup;
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2516(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2517(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		err = (fn->fptr_dya)(&bx->value, x, y, fn);
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2518(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2519(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2520(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2521(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2522(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2523(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2524(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2525(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2526(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2527(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		err = apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x);
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2528(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alphaalpha;
		dat[1] = omega;
	
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2529(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {3};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 3;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
		dat[2] = omega;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2530(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2531(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2532(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	err = 2;
	goto cleanup;
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alphaalpha;
		dat[1] = omega;
	
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2533(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	err = 2;
	goto cleanup;
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {3};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 3;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
		dat[2] = omega;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		err = mk_array(&arr, ARR_NESTED, STG_HOST, 1);
	
		if (err)
			goto cleanup;
	
		arr->shape[0] = 2;
	
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2534(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	err = 2;
	goto cleanup;
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2535(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	err = 2;
	goto cleanup;
	
	{
		struct cell_array *x = *--stkhd;
	
		err = guard_check(x);
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		err = mk_array(&arr, typ, STG_HOST, rnk);
	
		if (err)
			goto cleanup;
	
	
		err = fill_array(arr, dat);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_mon)(&dst, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		err = (fn->fptr_dya)(&dst, x, y, fn);
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

EXPORT int
q_signal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.q_signal;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_signal_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_signal, z, l, r);
}

EXPORT int
q_dr(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.q_dr;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_dr_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_dr, z, l, r);
}

EXPORT int
squeeze(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.squeeze;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
squeeze_dwa(void *z, void *l, void *r)
{
	return call_dwa(squeeze, z, l, r);
}

EXPORT int
is_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_simple;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_simple, z, l, r);
}

EXPORT int
is_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_numeric;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_numeric, z, l, r);
}

EXPORT int
is_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_integer;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_integer, z, l, r);
}

EXPORT int
max_shp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.max_shp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
max_shp_dwa(void *z, void *l, void *r)
{
	return call_dwa(max_shp, z, l, r);
}

EXPORT int
has_nat_vals(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.has_nat_vals;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
has_nat_vals_dwa(void *z, void *l, void *r)
{
	return call_dwa(has_nat_vals, z, l, r);
}

EXPORT int
chk_scl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.chk_scl;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_scl_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_scl, z, l, r);
}

EXPORT int
chk_valid_shape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.chk_valid_shape;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_valid_shape_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_valid_shape, z, l, r);
}

EXPORT int
both_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.both_simple;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_simple, z, l, r);
}

EXPORT int
both_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.both_numeric;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_numeric, z, l, r);
}

EXPORT int
rgt(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rgt;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rgt_dwa(void *z, void *l, void *r)
{
	return call_dwa(rgt, z, l, r);
}

EXPORT int
lft(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.lft;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lft_dwa(void *z, void *l, void *r)
{
	return call_dwa(lft, z, l, r);
}

EXPORT int
reshape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.reshape;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reshape_dwa(void *z, void *l, void *r)
{
	return call_dwa(reshape, z, l, r);
}

EXPORT int
rho(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rho;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rho_dwa(void *z, void *l, void *r)
{
	return call_dwa(rho, z, l, r);
}

EXPORT int
cat(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.cat;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
cat_dwa(void *z, void *l, void *r)
{
	return call_dwa(cat, z, l, r);
}

EXPORT int
eqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.eqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
eqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(eqv, z, l, r);
}

EXPORT int
nqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.nqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
nqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(nqv, z, l, r);
}

EXPORT int
materialize(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.materialize;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
materialize_dwa(void *z, void *l, void *r)
{
	return call_dwa(materialize, z, l, r);
}

EXPORT int
index(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_dwa(void *z, void *l, void *r)
{
	return call_dwa(index, z, l, r);
}

EXPORT int
sqd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sqd;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sqd_dwa(void *z, void *l, void *r)
{
	return call_dwa(sqd, z, l, r);
}

EXPORT int
index_gen(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index_gen;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_gen_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_gen, z, l, r);
}

EXPORT int
index_of(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index_of;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_of_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_of, z, l, r);
}

EXPORT int
iot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.iot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
iot_dwa(void *z, void *l, void *r)
{
	return call_dwa(iot, z, l, r);
}

EXPORT int
dis(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.dis;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
dis_dwa(void *z, void *l, void *r)
{
	return call_dwa(dis, z, l, r);
}

EXPORT int
par(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.par;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
par_dwa(void *z, void *l, void *r)
{
	return call_dwa(par, z, l, r);
}

EXPORT int
conjugate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.conjugate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
conjugate_dwa(void *z, void *l, void *r)
{
	return call_dwa(conjugate, z, l, r);
}

EXPORT int
add(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.add;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
add_dwa(void *z, void *l, void *r)
{
	return call_dwa(add, z, l, r);
}

EXPORT int
negate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.negate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
negate_dwa(void *z, void *l, void *r)
{
	return call_dwa(negate, z, l, r);
}

EXPORT int
sub(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sub;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sub_dwa(void *z, void *l, void *r)
{
	return call_dwa(sub, z, l, r);
}

EXPORT int
sign(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sign;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sign_dwa(void *z, void *l, void *r)
{
	return call_dwa(sign, z, l, r);
}

EXPORT int
mul(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.mul;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
mul_dwa(void *z, void *l, void *r)
{
	return call_dwa(mul, z, l, r);
}

EXPORT int
recip(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.recip;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
recip_dwa(void *z, void *l, void *r)
{
	return call_dwa(recip, z, l, r);
}

EXPORT int
div(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.div;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
div_dwa(void *z, void *l, void *r)
{
	return call_dwa(div, z, l, r);
}

EXPORT int
exp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.exp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
exp_dwa(void *z, void *l, void *r)
{
	return call_dwa(exp, z, l, r);
}

EXPORT int
split(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.split;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
split_dwa(void *z, void *l, void *r)
{
	return call_dwa(split, z, l, r);
}

EXPORT int
drop(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.drop;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drop_dwa(void *z, void *l, void *r)
{
	return call_dwa(drop, z, l, r);
}

EXPORT int
drp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.drp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drp_dwa(void *z, void *l, void *r)
{
	return call_dwa(drp, z, l, r);
}

EXPORT int
reverse_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.reverse_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reverse_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(reverse_last, z, l, r);
}

EXPORT int
rotate_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rotate_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rotate_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(rotate_last, z, l, r);
}

EXPORT int
rot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rot_dwa(void *z, void *l, void *r)
{
	return call_dwa(rot, z, l, r);
}

EXPORT int
map_monadic(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.map_monadic;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
map_monadic_dwa(void *z, void *l, void *r)
{
	return call_dwa(map_monadic, z, l, r);
}

EXPORT int
rpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rpf;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(rpf, z, l, r);
}

