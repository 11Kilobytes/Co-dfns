#include "codfns.h"
#include "prim.h"

EXPORT int
DyalogGetInterpreterFunctions(void *p)
{
    return set_dwafns(p);
}

extern struct cell_func *q_signal_ibeam;
extern struct cell_func *q_dr_ibeam;
extern struct cell_array *span_array;
extern struct cell_func *squeeze_ibeam;
extern struct cell_func *is_simple_ibeam;
extern struct cell_func *is_numeric_ibeam;
extern struct cell_func *is_char_ibeam;
extern struct cell_func *is_integer_ibeam;
extern struct cell_func *is_span_ibeam;
extern struct cell_func *max_shp_ibeam;
extern struct cell_func *max_shp_ibeam;
extern struct cell_func *has_nat_vals_ibeam;
extern struct cell_func *any_ibeam;
extern struct cell_moper *veach_ibeam;
extern struct cell_func *set_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *shape_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *same_ibeam;
extern struct cell_func *nqv_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_gen_vec;
extern struct cell_func *index_gen_vec;
extern struct cell_func *disclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *conjugate_vec_ibeam;
extern struct cell_func *conjugate_vec_ibeam;
extern struct cell_func *add_vec_ibeam;
extern struct cell_func *sub_vec_ibeam;
extern struct cell_func *mul_vec_ibeam;
extern struct cell_func *div_vec_ibeam;
extern struct cell_func *abs_vec_ibeam;
extern struct cell_func *abs_vec_ibeam;
extern struct cell_func *floor_vec_ibeam;
extern struct cell_func *floor_vec_ibeam;
extern struct cell_func *min_vec_ibeam;
extern struct cell_func *ceil_vec_ibeam;
extern struct cell_func *ceil_vec_ibeam;
extern struct cell_func *max_vec_ibeam;
extern struct cell_func *pow_vec_ibeam;
extern struct cell_func *exp_vec_ibeam;
extern struct cell_func *log_vec_ibeam;
extern struct cell_func *nlg_vec_ibeam;
extern struct cell_func *sin_vec_ibeam;
extern struct cell_func *arcsin_vec_ibeam;
extern struct cell_func *cos_vec_ibeam;
extern struct cell_func *arccos_vec_ibeam;
extern struct cell_func *tan_vec_ibeam;
extern struct cell_func *arctan_vec_ibeam;
extern struct cell_func *sinh_vec_ibeam;
extern struct cell_func *arcsinh_vec_ibeam;
extern struct cell_func *cosh_vec_ibeam;
extern struct cell_func *arccosh_vec_ibeam;
extern struct cell_func *tanh_vec_ibeam;
extern struct cell_func *arctanh_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *sin_vec_ibeam;
extern struct cell_func *arcsin_vec_ibeam;
extern struct cell_func *cos_vec_ibeam;
extern struct cell_func *arccos_vec_ibeam;
extern struct cell_func *tan_vec_ibeam;
extern struct cell_func *arctan_vec_ibeam;
extern struct cell_func *sinh_vec_ibeam;
extern struct cell_func *arcsinh_vec_ibeam;
extern struct cell_func *cosh_vec_ibeam;
extern struct cell_func *arccosh_vec_ibeam;
extern struct cell_func *tanh_vec_ibeam;
extern struct cell_func *arctanh_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *factorial_vec_ibeam;
extern struct cell_func *not_vec_ibeam;
extern struct cell_func *not_vec_ibeam;
extern struct cell_func *and_vec_ibeam;
extern struct cell_func *and_vec_ibeam;
extern struct cell_func *lor_vec_ibeam;
extern struct cell_func *lor_vec_ibeam;
extern struct cell_func *lth_vec_ibeam;
extern struct cell_func *lth_vec_ibeam;
extern struct cell_func *lte_vec_ibeam;
extern struct cell_func *lte_vec_ibeam;
extern struct cell_func *eql_vec_ibeam;
extern struct cell_func *gte_vec_ibeam;
extern struct cell_func *gte_vec_ibeam;
extern struct cell_func *gth_vec_ibeam;
extern struct cell_func *gth_vec_ibeam;
extern struct cell_func *neq_vec_ibeam;
extern struct cell_moper *identity_ibeam;
extern struct cell_moper *identity_ibeam;
extern struct cell_moper *identity_ibeam;
extern struct cell_moper *identity_ibeam;

int ptr8798(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8799(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8800(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8801(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8802(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8803(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8804(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8805(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8806(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8807(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8808(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8809(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8810(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8811(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8812(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8813(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8814(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8815(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8816(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8817(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8818(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8819(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8820(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8821(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8822(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8823(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8824(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8825(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8826(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8827(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8828(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8829(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8830(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8831(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8832(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8833(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8834(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8835(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8836(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8837(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8838(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8839(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8840(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8841(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8842(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8843(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8844(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8845(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8846(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8847(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8848(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8849(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8850(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8851(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8852(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8853(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8854(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8855(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8856(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8857(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8858(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8859(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8860(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8861(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8862(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8863(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8864(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8865(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8866(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8867(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8868(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8869(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8870(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8871(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8872(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8873(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8874(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8875(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8876(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8877(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8878(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8879(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8880(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8881(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8882(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8883(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8884(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8885(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8886(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8887(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8888(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8889(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8890(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8891(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8892(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8893(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8894(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8895(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8896(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8897(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8898(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8899(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8900(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8901(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8902(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8903(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8904(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8905(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8906(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8907(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8908(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8909(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8910(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8911(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8912(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8913(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8914(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8915(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8916(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8917(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8918(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8919(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8920(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8921(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8922(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8923(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8924(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8925(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8926(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8927(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8928(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8929(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8930(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8931(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8932(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8933(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8934(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8935(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8936(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8937(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8938(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8939(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8940(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8941(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8942(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8943(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8944(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8945(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8946(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8947(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8948(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8949(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8950(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8951(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8952(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8953(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8954(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8955(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8956(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8957(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8958(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8959(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8960(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8961(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8962(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8963(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8964(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8965(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8966(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8967(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8968(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8969(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8970(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8971(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8972(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8973(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8974(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8975(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8976(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8977(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8978(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8979(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8980(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8981(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8982(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8983(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8984(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8985(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8986(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8987(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8988(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8989(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8990(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8991(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8992(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8993(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8994(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8995(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8996(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8997(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr8998(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr8999(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9000(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9001(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9002(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9003(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9004(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9005(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9006(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9007(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9008(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9009(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9010(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9011(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9012(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9013(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9014(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9015(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9016(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9017(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9018(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9019(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9020(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9021(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9022(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9023(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9024(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9025(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9026(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9027(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9028(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9029(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9030(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9031(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9032(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9033(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9034(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9035(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9036(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9037(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9038(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9039(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9040(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9041(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9042(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9043(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9044(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9045(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9046(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9047(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9048(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9049(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9050(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9051(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9052(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9053(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9054(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9055(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9056(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9057(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9058(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9059(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9060(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9061(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9062(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9063(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9064(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9065(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9066(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9067(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9068(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9069(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9070(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9071(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9072(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9073(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9074(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9075(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9076(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9077(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9078(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9079(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr9080(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr9081(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);

int cdf_prim_flag = 0;

wchar_t *cdf_prim_names[] = {L"q_signal", L"q_dr", L"spn", L"squeeze", L"is_simple", L"is_numeric", L"is_char", L"is_integer", L"is_bool", L"is_span", L"max_shp", L"has_nat_vals", L"chk_scl", L"chk_valid_shape", L"both_simple", L"both_numeric", L"both_integer", L"both_char", L"both_bool", L"any", L"numeric", L"ambiv", L"same", L"veach", L"scalar", L"idx_shp_check", L"idx_rng_check", L"set", L"brk", L"rgt", L"lft", L"reshape", L"rho", L"cat", L"depth", L"eqv", L"nqv", L"sqd_vec", L"sqd", L"index_gen", L"index_of", L"iot", L"dis", L"enclose", L"par", L"conjugate", L"add", L"sub", L"sign", L"mul", L"div", L"absolute", L"residue", L"res", L"floor_array", L"min", L"ceil_array", L"max", L"exp", L"log", L"pitimes", L"trig", L"cir", L"binomial", L"fac", L"notscl", L"without", L"not", L"logand", L"and", L"logor", L"lor", L"nan", L"nor", L"lessthan", L"lth", L"lesseql", L"lte", L"eql_vec", L"equal", L"eql", L"greatereql", L"gte", L"greaterthan", L"gth", L"firstocc", L"neq_vec", L"noteq", L"neq", L"mix", L"take", L"tke", L"split", L"drop", L"drp", L"reverse_last", L"rotate_last", L"rot", L"com", L"map", L"reduce", L"nwreduce", L"rdf", L"rpf", L"scf", L"dot", L"oup", L"pow", L"jot"};

EXPORT int
cdf_prim_init(void)
{
	struct cdf_prim_loc *loc;
	void *stk[128];
	void **stkhd;
	int err;

	if (cdf_prim_flag)
		return 0;

	err = 0;
	cdf_prim_flag = 1;
	stkhd = &stk[0];
	loc = &cdf_prim;
	loc->__count = 109;
	loc->__names = cdf_prim_names;

	if (debug_info)
		release_array(debug_info);

	debug_info = NULL;

	CHKFN(cdf_prim_init(), cleanup);

	loc->q_signal = NULL;
	loc->q_dr = NULL;
	loc->spn = NULL;
	CHK(mk_func_box(&loc->squeeze, NULL), cleanup, L"Init mutable variable: loc->squeeze");
	CHK(mk_func_box(&loc->is_simple, NULL), cleanup, L"Init mutable variable: loc->is_simple");
	CHK(mk_func_box(&loc->is_numeric, NULL), cleanup, L"Init mutable variable: loc->is_numeric");
	CHK(mk_func_box(&loc->is_char, NULL), cleanup, L"Init mutable variable: loc->is_char");
	CHK(mk_func_box(&loc->is_integer, NULL), cleanup, L"Init mutable variable: loc->is_integer");
	CHK(mk_func_box(&loc->is_bool, NULL), cleanup, L"Init mutable variable: loc->is_bool");
	CHK(mk_func_box(&loc->is_span, NULL), cleanup, L"Init mutable variable: loc->is_span");
	CHK(mk_func_box(&loc->max_shp, NULL), cleanup, L"Init mutable variable: loc->max_shp");
	CHK(mk_func_box(&loc->has_nat_vals, NULL), cleanup, L"Init mutable variable: loc->has_nat_vals");
	CHK(mk_func_box(&loc->chk_scl, NULL), cleanup, L"Init mutable variable: loc->chk_scl");
	CHK(mk_func_box(&loc->chk_valid_shape, NULL), cleanup, L"Init mutable variable: loc->chk_valid_shape");
	CHK(mk_func_box(&loc->both_simple, NULL), cleanup, L"Init mutable variable: loc->both_simple");
	CHK(mk_func_box(&loc->both_numeric, NULL), cleanup, L"Init mutable variable: loc->both_numeric");
	CHK(mk_func_box(&loc->both_integer, NULL), cleanup, L"Init mutable variable: loc->both_integer");
	CHK(mk_func_box(&loc->both_char, NULL), cleanup, L"Init mutable variable: loc->both_char");
	CHK(mk_func_box(&loc->both_bool, NULL), cleanup, L"Init mutable variable: loc->both_bool");
	CHK(mk_func_box(&loc->any, NULL), cleanup, L"Init mutable variable: loc->any");
	loc->numeric = NULL;
	loc->ambiv = NULL;
	CHK(mk_func_box(&loc->same, NULL), cleanup, L"Init mutable variable: loc->same");
	CHK(mk_moper_box(&loc->veach, NULL), cleanup, L"Init mutable variable: loc->veach");
	loc->scalar = NULL;
	loc->idx_shp_check = NULL;
	loc->idx_rng_check = NULL;
	loc->set = NULL;
	loc->brk = NULL;
	loc->rgt = NULL;
	loc->lft = NULL;
	loc->reshape = NULL;
	loc->rho = NULL;
	loc->cat = NULL;
	loc->depth = NULL;
	loc->eqv = NULL;
	loc->nqv = NULL;
	CHK(mk_func_box(&loc->sqd_vec, NULL), cleanup, L"Init mutable variable: loc->sqd_vec");
	loc->sqd = NULL;
	loc->index_gen = NULL;
	loc->index_of = NULL;
	loc->iot = NULL;
	loc->dis = NULL;
	loc->enclose = NULL;
	loc->par = NULL;
	loc->conjugate = NULL;
	loc->add = NULL;
	loc->sub = NULL;
	loc->sign = NULL;
	loc->mul = NULL;
	loc->div = NULL;
	loc->absolute = NULL;
	loc->residue = NULL;
	loc->res = NULL;
	loc->floor_array = NULL;
	loc->min = NULL;
	loc->ceil_array = NULL;
	loc->max = NULL;
	loc->exp = NULL;
	loc->log = NULL;
	loc->pitimes = NULL;
	loc->trig = NULL;
	loc->cir = NULL;
	loc->binomial = NULL;
	loc->fac = NULL;
	loc->notscl = NULL;
	loc->without = NULL;
	loc->not = NULL;
	loc->logand = NULL;
	loc->and = NULL;
	loc->logor = NULL;
	loc->lor = NULL;
	loc->nan = NULL;
	loc->nor = NULL;
	loc->lessthan = NULL;
	loc->lth = NULL;
	loc->lesseql = NULL;
	loc->lte = NULL;
	CHK(mk_func_box(&loc->eql_vec, NULL), cleanup, L"Init mutable variable: loc->eql_vec");
	loc->equal = NULL;
	loc->eql = NULL;
	loc->greatereql = NULL;
	loc->gte = NULL;
	loc->greaterthan = NULL;
	loc->gth = NULL;
	loc->firstocc = NULL;
	CHK(mk_func_box(&loc->neq_vec, NULL), cleanup, L"Init mutable variable: loc->neq_vec");
	loc->noteq = NULL;
	loc->neq = NULL;
	loc->mix = NULL;
	loc->take = NULL;
	loc->tke = NULL;
	loc->split = NULL;
	loc->drop = NULL;
	loc->drp = NULL;
	loc->reverse_last = NULL;
	loc->rotate_last = NULL;
	loc->rot = NULL;
	loc->com = NULL;
	loc->map = NULL;
	CHK(mk_moper_box(&loc->reduce, NULL), cleanup, L"Init mutable variable: loc->reduce");
	CHK(mk_moper_box(&loc->nwreduce, NULL), cleanup, L"Init mutable variable: loc->nwreduce");
	loc->rdf = NULL;
	loc->rpf = NULL;
	loc->scf = NULL;
	loc->dot = NULL;
	loc->oup = NULL;
	loc->pow = NULL;
	loc->jot = NULL;

	if (!q_signal_ibeam)
		CHK(6, cleanup, L"[4] q_signal←╠'q_signal_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(q_signal_ibeam);
	
	release_cell(loc->q_signal);
	loc->q_signal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!q_dr_ibeam)
		CHK(6, cleanup, L"[5] q_dr←╠'q_dr_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(q_dr_ibeam);
	
	release_cell(loc->q_dr);
	loc->q_dr = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!span_array)
		CHK(6, cleanup, L"[8] spn←╠'span_array'⌶⌶⌶⌶╣");
	
	*stkhd++ = retain_cell(span_array);
	
	release_cell(loc->spn);
	loc->spn = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!squeeze_ibeam)
		CHK(6, cleanup, L"[11] squeeze←╠'squeeze_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(squeeze_ibeam);
	
	release_cell(loc->squeeze->value);
	loc->squeeze->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_simple_ibeam)
		CHK(6, cleanup, L"[12] is_simple←╠'is_simple_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_simple_ibeam);
	
	release_cell(loc->is_simple->value);
	loc->is_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_numeric_ibeam)
		CHK(6, cleanup, L"[13] is_numeric←╠'is_numeric_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_numeric_ibeam);
	
	release_cell(loc->is_numeric->value);
	loc->is_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_char_ibeam)
		CHK(6, cleanup, L"[14] is_char←╠'is_char_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_char_ibeam);
	
	release_cell(loc->is_char->value);
	loc->is_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_integer_ibeam)
		CHK(6, cleanup, L"[15] is_integer←╠'is_integer_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_integer_ibeam);
	
	release_cell(loc->is_integer->value);
	loc->is_integer->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8798, ptr8799, 1), cleanup, 
		    L"[16] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->is_bool->value);
	loc->is_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_span_ibeam)
		CHK(6, cleanup, L"[17] is_span←╠'is_span_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_span_ibeam);
	
	release_cell(loc->is_span->value);
	loc->is_span->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8800, ptr8801, 0), cleanup, 
		    L"[18] max_shp←╠{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->max_shp->value);
	loc->max_shp->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!has_nat_vals_ibeam)
		CHK(6, cleanup, L"[19] has_nat_vals←╠'has_nat_vals_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(has_nat_vals_ibeam);
	
	release_cell(loc->has_nat_vals->value);
	loc->has_nat_vals->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8802, ptr8803, 0), cleanup, 
		    L"[20] chk_scl←╠{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->chk_scl->value);
	loc->chk_scl->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8804, ptr8809, 1), cleanup, 
		    L"[21] chk_valid_shape←╠{╣");
	
		k->fv[0] = retain_cell(loc->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->chk_valid_shape->value);
	loc->chk_valid_shape->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8814, ptr8815, 1), cleanup, 
		    L"[26] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->both_simple->value);
	loc->both_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8816, ptr8817, 1), cleanup, 
		    L"[27] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->both_numeric->value);
	loc->both_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8818, ptr8819, 1), cleanup, 
		    L"[28] both_integer←╠{is_integer ⍺:is_integer ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->both_integer->value);
	loc->both_integer->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8820, ptr8821, 1), cleanup, 
		    L"[29] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_char);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->both_char->value);
	loc->both_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8822, ptr8823, 1), cleanup, 
		    L"[30] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->both_bool->value);
	loc->both_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!any_ibeam)
		CHK(6, cleanup, L"[31] any←╠'any_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(any_ibeam);
	
	release_cell(loc->any->value);
	loc->any->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr8824, ptr8825, ptr8826, ptr8827, 1), cleanup, 
		    L"[32] numeric←╠{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->numeric);
	loc->numeric = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr8828, ptr8829, ptr8830, ptr8831, ptr8832, ptr8833, ptr8834, ptr8835, 1), cleanup, 
		    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	
		k->fv[0] = retain_cell(loc->same);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->ambiv);
	loc->ambiv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!veach_ibeam)
		CHK(6, cleanup, L"[34] veach←╠'veach_ibeam'⌶⌶╣");
	
	*stkhd++ = retain_cell(veach_ibeam);
	
	release_cell(loc->veach->value);
	loc->veach->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr8836, ptr8837, ptr8838, ptr8839, 5), cleanup, 
		    L"[35] scalar←╠{╣");
	
		k->fv[0] = retain_cell(loc->veach);
		k->fv[1] = retain_cell(loc->both_simple);
		k->fv[2] = retain_cell(loc->chk_scl);
		k->fv[3] = retain_cell(loc->max_shp);
		k->fv[4] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->scalar);
	loc->scalar = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8840, ptr8841, 0), cleanup, 
		    L"[45] idx_shp_check←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->idx_shp_check);
	loc->idx_shp_check = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8842, ptr8843, 3), cleanup, 
		    L"[52] idx_rng_check←╠{╣");
	
		k->fv[0] = retain_cell(loc->any);
		k->fv[1] = retain_cell(loc->is_integer);
		k->fv[2] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->idx_rng_check);
	loc->idx_rng_check = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!set_ibeam)
		CHK(6, cleanup, L"[58] set←╠'set_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(set_ibeam);
	
	release_cell(loc->set);
	loc->set = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8844, ptr8845, 0), cleanup, 
		    L"[61] brk←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->brk);
	loc->brk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8846, ptr8847, 0), cleanup, 
		    L"[67] rgt←╠{⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->rgt);
	loc->rgt = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8850, ptr8851, 0), cleanup, 
		    L"[70] lft←{⍵} ambiv ╠{⍺}╣");
	
		*stkhd++ = k;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[70] lft←{⍵} ╠ambiv╣ {⍺}");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8848, ptr8849, 0), cleanup, 
		    L"[70] lft←╠{⍵}╣ ambiv {⍺}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[70] lft←╠{⍵} ambiv {⍺}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lft);
	loc->lft = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8852, ptr8853, 1), cleanup, 
		    L"[73] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->reshape);
	loc->reshape = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->reshape)
		CHK(6, cleanup, L"[74] rho←('shape_ibeam'⌶) ambiv ╠reshape╣");
	
	*stkhd++ = retain_cell(loc->reshape);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[74] rho←('shape_ibeam'⌶) ╠ambiv╣ reshape");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!shape_ibeam)
		CHK(6, cleanup, L"[74] rho←╠('shape_ibeam'⌶)╣ ambiv reshape");
	
	*stkhd++ = retain_cell(shape_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[74] rho←╠('shape_ibeam'⌶) ambiv reshape╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rho);
	loc->rho = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8854, ptr8865, 1), cleanup, 
		    L"[77] cat←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->cat);
	loc->cat = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8876, ptr8879, 1), cleanup, 
		    L"[103] depth←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->depth);
	loc->depth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!same_ibeam)
		CHK(6, cleanup, L"[110] same←╠'same_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(same_ibeam);
	
	release_cell(loc->same->value);
	loc->same->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->same->value)
		CHK(6, cleanup, L"[111] eqv←depth ambiv ╠same╣");
	
	*stkhd++ = retain_cell(loc->same->value);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[111] eqv←depth ╠ambiv╣ same");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->depth)
		CHK(6, cleanup, L"[111] eqv←╠depth╣ ambiv same");
	
	*stkhd++ = retain_cell(loc->depth);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[111] eqv←╠depth ambiv same╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->eqv);
	loc->eqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!nqv_ibeam)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ╠('nqv_ibeam'⌶)╣");
	
	*stkhd++ = retain_cell(nqv_ibeam);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵} ╠ambiv╣ ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8882, ptr8883, 0), cleanup, 
		    L"[114] nqv←╠{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵}╣ ambiv ('nqv_ibeam'⌶)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[114] nqv←╠{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->nqv);
	loc->nqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8884, ptr8885, 4), cleanup, 
		    L"[117] sqd_vec←╠{╣");
	
		k->fv[0] = retain_cell(loc->any);
		k->fv[1] = retain_cell(loc->is_span);
		k->fv[2] = retain_cell(loc->is_integer);
		k->fv[3] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->sqd_vec->value);
	loc->sqd_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8886, ptr8893, 2), cleanup, 
		    L"[124] sqd←╠{⍺←⊢╣");
	
		k->fv[0] = retain_cell(loc->sqd_vec);
		k->fv[1] = retain_cell(loc->is_span);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->sqd);
	loc->sqd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8900, ptr8901, 1), cleanup, 
		    L"[135] index_gen←╠{╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->index_gen);
	loc->index_gen = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8902, ptr8903, 0), cleanup, 
		    L"[142] index_of←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->index_of);
	loc->index_of = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->index_of)
		CHK(6, cleanup, L"[143] iot←index_gen ambiv ╠index_of╣");
	
	*stkhd++ = retain_cell(loc->index_of);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[143] iot←index_gen ╠ambiv╣ index_of");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->index_gen)
		CHK(6, cleanup, L"[143] iot←╠index_gen╣ ambiv index_of");
	
	*stkhd++ = retain_cell(loc->index_gen);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[143] iot←╠index_gen ambiv index_of╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->iot);
	loc->iot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8904, ptr8905, 0), cleanup, 
		    L"[146] dis←('disclose_ibeam'⌶) ambiv ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[146] dis←('disclose_ibeam'⌶) ╠ambiv╣ {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!disclose_ibeam)
		CHK(6, cleanup, L"[146] dis←╠('disclose_ibeam'⌶)╣ ambiv {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(disclose_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[146] dis←╠('disclose_ibeam'⌶) ambiv {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->dis);
	loc->dis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8906, ptr8907, 0), cleanup, 
		    L"[149] enclose←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->enclose);
	loc->enclose = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8908, ptr8909, 0), cleanup, 
		    L"[153] par←enclose ambiv ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[153] par←enclose ╠ambiv╣ {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->enclose)
		CHK(6, cleanup, L"[153] par←╠enclose╣ ambiv {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->enclose);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[153] par←╠enclose ambiv {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->par);
	loc->par = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8910, ptr8911, 1), cleanup, 
		    L"[156] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->conjugate);
	loc->conjugate = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[157] add←conjugate ambiv ('add_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[157] add←conjugate ambiv ('add_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!add_vec_ibeam)
		CHK(6, cleanup, L"[157] add←conjugate ambiv (╠'add_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(add_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[157] add←conjugate ambiv (╠'add_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[157] add←conjugate ambiv ╠('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[157] add←conjugate ╠ambiv╣ ('add_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->conjugate)
		CHK(6, cleanup, L"[157] add←╠conjugate╣ ambiv ('add_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->conjugate);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[157] add←╠conjugate ambiv ('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->add);
	loc->add = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[160] sub←{0-⍵} ambiv ('sub_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[160] sub←{0-⍵} ambiv ('sub_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!sub_vec_ibeam)
		CHK(6, cleanup, L"[160] sub←{0-⍵} ambiv (╠'sub_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(sub_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[160] sub←{0-⍵} ambiv (╠'sub_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[160] sub←{0-⍵} ambiv ╠('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[160] sub←{0-⍵} ╠ambiv╣ ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8912, ptr8913, 0), cleanup, 
		    L"[160] sub←╠{0-⍵}╣ ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[160] sub←╠{0-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->sub);
	loc->sub = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8914, ptr8915, 0), cleanup, 
		    L"[163] sign←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->sign);
	loc->sign = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[167] mul←sign ambiv ('mul_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[167] mul←sign ambiv ('mul_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!mul_vec_ibeam)
		CHK(6, cleanup, L"[167] mul←sign ambiv (╠'mul_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(mul_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[167] mul←sign ambiv (╠'mul_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[167] mul←sign ambiv ╠('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[167] mul←sign ╠ambiv╣ ('mul_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->sign)
		CHK(6, cleanup, L"[167] mul←╠sign╣ ambiv ('mul_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->sign);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[167] mul←╠sign ambiv ('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->mul);
	loc->mul = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[170] div←{1÷⍵} ambiv ('div_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[170] div←{1÷⍵} ambiv ('div_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!div_vec_ibeam)
		CHK(6, cleanup, L"[170] div←{1÷⍵} ambiv (╠'div_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(div_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[170] div←{1÷⍵} ambiv (╠'div_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[170] div←{1÷⍵} ambiv ╠('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[170] div←{1÷⍵} ╠ambiv╣ ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8916, ptr8917, 0), cleanup, 
		    L"[170] div←╠{1÷⍵}╣ ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[170] div←╠{1÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->div);
	loc->div = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8918, ptr8919, 1), cleanup, 
		    L"[173] absolute←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->absolute);
	loc->absolute = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8920, ptr8921, 0), cleanup, 
		    L"[178] residue←╠{⍵-⍺×⌊⍵÷⍺+0=⍺}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->residue);
	loc->residue = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->residue)
		CHK(6, cleanup, L"[179] res←absolute numeric ambiv ╠residue╣");
	
	*stkhd++ = retain_cell(loc->residue);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[179] res←absolute numeric ╠ambiv╣ residue");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[179] res←absolute ╠numeric╣ ambiv residue");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->absolute)
		CHK(6, cleanup, L"[179] res←╠absolute╣ numeric ambiv residue");
	
	*stkhd++ = retain_cell(loc->absolute);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[179] res←╠absolute numeric╣ ambiv residue");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[179] res←╠absolute numeric ambiv residue╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->res);
	loc->res = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8922, ptr8923, 1), cleanup, 
		    L"[182] floor_array←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->floor_array);
	loc->floor_array = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[187] min←floor_array numeric ambiv ('min_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[187] min←floor_array numeric ambiv ('min_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!min_vec_ibeam)
		CHK(6, cleanup, L"[187] min←floor_array numeric ambiv (╠'min_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(min_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[187] min←floor_array numeric ambiv (╠'min_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[187] min←floor_array numeric ambiv ╠('min_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[187] min←floor_array numeric ╠ambiv╣ ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[187] min←floor_array ╠numeric╣ ambiv ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->floor_array)
		CHK(6, cleanup, L"[187] min←╠floor_array╣ numeric ambiv ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->floor_array);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[187] min←╠floor_array numeric╣ ambiv ('min_vec_ibeam'⌶ numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[187] min←╠floor_array numeric ambiv ('min_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->min);
	loc->min = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8924, ptr8925, 1), cleanup, 
		    L"[190] ceil_array←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->ceil_array);
	loc->ceil_array = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[195] max←ceil_array numeric ambiv ('max_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[195] max←ceil_array numeric ambiv ('max_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!max_vec_ibeam)
		CHK(6, cleanup, L"[195] max←ceil_array numeric ambiv (╠'max_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(max_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[195] max←ceil_array numeric ambiv (╠'max_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[195] max←ceil_array numeric ambiv ╠('max_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[195] max←ceil_array numeric ╠ambiv╣ ('max_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[195] max←ceil_array ╠numeric╣ ambiv ('max_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->ceil_array)
		CHK(6, cleanup, L"[195] max←╠ceil_array╣ numeric ambiv ('max_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ceil_array);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[195] max←╠ceil_array numeric╣ ambiv ('max_vec_ibeam'⌶ numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[195] max←╠ceil_array numeric ambiv ('max_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->max);
	loc->max = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[198] exp←'exp_vec_ibeam'⌶ numeric ambiv ('pow_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[198] exp←'exp_vec_ibeam'⌶ numeric ambiv ('pow_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!pow_vec_ibeam)
		CHK(6, cleanup, L"[198] exp←'exp_vec_ibeam'⌶ numeric ambiv (╠'pow_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(pow_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[198] exp←'exp_vec_ibeam'⌶ numeric ambiv (╠'pow_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[198] exp←'exp_vec_ibeam'⌶ numeric ambiv ╠('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[198] exp←'exp_vec_ibeam'⌶ numeric ╠ambiv╣ ('pow_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[198] exp←'exp_vec_ibeam'⌶ ╠numeric╣ ambiv ('pow_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!exp_vec_ibeam)
		CHK(6, cleanup, L"[198] exp←╠'exp_vec_ibeam'⌶╣ numeric ambiv ('pow_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(exp_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[198] exp←╠'exp_vec_ibeam'⌶ numeric╣ ambiv ('pow_vec_ibeam'⌶ numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[198] exp←╠'exp_vec_ibeam'⌶ numeric ambiv ('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->exp);
	loc->exp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[201] log←'nlg_vec_ibeam'⌶ numeric ambiv ('log_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[201] log←'nlg_vec_ibeam'⌶ numeric ambiv ('log_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!log_vec_ibeam)
		CHK(6, cleanup, L"[201] log←'nlg_vec_ibeam'⌶ numeric ambiv (╠'log_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(log_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[201] log←'nlg_vec_ibeam'⌶ numeric ambiv (╠'log_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[201] log←'nlg_vec_ibeam'⌶ numeric ambiv ╠('log_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[201] log←'nlg_vec_ibeam'⌶ numeric ╠ambiv╣ ('log_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[201] log←'nlg_vec_ibeam'⌶ ╠numeric╣ ambiv ('log_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!nlg_vec_ibeam)
		CHK(6, cleanup, L"[201] log←╠'nlg_vec_ibeam'⌶╣ numeric ambiv ('log_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(nlg_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[201] log←╠'nlg_vec_ibeam'⌶ numeric╣ ambiv ('log_vec_ibeam'⌶ numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[201] log←╠'nlg_vec_ibeam'⌶ numeric ambiv ('log_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->log);
	loc->log = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8926, ptr8927, 0), cleanup, 
		    L"[204] pitimes←╠{3.14159265358979323846×⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->pitimes);
	loc->pitimes = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8928, ptr8933, 0), cleanup, 
		    L"[205] trig←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->trig);
	loc->trig = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[234] cir←pitimes numeric ambiv (trig numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[234] cir←pitimes numeric ambiv (trig ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->trig)
		CHK(6, cleanup, L"[234] cir←pitimes numeric ambiv (╠trig╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->trig);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[234] cir←pitimes numeric ambiv (╠trig numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[234] cir←pitimes numeric ambiv ╠(trig numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[234] cir←pitimes numeric ╠ambiv╣ (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[234] cir←pitimes ╠numeric╣ ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->pitimes)
		CHK(6, cleanup, L"[234] cir←╠pitimes╣ numeric ambiv (trig numeric scalar)");
	
	*stkhd++ = retain_cell(loc->pitimes);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[234] cir←╠pitimes numeric╣ ambiv (trig numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[234] cir←╠pitimes numeric ambiv (trig numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->cir);
	loc->cir = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8938, ptr8939, 0), cleanup, 
		    L"[237] binomial←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->binomial);
	loc->binomial = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[241] fac←'factorial_vec_ibeam'⌶ numeric ambiv (binomial numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[241] fac←'factorial_vec_ibeam'⌶ numeric ambiv (binomial ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->binomial)
		CHK(6, cleanup, L"[241] fac←'factorial_vec_ibeam'⌶ numeric ambiv (╠binomial╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->binomial);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[241] fac←'factorial_vec_ibeam'⌶ numeric ambiv (╠binomial numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[241] fac←'factorial_vec_ibeam'⌶ numeric ambiv ╠(binomial numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[241] fac←'factorial_vec_ibeam'⌶ numeric ╠ambiv╣ (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[241] fac←'factorial_vec_ibeam'⌶ ╠numeric╣ ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!factorial_vec_ibeam)
		CHK(6, cleanup, L"[241] fac←╠'factorial_vec_ibeam'⌶╣ numeric ambiv (binomial numeric scalar)");
	
	*stkhd++ = retain_cell(factorial_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[241] fac←╠'factorial_vec_ibeam'⌶ numeric╣ ambiv (binomial numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[241] fac←╠'factorial_vec_ibeam'⌶ numeric ambiv (binomial numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->fac);
	loc->fac = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8940, ptr8941, 1), cleanup, 
		    L"[244] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->is_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->notscl);
	loc->notscl = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8942, ptr8943, 0), cleanup, 
		    L"[245] without←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->without);
	loc->without = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->without)
		CHK(6, cleanup, L"[246] not←notscl ambiv ╠without╣");
	
	*stkhd++ = retain_cell(loc->without);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[246] not←notscl ╠ambiv╣ without");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->notscl)
		CHK(6, cleanup, L"[246] not←╠notscl╣ ambiv without");
	
	*stkhd++ = retain_cell(loc->notscl);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[246] not←╠notscl ambiv without╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->not);
	loc->not = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8944, ptr8945, 1), cleanup, 
		    L"[249] logand←╠{╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->logand);
	loc->logand = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[253] and←{⎕SIGNAL 2}ambiv (logand numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[253] and←{⎕SIGNAL 2}ambiv (logand ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->logand)
		CHK(6, cleanup, L"[253] and←{⎕SIGNAL 2}ambiv (╠logand╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->logand);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[253] and←{⎕SIGNAL 2}ambiv (╠logand numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[253] and←{⎕SIGNAL 2}ambiv ╠(logand numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[253] and←{⎕SIGNAL 2}╠ambiv╣ (logand numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8946, ptr8947, 0), cleanup, 
		    L"[253] and←╠{⎕SIGNAL 2}╣ambiv (logand numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[253] and←╠{⎕SIGNAL 2}ambiv (logand numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->and);
	loc->and = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8948, ptr8953, 4), cleanup, 
		    L"[256] logor←╠{╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
		k->fv[1] = retain_cell(loc->both_integer);
		k->fv[2] = retain_cell(loc->is_bool);
		k->fv[3] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->logor);
	loc->logor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[263] lor←{⎕SIGNAL 2}ambiv (logor numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[263] lor←{⎕SIGNAL 2}ambiv (logor ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->logor)
		CHK(6, cleanup, L"[263] lor←{⎕SIGNAL 2}ambiv (╠logor╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->logor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[263] lor←{⎕SIGNAL 2}ambiv (╠logor numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[263] lor←{⎕SIGNAL 2}ambiv ╠(logor numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[263] lor←{⎕SIGNAL 2}╠ambiv╣ (logor numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8958, ptr8959, 0), cleanup, 
		    L"[263] lor←╠{⎕SIGNAL 2}╣ambiv (logor numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[263] lor←╠{⎕SIGNAL 2}ambiv (logor numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lor);
	loc->lor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8962, ptr8963, 1), cleanup, 
		    L"[266] nan←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}╠ambiv╣{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8960, ptr8961, 0), cleanup, 
		    L"[266] nan←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[266] nan←╠{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->nan);
	loc->nan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8966, ptr8967, 1), cleanup, 
		    L"[269] nor←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}╠ambiv╣{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8964, ptr8965, 0), cleanup, 
		    L"[269] nor←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[269] nor←╠{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->nor);
	loc->nor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8968, ptr8969, 0), cleanup, 
		    L"[272] lessthan←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->lessthan);
	loc->lessthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[276] lth←{⎕SIGNAL 2} ambiv (lessthan numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[276] lth←{⎕SIGNAL 2} ambiv (lessthan ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->lessthan)
		CHK(6, cleanup, L"[276] lth←{⎕SIGNAL 2} ambiv (╠lessthan╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->lessthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[276] lth←{⎕SIGNAL 2} ambiv (╠lessthan numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[276] lth←{⎕SIGNAL 2} ambiv ╠(lessthan numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[276] lth←{⎕SIGNAL 2} ╠ambiv╣ (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8970, ptr8971, 0), cleanup, 
		    L"[276] lth←╠{⎕SIGNAL 2}╣ ambiv (lessthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[276] lth←╠{⎕SIGNAL 2} ambiv (lessthan numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lth);
	loc->lth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8972, ptr8973, 0), cleanup, 
		    L"[279] lesseql←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->lesseql);
	loc->lesseql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[283] lte←{⎕SIGNAL 2}ambiv (lesseql numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[283] lte←{⎕SIGNAL 2}ambiv (lesseql ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->lesseql)
		CHK(6, cleanup, L"[283] lte←{⎕SIGNAL 2}ambiv (╠lesseql╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->lesseql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[283] lte←{⎕SIGNAL 2}ambiv (╠lesseql numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[283] lte←{⎕SIGNAL 2}ambiv ╠(lesseql numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[283] lte←{⎕SIGNAL 2}╠ambiv╣ (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8974, ptr8975, 0), cleanup, 
		    L"[283] lte←╠{⎕SIGNAL 2}╣ambiv (lesseql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[283] lte←╠{⎕SIGNAL 2}ambiv (lesseql numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lte);
	loc->lte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!eql_vec_ibeam)
		CHK(6, cleanup, L"[286] eql_vec←╠'eql_vec_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(eql_vec_ibeam);
	
	release_cell(loc->eql_vec->value);
	loc->eql_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8976, ptr8977, 3), cleanup, 
		    L"[287] equal←╠{╣");
	
		k->fv[0] = retain_cell(loc->eql_vec);
		k->fv[1] = retain_cell(loc->both_char);
		k->fv[2] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->equal);
	loc->equal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[292] eql←{⎕SIGNAL 2}ambiv (equal ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->equal)
		CHK(6, cleanup, L"[292] eql←{⎕SIGNAL 2}ambiv (╠equal╣ scalar)");
	
	*stkhd++ = retain_cell(loc->equal);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[292] eql←{⎕SIGNAL 2}ambiv ╠(equal scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[292] eql←{⎕SIGNAL 2}╠ambiv╣ (equal scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8978, ptr8979, 0), cleanup, 
		    L"[292] eql←╠{⎕SIGNAL 2}╣ambiv (equal scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[292] eql←╠{⎕SIGNAL 2}ambiv (equal scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->eql);
	loc->eql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8980, ptr8981, 0), cleanup, 
		    L"[295] greatereql←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->greatereql);
	loc->greatereql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[299] gte←{⎕SIGNAL 2}ambiv (greatereql numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[299] gte←{⎕SIGNAL 2}ambiv (greatereql ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->greatereql)
		CHK(6, cleanup, L"[299] gte←{⎕SIGNAL 2}ambiv (╠greatereql╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->greatereql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[299] gte←{⎕SIGNAL 2}ambiv (╠greatereql numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[299] gte←{⎕SIGNAL 2}ambiv ╠(greatereql numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[299] gte←{⎕SIGNAL 2}╠ambiv╣ (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8982, ptr8983, 0), cleanup, 
		    L"[299] gte←╠{⎕SIGNAL 2}╣ambiv (greatereql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[299] gte←╠{⎕SIGNAL 2}ambiv (greatereql numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->gte);
	loc->gte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8984, ptr8985, 0), cleanup, 
		    L"[302] greaterthan←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->greaterthan);
	loc->greaterthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[306] gth←{⎕SIGNAL 2}ambiv (greaterthan numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[306] gth←{⎕SIGNAL 2}ambiv (greaterthan ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->greaterthan)
		CHK(6, cleanup, L"[306] gth←{⎕SIGNAL 2}ambiv (╠greaterthan╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->greaterthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[306] gth←{⎕SIGNAL 2}ambiv (╠greaterthan numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[306] gth←{⎕SIGNAL 2}ambiv ╠(greaterthan numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[306] gth←{⎕SIGNAL 2}╠ambiv╣ (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8986, ptr8987, 0), cleanup, 
		    L"[306] gth←╠{⎕SIGNAL 2}╣ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[306] gth←╠{⎕SIGNAL 2}ambiv (greaterthan numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->gth);
	loc->gth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8988, ptr8989, 0), cleanup, 
		    L"[309] firstocc←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->firstocc);
	loc->firstocc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!neq_vec_ibeam)
		CHK(6, cleanup, L"[310] neq_vec←╠'neq_vec_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(neq_vec_ibeam);
	
	release_cell(loc->neq_vec->value);
	loc->neq_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8990, ptr8991, 3), cleanup, 
		    L"[311] noteq←╠{╣");
	
		k->fv[0] = retain_cell(loc->neq_vec);
		k->fv[1] = retain_cell(loc->both_char);
		k->fv[2] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->noteq);
	loc->noteq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[316] neq←firstocc ambiv (noteq ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->noteq)
		CHK(6, cleanup, L"[316] neq←firstocc ambiv (╠noteq╣ scalar)");
	
	*stkhd++ = retain_cell(loc->noteq);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[316] neq←firstocc ambiv ╠(noteq scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[316] neq←firstocc ╠ambiv╣ (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->firstocc)
		CHK(6, cleanup, L"[316] neq←╠firstocc╣ ambiv (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->firstocc);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[316] neq←╠firstocc ambiv (noteq scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->neq);
	loc->neq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8992, ptr8993, 0), cleanup, 
		    L"[319] mix←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->mix);
	loc->mix = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8994, ptr8995, 0), cleanup, 
		    L"[320] take←╠{(⊂⍳⍺)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->take);
	loc->take = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->take)
		CHK(6, cleanup, L"[321] tke←mix ambiv ╠take╣");
	
	*stkhd++ = retain_cell(loc->take);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[321] tke←mix ╠ambiv╣ take");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->mix)
		CHK(6, cleanup, L"[321] tke←╠mix╣ ambiv take");
	
	*stkhd++ = retain_cell(loc->mix);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[321] tke←╠mix ambiv take╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->tke);
	loc->tke = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8996, ptr8997, 0), cleanup, 
		    L"[324] split←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->split);
	loc->split = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8998, ptr8999, 0), cleanup, 
		    L"[325] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->drop);
	loc->drop = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->drop)
		CHK(6, cleanup, L"[326] drp←split ambiv ╠drop╣");
	
	*stkhd++ = retain_cell(loc->drop);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[326] drp←split ╠ambiv╣ drop");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->split)
		CHK(6, cleanup, L"[326] drp←╠split╣ ambiv drop");
	
	*stkhd++ = retain_cell(loc->split);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[326] drp←╠split ambiv drop╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->drp);
	loc->drp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9000, ptr9001, 0), cleanup, 
		    L"[329] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->reverse_last);
	loc->reverse_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9002, ptr9003, 0), cleanup, 
		    L"[330] rotate_last←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->rotate_last);
	loc->rotate_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rotate_last)
		CHK(6, cleanup, L"[331] rot←reverse_last ambiv ╠rotate_last╣");
	
	*stkhd++ = retain_cell(loc->rotate_last);
	
	if (!loc->ambiv)
		CHK(6, cleanup, L"[331] rot←reverse_last ╠ambiv╣ rotate_last");
	
	*stkhd++ = retain_cell(loc->ambiv);
	
	if (!loc->reverse_last)
		CHK(6, cleanup, L"[331] rot←╠reverse_last╣ ambiv rotate_last");
	
	*stkhd++ = retain_cell(loc->reverse_last);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[331] rot←╠reverse_last ambiv rotate_last╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rot);
	loc->rot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9004, ptr9005, ptr9006, ptr9007, 0), cleanup, 
		    L"[334] com←╠{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->com);
	loc->com = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9008, ptr9009, ptr9010, ptr9011, 4), cleanup, 
		    L"[337] map←╠{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}╣");
	
		k->fv[0] = retain_cell(loc->veach);
		k->fv[1] = retain_cell(loc->chk_scl);
		k->fv[2] = retain_cell(loc->max_shp);
		k->fv[3] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->map);
	loc->map = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9012, ptr9015, ptr9018, ptr9021, 0), cleanup, 
		    L"[340] reduce←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->reduce->value);
	loc->reduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9024, ptr9027, ptr9030, ptr9033, 1), cleanup, 
		    L"[345] nwreduce←╠{op←⍺⍺¨╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->nwreduce->value);
	loc->nwreduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9036, ptr9037, ptr9038, ptr9039, 2), cleanup, 
		    L"[349] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	
		k->fv[0] = retain_cell(loc->nwreduce);
		k->fv[1] = retain_cell(loc->reduce);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->rdf);
	loc->rdf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9040, ptr9041, 0), cleanup, 
		    L"[354] rpf←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->rpf);
	loc->rpf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9042, ptr9045, ptr9048, ptr9051, 1), cleanup, 
		    L"[357] scf←╠{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->scf);
	loc->scf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr9054, ptr9055, ptr9056, ptr9057, ptr9058, ptr9059, ptr9060, ptr9061, 0), cleanup, 
		    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->dot);
	loc->dot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr9062, ptr9063, ptr9064, ptr9065, 0), cleanup, 
		    L"[363] oup←╠{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->oup);
	loc->oup = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr9066, ptr9067, ptr9068, ptr9069, ptr9070, ptr9071, ptr9072, ptr9073, 0), cleanup, 
		    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->pow);
	loc->pow = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr9074, ptr9075, ptr9076, ptr9077, ptr9078, ptr9079, ptr9080, ptr9081, 0), cleanup, 
		    L"[369] jot←╠{╣");
	
		*stkhd++ = k;
	}
	
	release_cell(loc->jot);
	loc->jot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr8798(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[16] is_bool←{11≡⎕DR squeeze ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[16] is_bool←{11≡⎕DR ╠squeeze╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[16] is_bool←{11≡⎕DR ╠squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[16] is_bool←{11≡╠⎕DR╣ squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[16] is_bool←{11≡╠⎕DR squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[16] is_bool←{11╠≡╣⎕DR squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[16] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[16] is_bool←{╠11≡⎕DR squeeze ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[16] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	return err;
}

int
ptr8799(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[16] is_bool←{11≡⎕DR squeeze ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[16] is_bool←{11≡⎕DR ╠squeeze╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[16] is_bool←{11≡⎕DR ╠squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[16] is_bool←{11≡╠⎕DR╣ squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[16] is_bool←{11≡╠⎕DR squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[16] is_bool←{11╠≡╣⎕DR squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[16] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[16] is_bool←{╠11≡⎕DR squeeze ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[16] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	return err;
}

int
ptr8800(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] max_shp←{⍺←╠0╣ ⋄ ⍺('max_shp_ibeam'⌶)⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] max_shp←{⍺←╠0╣ ⋄ ⍺('max_shp_ibeam'⌶)⍵}");
	
		*stkhd++ = arr;
	}
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!max_shp_ibeam)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ⍺╠('max_shp_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(max_shp_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ╠⍺╣('max_shp_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] max_shp←{⍺←0 ⋄ ╠⍺('max_shp_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[18] max_shp←╠{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr8801(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!max_shp_ibeam)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ⍺╠('max_shp_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(max_shp_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] max_shp←{⍺←0 ⋄ ╠⍺╣('max_shp_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] max_shp←{⍺←0 ⋄ ╠⍺('max_shp_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[18] max_shp←╠{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr8802(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←╠0╣ ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←╠0╣ ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡╠⍴╣⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)╠≡╣⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴╠⍺╣)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (╠⍴╣⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ ╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ ╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,╣⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢╣,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1╠≡╣≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,╣⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢╣,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1╠≡╣≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴╣⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢╣⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)╠≡╣≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴╠⍺╣)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴╣⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (╠≢╣⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL╣ 5 ⋄ ⎕SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL╣ 4}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] chk_scl←╠{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	return err;
}

int
ptr8803(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡╠⍴╣⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)╠≡╣⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴╠⍺╣)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (╠⍴╣⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ ╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ ╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,╣⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢╣,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1╠≡╣≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,╣⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢╣,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1╠≡╣≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴╣⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢╣⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)╠≡╣≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴╠⍺╣)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴╣⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (╠≢╣⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL╣ 5 ⋄ ⎕SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL╣ 4}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] chk_scl←╠{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	return err;
}

int
ptr8804(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8805, ptr8806, 0), cleanup, 
		    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8807, ptr8808, 1), cleanup, 
		    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] chk_valid_shape←╠{╣");
	return err;
}

int
ptr8805(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[22] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[22] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rnk);
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr8806(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[22] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[22] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rnk);
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr8807(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[23] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr8808(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[23] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr8809(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8810, ptr8811, 0), cleanup, 
		    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8812, ptr8813, 1), cleanup, 
		    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[23] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] chk_valid_shape←╠{╣");
	return err;
}

int
ptr8810(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[22] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[22] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rnk);
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr8811(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[22] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[22] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[22] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rnk);
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[22] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr8812(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[23] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr8813(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[23] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[23] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[23] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[23] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[23] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr8814(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[26] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[26] both_simple←{╠is_simple╣ ⍺:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_simple->value)
				CHK(6, cleanup, L"[26] both_simple←{is_simple ⍺:╠is_simple╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8815(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[26] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[26] both_simple←{╠is_simple╣ ⍺:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_simple->value)
				CHK(6, cleanup, L"[26] both_simple←{is_simple ⍺:╠is_simple╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8816(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[27] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[27] both_numeric←{╠is_numeric╣ ⍺:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[27] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[27] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_numeric->value)
				CHK(6, cleanup, L"[27] both_numeric←{is_numeric ⍺:╠is_numeric╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[27] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[27] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8817(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[27] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[27] both_numeric←{╠is_numeric╣ ⍺:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[27] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[27] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_numeric->value)
				CHK(6, cleanup, L"[27] both_numeric←{is_numeric ⍺:╠is_numeric╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[27] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[27] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[27] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8818(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[28] both_integer←{is_integer ╠⍺╣:is_integer ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[28] both_integer←{╠is_integer╣ ⍺:is_integer ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] both_integer←{╠is_integer ⍺╣:is_integer ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] both_integer←{is_integer ╠⍺╣:is_integer ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_integer->value)
				CHK(6, cleanup, L"[28] both_integer←{is_integer ⍺:╠is_integer╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_integer->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[28] both_integer←{is_integer ⍺:╠is_integer ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] both_integer←╠{is_integer ⍺:is_integer ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8819(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[28] both_integer←{is_integer ╠⍺╣:is_integer ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[28] both_integer←{╠is_integer╣ ⍺:is_integer ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] both_integer←{╠is_integer ⍺╣:is_integer ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] both_integer←{is_integer ╠⍺╣:is_integer ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_integer->value)
				CHK(6, cleanup, L"[28] both_integer←{is_integer ⍺:╠is_integer╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_integer->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[28] both_integer←{is_integer ⍺:╠is_integer ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] both_integer←{is_integer ⍺:is_integer ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] both_integer←╠{is_integer ⍺:is_integer ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8820(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_char;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[29] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_char->value)
		CHK(6, cleanup, L"[29] both_char←{╠is_char╣ ⍺:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] both_char←{╠is_char ⍺╣:is_char ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] both_char←{is_char ⍺:is_char ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_char->value)
				CHK(6, cleanup, L"[29] both_char←{is_char ⍺:╠is_char╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] both_char←{is_char ⍺:╠is_char ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8821(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_char;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[29] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_char->value)
		CHK(6, cleanup, L"[29] both_char←{╠is_char╣ ⍺:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[29] both_char←{╠is_char ⍺╣:is_char ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] both_char←{is_char ⍺:is_char ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_char->value)
				CHK(6, cleanup, L"[29] both_char←{is_char ⍺:╠is_char╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[29] both_char←{is_char ⍺:╠is_char ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[29] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[29] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8822(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[30] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[30] both_bool←{╠is_bool╣ ⍺:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[30] both_bool←{╠is_bool ⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[30] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_bool->value)
				CHK(6, cleanup, L"[30] both_bool←{is_bool ⍺:╠is_bool╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[30] both_bool←{is_bool ⍺:╠is_bool ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[30] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8823(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[30] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[30] both_bool←{╠is_bool╣ ⍺:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[30] both_bool←{╠is_bool ⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[30] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_bool->value)
				CHK(6, cleanup, L"[30] both_bool←{is_bool ⍺:╠is_bool╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[30] both_bool←{is_bool ⍺:╠is_bool ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[30] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[30] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	return err;
}

int
ptr8824(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[32] numeric←{⍺←╠⊢╣ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣╣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (╠⍺╣⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] numeric←╠{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8825(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣╣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (╠⍺╣⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] numeric←╠{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8826(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[32] numeric←{⍺←╠⊢╣ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣╣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (╠⍺╣⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] numeric←╠{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8827(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣╠0╣)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺╠⊣╣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (╠⍺╣⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)╣both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ ╠(⍺⊣0)both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[32] numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] numeric←╠{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8828(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[33] ambiv←{⍺←╠⊢╣ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8829(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8830(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[33] ambiv←{⍺←╠⊢╣ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8831(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8832(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[33] ambiv←{⍺←╠⊢╣ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8833(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8834(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[33] ambiv←{⍺←╠⊢╣ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8835(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct lex_vars {
		struct cell_func_box *same;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺╣ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ╠⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!lex->same->value)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 ╠same╣ ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(lex->same->value);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[33] ambiv←{⍺←⊢ ⋄ ╠1╣ same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ ╠1 same ⍺ 1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ ╠1╣:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ╠⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺╣ ⍵ ⋄ ⍺ ⍵⍵ ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:╠⍺⍺ ⍵╣ ⋄ ⍺ ⍵⍵ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ╠⍵⍵╣ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺╣ ⍵⍵ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[33] ambiv←{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ╠⍺ ⍵⍵ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[33] ambiv←╠{⍺←⊢ ⋄ 1 same ⍺ 1:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵}╣");
	return err;
}

int
ptr8836(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[36] 	⍺ ╠chk_scl╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[36] 	╠⍺╣ chk_scl ⍵: ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	╠⍺ chk_scl ⍵╣: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[37] 	s←⍺ max_shp ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[37] 	s←⍺ ╠max_shp╣ ⍵");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[37] 	s←╠⍺╣ max_shp ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	s←╠⍺ max_shp ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[38] 	0≡≢╠,╣⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡≢╠,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[38] 	0≡╠≢╣,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡╠≢,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[38] 	0╠≡╣≢,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] 	╠0≡≢,⍺╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[38] 	0≡≢,⍺:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[39] 	0≡≢╠,╣⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡≢╠,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[39] 	0≡╠≢╣,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡╠≢,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[39] 	0╠≡╣≢,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[39] 	╠0≡≢,⍵╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[39] 	0≡≢,⍵:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[40] 	⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[40] 	╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[40] 	╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ veach ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ ╠veach╣ ⍵");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!self)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ╠∇╣ veach ⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[41] 	s⍴squeeze ⍺ ╠∇ veach╣ ⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ╠⍺╣ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	s⍴squeeze ╠⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[41] 	s⍴╠squeeze╣ ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[41] 	s⍴╠squeeze ⍺ ∇ veach ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[41] 	s╠⍴╣squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[41] 	╠s╣⍴squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	╠s⍴squeeze ⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] scalar←╠{╣");
	return err;
}

int
ptr8837(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[36] 	⍺ ╠chk_scl╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[36] 	╠⍺╣ chk_scl ⍵: ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	╠⍺ chk_scl ⍵╣: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[37] 	s←⍺ max_shp ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[37] 	s←⍺ ╠max_shp╣ ⍵");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[37] 	s←╠⍺╣ max_shp ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	s←╠⍺ max_shp ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[38] 	0≡≢╠,╣⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡≢╠,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[38] 	0≡╠≢╣,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡╠≢,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[38] 	0╠≡╣≢,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] 	╠0≡≢,⍺╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[38] 	0≡≢,⍺:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[39] 	0≡≢╠,╣⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡≢╠,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[39] 	0≡╠≢╣,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡╠≢,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[39] 	0╠≡╣≢,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[39] 	╠0≡≢,⍵╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[39] 	0≡≢,⍵:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[40] 	⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[40] 	╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[40] 	╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ veach ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ ╠veach╣ ⍵");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!self)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ╠∇╣ veach ⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[41] 	s⍴squeeze ⍺ ╠∇ veach╣ ⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ╠⍺╣ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	s⍴squeeze ╠⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[41] 	s⍴╠squeeze╣ ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[41] 	s⍴╠squeeze ⍺ ∇ veach ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[41] 	s╠⍴╣squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[41] 	╠s╣⍴squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	╠s⍴squeeze ⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] scalar←╠{╣");
	return err;
}

int
ptr8838(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[36] 	⍺ ╠chk_scl╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[36] 	╠⍺╣ chk_scl ⍵: ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	╠⍺ chk_scl ⍵╣: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[37] 	s←⍺ max_shp ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[37] 	s←⍺ ╠max_shp╣ ⍵");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[37] 	s←╠⍺╣ max_shp ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	s←╠⍺ max_shp ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[38] 	0≡≢╠,╣⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡≢╠,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[38] 	0≡╠≢╣,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡╠≢,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[38] 	0╠≡╣≢,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] 	╠0≡≢,⍺╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[38] 	0≡≢,⍺:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[39] 	0≡≢╠,╣⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡≢╠,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[39] 	0≡╠≢╣,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡╠≢,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[39] 	0╠≡╣≢,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[39] 	╠0≡≢,⍵╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[39] 	0≡≢,⍵:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[40] 	⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[40] 	╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[40] 	╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ veach ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ ╠veach╣ ⍵");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!self)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ╠∇╣ veach ⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[41] 	s⍴squeeze ⍺ ╠∇ veach╣ ⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ╠⍺╣ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	s⍴squeeze ╠⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[41] 	s⍴╠squeeze╣ ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[41] 	s⍴╠squeeze ⍺ ∇ veach ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[41] 	s╠⍴╣squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[41] 	╠s╣⍴squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	╠s⍴squeeze ⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] scalar←╠{╣");
	return err;
}

int
ptr8839(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[36] 	⍺ ╠chk_scl╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[36] 	╠⍺╣ chk_scl ⍵: ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[36] 	╠⍺ chk_scl ⍵╣: ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[36] 	⍺ chk_scl ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[37] 	s←⍺ max_shp ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[37] 	s←⍺ ╠max_shp╣ ⍵");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[37] 	s←╠⍺╣ max_shp ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[37] 	s←╠⍺ max_shp ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[38] 	0≡≢╠,╣⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡≢╠,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[38] 	0≡╠≢╣,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] 	0≡╠≢,⍺╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[38] 	0╠≡╣≢,⍺:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[38] 	╠0╣≡≢,⍺:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] 	╠0≡≢,⍺╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] 	0≡≢,╠⍺╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[38] 	0≡≢,⍺:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[38] 	0≡≢,⍺:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[38] 	0≡≢,⍺:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[39] 	0≡≢╠,╣⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡≢╠,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[39] 	0≡╠≢╣,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[39] 	0≡╠≢,⍵╣:s⍴0");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[39] 	0╠≡╣≢,⍵:s⍴0");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		CHK(fill_array(arr, dat), cleanup, L"[39] 	╠0╣≡≢,⍵:s⍴0");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[39] 	╠0≡≢,⍵╣:s⍴0");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[39] 	0≡≢,╠⍵╣:s⍴0");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[39] 	0≡≢,⍵:s⍴╠0╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:s╠⍴╣0");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[39] 	0≡≢,⍵:╠s╣⍴0");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[39] 	0≡≢,⍵:╠s⍴0╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[40] 	⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[40] 	╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[40] 	╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[40] 	⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[40] 	⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[40] 	⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ veach ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ∇ ╠veach╣ ⍵");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!self)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ⍺ ╠∇╣ veach ⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[41] 	s⍴squeeze ⍺ ╠∇ veach╣ ⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[41] 	s⍴squeeze ╠⍺╣ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	s⍴squeeze ╠⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[41] 	s⍴╠squeeze╣ ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[41] 	s⍴╠squeeze ⍺ ∇ veach ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[41] 	s╠⍴╣squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[41] 	╠s╣⍴squeeze ⍺ ∇ veach ⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[41] 	╠s⍴squeeze ⍺ ∇ veach ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] scalar←╠{╣");
	return err;
}

int
ptr8840(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *idx;
		struct cell_array *ic;
		struct cell_array *vc;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->idx = NULL;
	loc->ic = NULL;
	loc->vc = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[46] 	326≢⎕DR ╠⍺╣:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[46] 	326≢╠⎕DR╣ ⍺:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	326≢╠⎕DR ⍺╣:⎕SIGNAL 99");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	326╠≢╣⎕DR ⍺:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {326};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	╠326╣≢⎕DR ⍺:⎕SIGNAL 99");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	╠326╣≢⎕DR ⍺:⎕SIGNAL 99");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	╠326≢⎕DR ⍺╣:⎕SIGNAL 99");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	326≢⎕DR ╠⍺╣:⎕SIGNAL 99");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {99};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	326≢⎕DR ⍺:⎕SIGNAL ╠99╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	326≢⎕DR ⍺:⎕SIGNAL ╠99╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[46] 	326≢⎕DR ⍺:╠⎕SIGNAL╣ 99");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[46] 	326≢⎕DR ⍺:╠⎕SIGNAL 99╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[47] 	1≢≢,╠⍺╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[47] 	1≢≢╠,╣⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	1≢≢╠,⍺╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[47] 	1≢╠≢╣,⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	1≢╠≢,⍺╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[47] 	1╠≢╣≢,⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	╠1╣≢≢,⍺:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[47] 	╠1╣≢≢,⍺:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[47] 	╠1≢≢,⍺╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[47] 	1≢≢,╠⍺╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	1≢≢,⍺:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[47] 	1≢≢,⍺:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[47] 	1≢≢,⍺:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[47] 	1≢≢,⍺:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[48] 	idx←⊃╠⍺╣ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[48] 	idx←╠⊃╣⍺ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←╠⊃⍺╣ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->idx);
	loc->idx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,╠idx╣ ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢╠,╣idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢╠,idx╣ ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←╠≢╣,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←╠≢,idx╣ ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ic);
	loc->ic = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢,╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢╠,╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢╠,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←╠≢╣,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←╠≢,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->vc);
	loc->vc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧ic≢╠vc╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧ic╠≢╣vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->ic)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧╠ic╣≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->ic);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	(1≢vc)∧╠ic≢vc╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[49] 	(1≢vc)╠∧╣ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[49] 	(1≢╠vc╣)∧ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[49] 	(1╠≢╣vc)∧ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[49] 	(╠1╣≢vc)∧ic≢vc:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[49] 	(╠1╣≢vc)∧ic≢vc:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	╠(1≢vc)╣∧ic≢vc:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	╠(1≢vc)∧ic≢vc╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[49] 	(1≢vc)∧ic≢╠vc╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[49] 	(1≢vc)∧ic≢vc:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[49] 	(1≢vc)∧ic≢vc:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[49] 	(1≢vc)∧ic≢vc:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[49] 	(1≢vc)∧ic≢vc:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->idx)
		CHK(6, cleanup, L"[50] 	╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[45] idx_shp_check←╠{╣");
	return err;
}

int
ptr8841(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *idx;
		struct cell_array *ic;
		struct cell_array *vc;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->idx = NULL;
	loc->ic = NULL;
	loc->vc = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[46] 	326≢⎕DR ╠⍺╣:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[46] 	326≢╠⎕DR╣ ⍺:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	326≢╠⎕DR ⍺╣:⎕SIGNAL 99");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	326╠≢╣⎕DR ⍺:⎕SIGNAL 99");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {326};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	╠326╣≢⎕DR ⍺:⎕SIGNAL 99");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	╠326╣≢⎕DR ⍺:⎕SIGNAL 99");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	╠326≢⎕DR ⍺╣:⎕SIGNAL 99");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	326≢⎕DR ╠⍺╣:⎕SIGNAL 99");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {99};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	326≢⎕DR ⍺:⎕SIGNAL ╠99╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	326≢⎕DR ⍺:⎕SIGNAL ╠99╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[46] 	326≢⎕DR ⍺:╠⎕SIGNAL╣ 99");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[46] 	326≢⎕DR ⍺:╠⎕SIGNAL 99╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[47] 	1≢≢,╠⍺╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[47] 	1≢≢╠,╣⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	1≢≢╠,⍺╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[47] 	1≢╠≢╣,⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	1≢╠≢,⍺╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[47] 	1╠≢╣≢,⍺:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	╠1╣≢≢,⍺:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[47] 	╠1╣≢≢,⍺:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[47] 	╠1≢≢,⍺╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[47] 	1≢≢,╠⍺╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	1≢≢,⍺:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[47] 	1≢≢,⍺:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[47] 	1≢≢,⍺:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[47] 	1≢≢,⍺:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[48] 	idx←⊃╠⍺╣ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[48] 	idx←╠⊃╣⍺ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←╠⊃⍺╣ ⋄ ic←≢,idx ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->idx);
	loc->idx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,╠idx╣ ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢╠,╣idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢╠,idx╣ ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←╠≢╣,idx ⋄ vc←≢,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←╠≢,idx╣ ⋄ vc←≢,⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ic);
	loc->ic = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢,╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢╠,╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←≢╠,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←╠≢╣,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[48] 	idx←⊃⍺ ⋄ ic←≢,idx ⋄ vc←╠≢,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->vc);
	loc->vc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧ic≢╠vc╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧ic╠≢╣vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->ic)
		CHK(6, cleanup, L"[49] 	(1≢vc)∧╠ic╣≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->ic);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	(1≢vc)∧╠ic≢vc╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[49] 	(1≢vc)╠∧╣ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[49] 	(1≢╠vc╣)∧ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[49] 	(1╠≢╣vc)∧ic≢vc:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[49] 	(╠1╣≢vc)∧ic≢vc:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[49] 	(╠1╣≢vc)∧ic≢vc:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	╠(1≢vc)╣∧ic≢vc:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[49] 	╠(1≢vc)∧ic≢vc╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[49] 	(1≢vc)∧ic≢╠vc╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[49] 	(1≢vc)∧ic≢vc:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[49] 	(1≢vc)∧ic≢vc:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[49] 	(1≢vc)∧ic≢vc:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[49] 	(1≢vc)∧ic≢vc:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->idx)
		CHK(6, cleanup, L"[50] 	╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[45] idx_shp_check←╠{╣");
	return err;
}

int
ptr8842(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *any;
		struct cell_func_box *is_integer;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[53] 	0≡≢,╠⍺╣:⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[53] 	0≡≢╠,╣⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0≡≢╠,⍺╣:⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[53] 	0≡╠≢╣,⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0≡╠≢,⍺╣:⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[53] 	0╠≡╣≢,⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	╠0╣≡≢,⍺:⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	╠0╣≡≢,⍺:⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[53] 	╠0≡≢,⍺╣:⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	0≡≢,╠⍺╣:⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[53] 	0≡≢,⍺:╠⍺╣");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←╠squeeze╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡is_integer⊢idx←╠squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->idx);
	loc->idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[54] 	0≡is_integer╠⊢╣idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡is_integer╠⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[54] 	0≡╠is_integer╣⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡╠is_integer⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[54] 	0╠≡╣is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	╠0╣≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	╠0╣≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[54] 	╠0≡is_integer⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	0≡is_integer⊢idx←squeeze ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[54] 	0≡is_integer⊢idx←squeeze ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢,╠⍵╣:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢╠,╣⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨idx>≢╠,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>╠≢╣,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨idx>╠≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx╠>╣≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨╠idx╣>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨╠idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[55] 	any(idx<0)╠∨╣idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<╠0╣)∨idx>≢,⍵:⎕SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<╠0╣)∨idx>≢,⍵:⎕SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[55] 	any(idx╠<╣0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[55] 	any(╠idx╣<0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any╠(idx<0)╣∨idx>≢,⍵:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any╠(idx<0)∨idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->any->value)
		CHK(6, cleanup, L"[55] 	╠any╣(idx<0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	╠any(idx<0)∨idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[55] 	any(idx<0)∨idx>≢,╠⍵╣:⎕SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:⎕SIGNAL ╠3╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:⎕SIGNAL ╠3╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:╠⎕SIGNAL╣ 3");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[55] 	any(idx<0)∨idx>≢,⍵:╠⎕SIGNAL 3╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->idx)
		CHK(6, cleanup, L"[56] 	╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] idx_rng_check←╠{╣");
	return err;
}

int
ptr8843(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *idx;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *any;
		struct cell_func_box *is_integer;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->idx = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[53] 	0≡≢,╠⍺╣:⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[53] 	0≡≢╠,╣⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0≡≢╠,⍺╣:⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[53] 	0≡╠≢╣,⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[53] 	0≡╠≢,⍺╣:⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[53] 	0╠≡╣≢,⍺:⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	╠0╣≡≢,⍺:⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	╠0╣≡≢,⍺:⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[53] 	╠0≡≢,⍺╣:⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	0≡≢,╠⍺╣:⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[53] 	0≡≢,⍺:╠⍺╣");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←╠squeeze╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡is_integer⊢idx←╠squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->idx);
	loc->idx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[54] 	0≡is_integer╠⊢╣idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡is_integer╠⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[54] 	0≡╠is_integer╣⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[54] 	0≡╠is_integer⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[54] 	0╠≡╣is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	╠0╣≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	╠0╣≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[54] 	╠0≡is_integer⊢idx←squeeze ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	0≡is_integer⊢idx←squeeze ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[54] 	0≡is_integer⊢idx←squeeze ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[54] 	0≡is_integer⊢idx←squeeze ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢,╠⍵╣:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢╠,╣⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨idx>≢╠,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>╠≢╣,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨idx>╠≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨idx╠>╣≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[55] 	any(idx<0)∨╠idx╣>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any(idx<0)∨╠idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[55] 	any(idx<0)╠∨╣idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<╠0╣)∨idx>≢,⍵:⎕SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<╠0╣)∨idx>≢,⍵:⎕SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[55] 	any(idx╠<╣0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[55] 	any(╠idx╣<0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any╠(idx<0)╣∨idx>≢,⍵:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[55] 	any╠(idx<0)∨idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->any->value)
		CHK(6, cleanup, L"[55] 	╠any╣(idx<0)∨idx>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] 	╠any(idx<0)∨idx>≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[55] 	any(idx<0)∨idx>≢,╠⍵╣:⎕SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:⎕SIGNAL ╠3╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:⎕SIGNAL ╠3╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[55] 	any(idx<0)∨idx>≢,⍵:╠⎕SIGNAL╣ 3");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[55] 	any(idx<0)∨idx>≢,⍵:╠⎕SIGNAL 3╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->idx)
		CHK(6, cleanup, L"[56] 	╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] idx_rng_check←╠{╣");
	return err;
}

int
ptr8844(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢,╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢╠,╣⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢⍴⍺)≢≢╠,⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢╠≢╣,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢⍴⍺)≢╠≢,⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)╠≢╣≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[62] 	(≢⍴╠⍺╣)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[62] 	(≢╠⍴╣⍺)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢╠⍴⍺)╣≢≢,⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(╠≢╣⍴⍺)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	╠(≢⍴⍺)╣≢≢,⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[62] 	╠(≢⍴⍺)≢≢,⍵╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[62] 	(≢⍴⍺)≢≢,╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[62] 	(≢⍴⍺)≢≢,⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[63] 	⍵⌷╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[63] 	⍵╠⌷╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[63] 	╠⍵╣⌷⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] 	╠⍵⌷⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[61] brk←╠{╣");
	return err;
}

int
ptr8845(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢,╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢╠,╣⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢⍴⍺)≢≢╠,⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢╠≢╣,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢⍴⍺)≢╠≢,⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(≢⍴⍺)╠≢╣≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[62] 	(≢⍴╠⍺╣)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[62] 	(≢╠⍴╣⍺)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	(≢╠⍴⍺)╣≢≢,⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[62] 	(╠≢╣⍴⍺)≢≢,⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[62] 	╠(≢⍴⍺)╣≢≢,⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[62] 	╠(≢⍴⍺)≢≢,⍵╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[62] 	(≢⍴⍺)≢≢,╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[62] 	(≢⍴⍺)≢≢,⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[62] 	(≢⍴⍺)≢≢,⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[63] 	⍵⌷╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[63] 	⍵╠⌷╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[63] 	╠⍵╣⌷⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[63] 	╠⍵⌷⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[61] brk←╠{╣");
	return err;
}

int
ptr8846(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[67] rgt←{╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] rgt←╠{⍵}╣");
	return err;
}

int
ptr8847(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[67] rgt←{╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[67] rgt←╠{⍵}╣");
	return err;
}

int
ptr8848(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[70] lft←{╠⍵╣} ambiv {⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[70] lft←╠{⍵}╣ ambiv {⍺}");
	return err;
}

int
ptr8849(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[70] lft←{╠⍵╣} ambiv {⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[70] lft←╠{⍵}╣ ambiv {⍺}");
	return err;
}

int
ptr8850(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[70] lft←{⍵} ambiv {╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[70] lft←{⍵} ambiv ╠{⍺}╣");
	return err;
}

int
ptr8851(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[70] lft←{⍵} ambiv {╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[70] lft←{⍵} ambiv ╠{⍺}╣");
	return err;
}

int
ptr8852(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[73] reshape←{╠chk_valid_shape╣ ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[73] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[73] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!reshape_ibeam)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ⍺╠('reshape_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(reshape_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺╣('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[73] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[73] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr8853(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[73] reshape←{╠chk_valid_shape╣ ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[73] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[73] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!reshape_ibeam)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ⍺╠('reshape_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(reshape_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[73] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺╣('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[73] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[73] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr8854(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array_box *noax;
		struct cell_array *israv;
		struct cell_array_box *lr;
		struct cell_array_box *rr;
		struct cell_array_box *axis;
		struct cell_array *rk;
		struct cell_array *ar;
		struct cell_array_box *fx;
		struct cell_array *pr;
		struct cell_func *lx;
		struct cell_func *vc;
		struct cell_array_box *c;
		struct cell_array *a;
		struct cell_array *ax;
		struct cell_array *w;
		struct cell_array *wx;
		struct cell_array_box *s;
		struct cell_array *ac;
		struct cell_array *wc;
		struct cell_array_box *z;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	struct opt_vars {
		struct cell_array_box *axis;
	} *opts;

	opts = (struct opt_vars *)self->opts;

	CHK(mk_array_box(&loc->noax, NULL), cleanup, L"Init mutable variable: loc->noax");
	loc->israv = NULL;
	CHK(mk_array_box(&loc->lr, NULL), cleanup, L"Init mutable variable: loc->lr");
	CHK(mk_array_box(&loc->rr, NULL), cleanup, L"Init mutable variable: loc->rr");
	CHK(mk_array_box(&loc->axis, NULL), cleanup, L"Init mutable variable: loc->axis");
	loc->rk = NULL;
	loc->ar = NULL;
	CHK(mk_array_box(&loc->fx, NULL), cleanup, L"Init mutable variable: loc->fx");
	loc->pr = NULL;
	loc->lx = NULL;
	loc->vc = NULL;
	CHK(mk_array_box(&loc->c, NULL), cleanup, L"Init mutable variable: loc->c");
	loc->a = NULL;
	loc->ax = NULL;
	loc->w = NULL;
	loc->wx = NULL;
	CHK(mk_array_box(&loc->s, NULL), cleanup, L"Init mutable variable: loc->s");
	loc->ac = NULL;
	loc->wc = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] 	israv←noax←╠0╣ ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		CHK(fill_array(arr, dat), cleanup, L"[78] 	israv←noax←╠0╣ ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->noax->value);
	loc->noax->value = retain_cell(stkhd[-1]);
	
	release_cell(loc->israv);
	loc->israv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←╠1╣ ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		CHK(fill_array(arr, dat), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←╠1╣ ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->israv);
	loc->israv = retain_cell(stkhd[-1]);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴╠⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢╠⍴╣⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢╠⍴⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←╠≢╣⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←╠≢⍴⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lr->value);
	loc->lr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴╠⍵╣ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢╠⍴╣⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢╠⍴⍵╣ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←╠≢╣⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←╠≢⍴⍵╣ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rr->value);
	loc->rr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->axis) {
		*stkhd++ = retain_cell(opts->axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←╠1╣");
		
			CHK(fill_array(arr, dat), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←╠1╣");
		
			*stkhd++ = arr;
		}
		
		release_cell(loc->noax->value);
		loc->noax->value = retain_cell(stkhd[-1]);
		
	}
	
	release_cell(loc->axis->value);
	loc->axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->israv)
		CHK(6, cleanup, L"[79] 	╠israv╣:{");
	
	*stkhd++ = retain_cell(loc->israv);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	╠israv╣:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[84] 	}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8855, ptr8856, 2), cleanup, 
				    L"[79] 	israv:╠{╣");
			
				k->fv[0] = retain_cell(loc->axis);
				k->fv[1] = retain_cell(loc->noax);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[79] 	israv:╠{╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[85] 	rk←lr⌈╠rr╣ ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[85] 	rk←lr╠⌈╣rr ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[85] 	rk←╠lr╣⌈rr ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] 	rk←╠lr⌈rr╣ ⋄ axis⍠←¯1+rk");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rk);
	loc->rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->axis) {
		*stkhd++ = retain_cell(opts->axis);
	} else {
		if (!loc->rk)
			CHK(6, cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←¯1+╠rk╣");
		
		*stkhd++ = retain_cell(loc->rk);
		
		if (!cdf_prim.add)
			CHK(6, cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←¯1╠+╣rk");
		
		*stkhd++ = retain_cell(cdf_prim.add);
		
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {-1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1╣+rk");
		
			CHK(fill_array(arr, dat), cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1╣+rk");
		
			*stkhd++ = arr;
		}
		
		{
			struct cell_array *x = stkhd[-1];
			struct cell_func *fn = stkhd[-2];
			struct cell_array *y = stkhd[-3];
			struct cell_array *dst;
		
			CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
			    L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1+rk╣");
		
			release_array(x);
			release_func(fn);
			release_array(y);
		
			stkhd -= 3;
			*stkhd++ = dst;
		}
		
	}
	
	release_cell(loc->axis->value);
	loc->axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡╠rr╣):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[86] 	(0≡lr)∧(0╠≡╣rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[86] 	(0≡lr)∧(╠0╣≡rr):(,⍺),,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[86] 	(0≡lr)∧(╠0╣≡rr):(,⍺),,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	(0≡lr)∧╠(0≡rr)╣:(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[86] 	(0≡lr)╠∧╣(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[86] 	(0≡╠lr╣)∧(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[86] 	(0╠≡╣lr)∧(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[86] 	(╠0╣≡lr)∧(0≡rr):(,⍺),,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[86] 	(╠0╣≡lr)∧(0≡rr):(,⍺),,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	╠(0≡lr)╣∧(0≡rr):(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	╠(0≡lr)∧(0≡rr)╣:(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 	(0≡lr)∧(0≡╠rr╣):(,⍺),,⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺),,╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺),╠,╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):(,⍺),╠,⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺)╠,╣,⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			if (!alpha)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,╠⍺╣),,⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(╠,╣⍺),,⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):╠(,⍺)╣,,⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):╠(,⍺),,⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[87] 	ar←≢⍴╠axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[87] 	ar←≢╠⍴╣axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢╠⍴axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←╠≢╣⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←╠≢⍴axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ar);
	loc->ar = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[87] 	ar←≢⍴╠axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL ╠4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL ╠4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[87] 	ar←≢⍴axis:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 	ar←≢⍴axis:╠⎕SIGNAL 4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,╠axis╣:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢╠,╣axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢╠,axis╣:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢╠≢╣,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢╠≢,axis╣:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1╠≢╣≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1╣≢≢,axis:⎕SIGNAL 5 ");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1╣≢≢,axis:⎕SIGNAL 5 ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1≢≢,axis╣:⎕SIGNAL 5 ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,╠axis╣:⎕SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL ╠5╣ ");
			
				CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL ╠5╣ ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:╠⎕SIGNAL╣ 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:╠⎕SIGNAL 5╣ ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[88] 	~is_numeric ╠axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[88] 	~╠is_numeric╣ axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 	~╠is_numeric axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[88] 	╠~╣is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 	╠~is_numeric axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 	~is_numeric ╠axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL ╠11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL ╠11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[88] 	~is_numeric axis:╠⎕SIGNAL╣ 11 ⋄ axis≤¯1:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[88] 	~is_numeric axis:╠⎕SIGNAL 11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lte)
		CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis╠≤╣¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lte);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ ╠axis╣≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ ╠axis≤¯1╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rk)
		CHK(6, cleanup, L"[89] 	axis≥╠rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rk);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[89] 	axis╠≥╣rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[89] 	╠axis╣≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	╠axis≥rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[89] 	axis≥╠rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL ╠4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL ╠4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[89] 	axis≥rk:╠⎕SIGNAL╣ 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[89] 	axis≥rk:╠⎕SIGNAL 4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr╠-╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|╠lr╣-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|╠lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<╠|╣lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<╠|lr-rr╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1╠<╣|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1╣<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1╣<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)╠∧╣1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢╠0╣)∧1<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢╠0╣)∧1<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr╠≢╣0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(╠rr╣≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧╠(rr≢0)╣∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧╠(rr≢0)∧1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)╠∧╣(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢╠0╣)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢╠0╣)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr╠≢╣0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (╠lr╣≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ ╠(lr≢0)╣∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ ╠(lr≢0)∧(rr≢0)∧1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-╠rr╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[90] 	axis≠fx←⌈╠axis╣:⍺{");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[90] 	axis≠fx←╠⌈╣axis:⍺{");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	axis≠fx←╠⌈axis╣:⍺{");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->fx->value);
	loc->fx->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[90] 	axis╠≠╣fx←⌈axis:⍺{");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[90] 	╠axis╣≠fx←⌈axis:⍺{");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[90] 	╠axis≠fx←⌈axis╣:⍺{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[90] 	axis≠fx←⌈╠axis╣:⍺{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[93] 	}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8857, ptr8858, 4), cleanup, 
				    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
			
				k->fv[0] = retain_cell(loc->fx);
				k->fv[1] = retain_cell(loc->axis);
				k->fv[2] = retain_cell(loc->rr);
				k->fv[3] = retain_cell(loc->lr);
			
				*stkhd++ = k;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[90] 	axis≠fx←⌈axis:╠⍺╣{");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[90] 	axis≠fx←⌈axis:╠⍺{╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴╠⍵╣:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑╠⍴╣⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑╠⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)╠↑╣⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=╠rr╣)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr╠=╣rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-╠lr╣=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-╠lr=rr╣)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)╠-╣lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊╠rr╣)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr╠⌊╣rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(╠lr╣⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←╠(lr⌊rr)╣-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←╠(lr⌊rr)-lr=rr╣)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠╠(pr←(lr⌊rr)-lr=rr)↑⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.╠≠╣(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!cdf_prim.dot)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨╠.╣≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.dot);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)╠∨╣.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[94] 	(pr↑⍴⍺)╠∨.≠╣(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[94] 	(pr↑⍴╠⍺╣)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[94] 	(pr↑╠⍴╣⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[94] 	(pr↑╠⍴⍺)╣∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[94] 	(pr╠↑╣⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[94] 	(╠pr╣↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	╠(pr↑⍴⍺)╣∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	╠(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴╠⍵╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8859, ptr8860, 1), cleanup, 
		    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		k->fv[0] = retain_cell(loc->fx);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->lx);
	loc->lx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8861, ptr8862, 1), cleanup, 
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	
		k->fv[0] = retain_cell(loc->c);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->vc);
	loc->vc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[96] 	fx←(lr⌈rr)-╠1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[96] 	fx←(lr⌈rr)-╠1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)╠-╣1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈╠rr╣)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[96] 	fx←(lr╠⌈╣rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[96] 	fx←(╠lr╣⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←╠(lr⌈rr)╣-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←╠(lr⌈rr)-1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->fx->value);
	loc->fx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,╠⍺╣ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←╠,╣⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←╠,⍺╣ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->a);
	loc->a = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ╠⍺╣ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!loc->lx)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr ╠lx╣ ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lx);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←╠lr╣ lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←╠lr lx ⍺╣ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ax);
	loc->ax = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,╠⍵╣ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←╠,╣⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←╠,⍵╣ ⋄ wx←rr lx ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->w);
	loc->w = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!loc->lx)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr ╠lx╣ ⍵");
	
	*stkhd++ = retain_cell(loc->lx);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←╠rr╣ lx ⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←╠rr lx ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->wx);
	loc->wx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}╠⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8863, ptr8864, 2), cleanup, 
		    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		k->fv[0] = retain_cell(loc->rr);
		k->fv[1] = retain_cell(loc->lr);
	
		*stkhd++ = k;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[97] 	s←⍴╠⍺╣{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴╠⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[97] 	s←╠⍴╣⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] 	s←╠⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s->value);
	loc->s->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+╠wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->wx);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax╠+╣wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←╠ax╣+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->ax);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←╠ax+wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]╠←╣ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[╠fx╣]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s╠[fx]╣←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s╠[fx]╣←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->s;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ ╠s[fx]←ax+wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑╠s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx╠↑╣s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿╠fx╣↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿╠fx↑s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×╠⌿╣fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×╣⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×⌿╣fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×⌿fx↑s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c->value);
	loc->c->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->a)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc ╠a╣ ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->a);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr ╠vc╣ a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←╠lr╣ vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←╠lr vc a╣ ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ac);
	loc->ac = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->w)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc ╠w╣ ");
	
	*stkhd++ = retain_cell(loc->w);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr ╠vc╣ w ");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←╠rr╣ vc w ");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←╠rr vc w╣ ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->wc);
	loc->wc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[98] 	z←(c×fx⌷s)⍴╠0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		CHK(fill_array(arr, dat), cleanup, L"[98] 	z←(c×fx⌷s)⍴╠0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)╠⍴╣0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷╠s╣)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[98] 	z←(c×fx╠⌷╣s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[98] 	z←(c×╠fx╣⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×╠fx⌷s)╣⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c╠×╣fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->c->value)
		CHK(6, cleanup, L"[98] 	z←(╠c╣×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->c->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←╠(c×fx⌷s)╣⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←╠(c×fx⌷s)⍴0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->a)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←╠a╣ ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->a);
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]╠←╣a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷╠ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ax);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)╠÷╣ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->ac)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳╠ac╣)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ac);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←╠⍳╣ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←╠⍳ac╣)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊╠(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×╠⌊╣(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×╠⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx╠×╣⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+╠wx╣×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->wx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+╠wx×⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i╠+╣wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->i)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[╠i╣+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[╠i+wx×⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z╠[i+wx×⌊(i←⍳ac)÷ax]╣←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z╠[i+wx×⌊(i←⍳ac)÷ax]╣←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ ╠z[i+wx×⌊(i←⍳ac)÷ax]←a╣ ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->w)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←╠w╣");
	
	*stkhd++ = retain_cell(loc->w);
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]╠←╣w");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷╠wx╣]←w");
	
	*stkhd++ = retain_cell(loc->wx);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)╠÷╣wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->wc)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳╠wc╣)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->wc);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←╠⍳╣wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←╠⍳wc╣)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊╠(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+╠⌊╣(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+╠⌊(i←⍳wc)÷wx╣]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1╠+╣⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1╣+⌊(i←⍳wc)÷wx]←w");
	
		CHK(fill_array(arr, dat), cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1╣+⌊(i←⍳wc)÷wx]←w");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax╠×╣1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+╠ax╣×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ax);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+╠ax×1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i╠+╣ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->i)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[╠i╣+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[╠i+ax×1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z╠[i+ax×1+⌊(i←⍳wc)÷wx]╣←w");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z╠[i+ax×1+⌊(i←⍳wc)÷wx]╣←w");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ ╠z[i+ax×1+⌊(i←⍳wc)÷wx]←w╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[99] 	s⍴╠z╣	");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[99] 	s╠⍴╣z	");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[99] 	╠s╣⍴z	");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[99] 	╠s⍴z╣	");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[77] cat←╠{╣");
	return err;
}

int
ptr8855(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *s;
		struct cell_array *pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *axis;
		struct cell_array_box *noax;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->s = NULL;
	loc->pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->noax->value)
		CHK(6, cleanup, L"[80] 		╠noax╣:'ravel_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(lex->noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	israv:╠{╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[80] 		noax:'ravel_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!ravel_ibeam)
				CHK(6, cleanup, L"[80] 		noax:╠'ravel_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[81] 		1≢≢,╠axis╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[81] 		1≢≢╠,╣axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢≢╠,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1≢╠≢╣,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢╠≢,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1╠≢╣≢,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[81] 		╠1≢≢,axis╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[81] 		1≢≢,axis:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		axis=⌈╠axis╣:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[82] 		axis=╠⌈╣axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] 		axis=╠⌈axis╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[82] 		axis╠=╣⌈axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		╠axis╣=⌈axis:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[82] 		╠axis=⌈axis╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[82] 		axis=⌈axis:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴╠⍵╣)⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴╣⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴⍵╣)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)╠↓╣s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈╠axis╣)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←╠⌈╣axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←╠⌈axis╣)↓s←⍴⍵)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,╠(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s),1╠,╣(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),╠1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s)╠,╣1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->s)
		CHK(6, cleanup, L"[83] 		((pr↑╠s╣),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[83] 		((pr╠↑╣s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[83] 		((╠pr╣↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		(╠(pr↑s)╣,1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[79] 	israv:╠{╣");
	return err;
}

int
ptr8856(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *s;
		struct cell_array *pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *axis;
		struct cell_array_box *noax;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->s = NULL;
	loc->pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->noax->value)
		CHK(6, cleanup, L"[80] 		╠noax╣:'ravel_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(lex->noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[80] 		noax:'ravel_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!ravel_ibeam)
				CHK(6, cleanup, L"[80] 		noax:╠'ravel_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[81] 		1≢≢,╠axis╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[81] 		1≢≢╠,╣axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢≢╠,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1≢╠≢╣,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢╠≢,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1╠≢╣≢,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[81] 		╠1≢≢,axis╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[81] 		1≢≢,axis:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		axis=⌈╠axis╣:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[82] 		axis=╠⌈╣axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] 		axis=╠⌈axis╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[82] 		axis╠=╣⌈axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		╠axis╣=⌈axis:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[82] 		╠axis=⌈axis╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[82] 		axis=⌈axis:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴╠⍵╣)⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴╣⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴⍵╣)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)╠↓╣s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈╠axis╣)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←╠⌈╣axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←╠⌈axis╣)↓s←⍴⍵)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,╠(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s),1╠,╣(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),╠1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s)╠,╣1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->s)
		CHK(6, cleanup, L"[83] 		((pr↑╠s╣),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[83] 		((pr╠↑╣s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[83] 		((╠pr╣↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		(╠(pr↑s)╣,1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[79] 	israv:╠{╣");
	return err;
}

int
ptr8857(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fx;
		struct cell_array_box *axis;
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr╠≠╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧╠lr╣≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧(rr≢0)∧╠lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)╠∧╣lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr╠≢╣0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(╠rr╣≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)╣∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)╠∧╣(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr╠≢╣0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(╠lr╣≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)╣∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)∧(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[90] 	axis≠fx←⌈axis:╠⍺{╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr╠≢╣0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(╠rr╣≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣╠(rr≢0)╣⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]╠⍣╣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[╠axis╣]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,╣[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis╣]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)╣⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[╠fx╣],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,╣[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,[fx╣],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢╠⍺╣),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)╠⊢╣⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)╠⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr╠≢╣0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(╠lr╣≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣╠(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]╠⍣╣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[╠axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(╠,╣[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(╠,[axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(╠,[axis]⍣(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
	return err;
}

int
ptr8858(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fx;
		struct cell_array_box *axis;
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr╠≠╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧╠lr╣≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧(rr≢0)∧╠lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)╠∧╣lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr╠≢╣0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(╠rr╣≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)╣∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)╠∧╣(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr╠≢╣0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(╠lr╣≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)╣∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)∧(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr╠≢╣0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(╠rr╣≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣╠(rr≢0)╣⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]╠⍣╣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[╠axis╣]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,╣[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis╣]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)╣⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[╠fx╣],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,╣[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,[fx╣],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢╠⍺╣),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)╠⊢╣⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)╠⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr╠≢╣0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(╠lr╣≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣╠(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]╠⍣╣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[╠axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(╠,╣[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(╠,[axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(╠,[axis]⍣(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
	return err;
}

int
ptr8859(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fx;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[95] 	lx←{fx╠≥╣⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{╠fx╣≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{╠fx≥⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴╠⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴╣⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx╠⌷╣⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx╣⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx⌷⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	return err;
}

int
ptr8860(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fx;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[95] 	lx←{fx╠≥╣⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{╠fx╣≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{╠fx≥⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴╠⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴╣⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx╠⌷╣⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx╣⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx⌷⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	return err;
}

int
ptr8861(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *c;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺╠≡╣0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺╣≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺≡0╣:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!lex->c->value)
				CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:╠c╣ ⋄ ≢⍵}");
			
			*stkhd++ = retain_cell(lex->c->value);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	return err;
}

int
ptr8862(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *c;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺╠≡╣0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺╣≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺≡0╣:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!lex->c->value)
				CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:╠c╣ ⋄ ≢⍵}");
			
			*stkhd++ = retain_cell(lex->c->value);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	return err;
}

int
ptr8863(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>╠rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr╠>╣rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{╠lr╣>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{╠lr>rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[97] 	╠s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:╠⍺╣ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	return err;
}

int
ptr8864(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>╠rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr╠>╣rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{╠lr╣>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{╠lr>rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:╠⍺╣ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	return err;
}

int
ptr8865(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array_box *noax;
		struct cell_array *israv;
		struct cell_array_box *lr;
		struct cell_array_box *rr;
		struct cell_array_box *axis;
		struct cell_array *rk;
		struct cell_array *ar;
		struct cell_array_box *fx;
		struct cell_array *pr;
		struct cell_func *lx;
		struct cell_func *vc;
		struct cell_array_box *c;
		struct cell_array *a;
		struct cell_array *ax;
		struct cell_array *w;
		struct cell_array *wx;
		struct cell_array_box *s;
		struct cell_array *ac;
		struct cell_array *wc;
		struct cell_array_box *z;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	struct opt_vars {
		struct cell_array_box *axis;
	} *opts;

	opts = (struct opt_vars *)self->opts;

	CHK(mk_array_box(&loc->noax, NULL), cleanup, L"Init mutable variable: loc->noax");
	loc->israv = NULL;
	CHK(mk_array_box(&loc->lr, NULL), cleanup, L"Init mutable variable: loc->lr");
	CHK(mk_array_box(&loc->rr, NULL), cleanup, L"Init mutable variable: loc->rr");
	CHK(mk_array_box(&loc->axis, NULL), cleanup, L"Init mutable variable: loc->axis");
	loc->rk = NULL;
	loc->ar = NULL;
	CHK(mk_array_box(&loc->fx, NULL), cleanup, L"Init mutable variable: loc->fx");
	loc->pr = NULL;
	loc->lx = NULL;
	loc->vc = NULL;
	CHK(mk_array_box(&loc->c, NULL), cleanup, L"Init mutable variable: loc->c");
	loc->a = NULL;
	loc->ax = NULL;
	loc->w = NULL;
	loc->wx = NULL;
	CHK(mk_array_box(&loc->s, NULL), cleanup, L"Init mutable variable: loc->s");
	loc->ac = NULL;
	loc->wc = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] 	israv←noax←╠0╣ ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		CHK(fill_array(arr, dat), cleanup, L"[78] 	israv←noax←╠0╣ ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->noax->value);
	loc->noax->value = retain_cell(stkhd[-1]);
	
	release_cell(loc->israv);
	loc->israv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴╠⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢╠⍴╣⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢╠⍴⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←╠≢╣⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←╠≢⍴⍺╣ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->lr->value);
	loc->lr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴╠⍵╣ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢╠⍴╣⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢╠⍴⍵╣ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←╠≢╣⍴⍵ ⋄ axis⍠←noax←1");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←╠≢⍴⍵╣ ⋄ axis⍠←noax←1");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rr->value);
	loc->rr->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->axis) {
		*stkhd++ = retain_cell(opts->axis);
	} else {
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←╠1╣");
		
			CHK(fill_array(arr, dat), cleanup, L"[78] 	israv←noax←0 ⋄ ⍺←israv←1 ⋄ lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←╠1╣");
		
			*stkhd++ = arr;
		}
		
		release_cell(loc->noax->value);
		loc->noax->value = retain_cell(stkhd[-1]);
		
	}
	
	release_cell(loc->axis->value);
	loc->axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->israv)
		CHK(6, cleanup, L"[79] 	╠israv╣:{");
	
	*stkhd++ = retain_cell(loc->israv);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	╠israv╣:{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[84] 	}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8866, ptr8867, 2), cleanup, 
				    L"[79] 	israv:╠{╣");
			
				k->fv[0] = retain_cell(loc->axis);
				k->fv[1] = retain_cell(loc->noax);
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[79] 	israv:╠{╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[85] 	rk←lr⌈╠rr╣ ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[85] 	rk←lr╠⌈╣rr ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[85] 	rk←╠lr╣⌈rr ⋄ axis⍠←¯1+rk");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] 	rk←╠lr⌈rr╣ ⋄ axis⍠←¯1+rk");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rk);
	loc->rk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (opts && opts->axis) {
		*stkhd++ = retain_cell(opts->axis);
	} else {
		if (!loc->rk)
			CHK(6, cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←¯1+╠rk╣");
		
		*stkhd++ = retain_cell(loc->rk);
		
		if (!cdf_prim.add)
			CHK(6, cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←¯1╠+╣rk");
		
		*stkhd++ = retain_cell(cdf_prim.add);
		
		{
			struct cell_array *arr;
		
			enum array_type typ = ARR_SINT;
			unsigned int rnk = 0;
			int16_t dat[] = {-1};
		
			CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1╣+rk");
		
			CHK(fill_array(arr, dat), cleanup, L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1╣+rk");
		
			*stkhd++ = arr;
		}
		
		{
			struct cell_array *x = stkhd[-1];
			struct cell_func *fn = stkhd[-2];
			struct cell_array *y = stkhd[-3];
			struct cell_array *dst;
		
			CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
			    L"[85] 	rk←lr⌈rr ⋄ axis⍠←╠¯1+rk╣");
		
			release_array(x);
			release_func(fn);
			release_array(y);
		
			stkhd -= 3;
			*stkhd++ = dst;
		}
		
	}
	
	release_cell(loc->axis->value);
	loc->axis->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡╠rr╣):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[86] 	(0≡lr)∧(0╠≡╣rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[86] 	(0≡lr)∧(╠0╣≡rr):(,⍺),,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[86] 	(0≡lr)∧(╠0╣≡rr):(,⍺),,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	(0≡lr)∧╠(0≡rr)╣:(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[86] 	(0≡lr)╠∧╣(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[86] 	(0≡╠lr╣)∧(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[86] 	(0╠≡╣lr)∧(0≡rr):(,⍺),,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[86] 	(╠0╣≡lr)∧(0≡rr):(,⍺),,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[86] 	(╠0╣≡lr)∧(0≡rr):(,⍺),,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	╠(0≡lr)╣∧(0≡rr):(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[86] 	╠(0≡lr)∧(0≡rr)╣:(,⍺),,⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[86] 	(0≡lr)∧(0≡╠rr╣):(,⍺),,⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺),,╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺),╠,╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):(,⍺),╠,⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,⍺)╠,╣,⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			if (!alpha)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(,╠⍺╣),,⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[86] 	(0≡lr)∧(0≡rr):(╠,╣⍺),,⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):╠(,⍺)╣,,⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[86] 	(0≡lr)∧(0≡rr):╠(,⍺),,⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[87] 	ar←≢⍴╠axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[87] 	ar←≢╠⍴╣axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢╠⍴axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←╠≢╣⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←╠≢⍴axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ar);
	loc->ar = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[87] 	ar←≢⍴╠axis╣:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL ╠4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL ╠4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[87] 	ar←≢⍴axis:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 	ar←≢⍴axis:╠⎕SIGNAL 4╣ ⋄ 1≢≢,axis:⎕SIGNAL 5 ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,╠axis╣:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢╠,╣axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢╠,axis╣:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢╠≢╣,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢╠≢,axis╣:⎕SIGNAL 5 ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1╠≢╣≢,axis:⎕SIGNAL 5 ");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1╣≢≢,axis:⎕SIGNAL 5 ");
	
		CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1╣≢≢,axis:⎕SIGNAL 5 ");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ ╠1≢≢,axis╣:⎕SIGNAL 5 ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,╠axis╣:⎕SIGNAL 5 ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL ╠5╣ ");
			
				CHK(fill_array(arr, dat), cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL ╠5╣ ");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:╠⎕SIGNAL╣ 5 ");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[87] 	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:╠⎕SIGNAL 5╣ ");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[88] 	~is_numeric ╠axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[88] 	~╠is_numeric╣ axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 	~╠is_numeric axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[88] 	╠~╣is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[88] 	╠~is_numeric axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 	~is_numeric ╠axis╣:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL ╠11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL ╠11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[88] 	~is_numeric axis:╠⎕SIGNAL╣ 11 ⋄ axis≤¯1:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[88] 	~is_numeric axis:╠⎕SIGNAL 11╣ ⋄ axis≤¯1:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lte)
		CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis╠≤╣¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lte);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ ╠axis╣≤¯1:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ ╠axis≤¯1╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤╠¯1╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[88] 	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rk)
		CHK(6, cleanup, L"[89] 	axis≥╠rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rk);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[89] 	axis╠≥╣rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[89] 	╠axis╣≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	╠axis≥rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[89] 	axis≥╠rk╣:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL ╠4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL ╠4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[89] 	axis≥rk:╠⎕SIGNAL╣ 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[89] 	axis≥rk:╠⎕SIGNAL 4╣ ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr╠-╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|╠lr╣-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|╠lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<╠|╣lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<╠|lr-rr╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1╠<╣|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1╣<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1╣<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧╠1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)╠∧╣1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢╠0╣)∧1<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢╠0╣)∧1<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr╠≢╣0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(╠rr╣≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧╠(rr≢0)╣∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧╠(rr≢0)∧1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)╠∧╣(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢╠0╣)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢╠0╣)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr╠≢╣0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (╠lr╣≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ ╠(lr≢0)╣∧(rr≢0)∧1<|lr-rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ ╠(lr≢0)∧(rr≢0)∧1<|lr-rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-╠rr╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[89] 	axis≥rk:⎕SIGNAL 4 ⋄ (lr≢0)∧(rr≢0)∧1<|lr-rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[90] 	axis≠fx←⌈╠axis╣:⍺{");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[90] 	axis≠fx←╠⌈╣axis:⍺{");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[90] 	axis≠fx←╠⌈axis╣:⍺{");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->fx->value);
	loc->fx->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[90] 	axis╠≠╣fx←⌈axis:⍺{");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!loc->axis->value)
		CHK(6, cleanup, L"[90] 	╠axis╣≠fx←⌈axis:⍺{");
	
	*stkhd++ = retain_cell(loc->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[90] 	╠axis≠fx←⌈axis╣:⍺{");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[90] 	axis≠fx←⌈╠axis╣:⍺{");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[93] 	}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8868, ptr8869, 4), cleanup, 
				    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
			
				k->fv[0] = retain_cell(loc->fx);
				k->fv[1] = retain_cell(loc->axis);
				k->fv[2] = retain_cell(loc->rr);
				k->fv[3] = retain_cell(loc->lr);
			
				*stkhd++ = k;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[90] 	axis≠fx←⌈axis:╠⍺╣{");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[90] 	axis≠fx←⌈axis:╠⍺{╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴╠⍵╣:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑╠⍴╣⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑╠⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)╠↑╣⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=╠rr╣)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr╠=╣rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-╠lr╣=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-╠lr=rr╣)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)╠-╣lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊╠rr╣)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr╠⌊╣rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(╠lr╣⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←╠(lr⌊rr)╣-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠(pr←╠(lr⌊rr)-lr=rr╣)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	(pr↑⍴⍺)∨.≠╠(pr←(lr⌊rr)-lr=rr)↑⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.╠≠╣(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!cdf_prim.dot)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨╠.╣≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.dot);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)╠∨╣.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[94] 	(pr↑⍴⍺)╠∨.≠╣(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[94] 	(pr↑⍴╠⍺╣)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[94] 	(pr↑╠⍴╣⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[94] 	(pr↑╠⍴⍺)╣∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[94] 	(pr╠↑╣⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[94] 	(╠pr╣↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	╠(pr↑⍴⍺)╣∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[94] 	╠(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴╠⍵╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[94] 	(pr↑⍴⍺)∨.≠(pr←(lr⌊rr)-lr=rr)↑⍴⍵:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8870, ptr8871, 1), cleanup, 
		    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		k->fv[0] = retain_cell(loc->fx);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->lx);
	loc->lx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8872, ptr8873, 1), cleanup, 
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	
		k->fv[0] = retain_cell(loc->c);
	
		*stkhd++ = k;
	}
	
	release_cell(loc->vc);
	loc->vc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[96] 	fx←(lr⌈rr)-╠1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[96] 	fx←(lr⌈rr)-╠1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)╠-╣1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈╠rr╣)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[96] 	fx←(lr╠⌈╣rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[96] 	fx←(╠lr╣⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←╠(lr⌈rr)╣-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←╠(lr⌈rr)-1╣ ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->fx->value);
	loc->fx->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,╠⍺╣ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←╠,╣⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←╠,⍺╣ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->a);
	loc->a = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ╠⍺╣ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!loc->lx)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr ╠lx╣ ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lx);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←╠lr╣ lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←╠lr lx ⍺╣ ⋄ w←,⍵ ⋄ wx←rr lx ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ax);
	loc->ax = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,╠⍵╣ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←╠,╣⍵ ⋄ wx←rr lx ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←╠,⍵╣ ⋄ wx←rr lx ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->w);
	loc->w = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr lx ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!loc->lx)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←rr ╠lx╣ ⍵");
	
	*stkhd++ = retain_cell(loc->lx);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←╠rr╣ lx ⍵");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[96] 	fx←(lr⌈rr)-1 ⋄ a←,⍺ ⋄ ax←lr lx ⍺ ⋄ w←,⍵ ⋄ wx←╠rr lx ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->wx);
	loc->wx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}╠⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8874, ptr8875, 2), cleanup, 
		    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		k->fv[0] = retain_cell(loc->rr);
		k->fv[1] = retain_cell(loc->lr);
	
		*stkhd++ = k;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[97] 	s←⍴╠⍺╣{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴╠⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[97] 	s←╠⍴╣⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] 	s←╠⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s->value);
	loc->s->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+╠wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->wx);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax╠+╣wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←╠ax╣+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->ax);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←╠ax+wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]╠←╣ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[╠fx╣]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s╠[fx]╣←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s╠[fx]╣←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->s;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ ╠s[fx]←ax+wx╣ ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑╠s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx╠↑╣s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿╠fx╣↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿╠fx↑s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×╠⌿╣fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×╣⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×⌿╣fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←╠×⌿fx↑s╣ ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c->value);
	loc->c->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->a)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc ╠a╣ ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->a);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr ╠vc╣ a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!loc->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←╠lr╣ vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(loc->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←╠lr vc a╣ ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ac);
	loc->ac = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->w)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc ╠w╣ ");
	
	*stkhd++ = retain_cell(loc->w);
	
	if (!loc->vc)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr ╠vc╣ w ");
	
	*stkhd++ = retain_cell(loc->vc);
	
	if (!loc->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←╠rr╣ vc w ");
	
	*stkhd++ = retain_cell(loc->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←╠rr vc w╣ ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->wc);
	loc->wc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[98] 	z←(c×fx⌷s)⍴╠0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		CHK(fill_array(arr, dat), cleanup, L"[98] 	z←(c×fx⌷s)⍴╠0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)╠⍴╣0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷╠s╣)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[98] 	z←(c×fx╠⌷╣s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!loc->fx->value)
		CHK(6, cleanup, L"[98] 	z←(c×╠fx╣⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×╠fx⌷s)╣⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c╠×╣fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->c->value)
		CHK(6, cleanup, L"[98] 	z←(╠c╣×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->c->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←╠(c×fx⌷s)╣⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←╠(c×fx⌷s)⍴0╣ ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->a)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←╠a╣ ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->a);
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]╠←╣a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷╠ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ax);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)╠÷╣ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->ac)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳╠ac╣)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ac);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←╠⍳╣ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←╠⍳ac╣)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊╠(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×╠⌊╣(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×╠⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx╠×╣⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+╠wx╣×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->wx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+╠wx×⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i╠+╣wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->i)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[╠i╣+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[╠i+wx×⌊(i←⍳ac)÷ax╣]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z╠[i+wx×⌊(i←⍳ac)÷ax]╣←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z╠[i+wx×⌊(i←⍳ac)÷ax]╣←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ ╠z[i+wx×⌊(i←⍳ac)÷ax]←a╣ ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←w");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->w)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]←╠w╣");
	
	*stkhd++ = retain_cell(loc->w);
	
	if (!cdf_prim.set)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷wx]╠←╣w");
	
	*stkhd++ = retain_cell(cdf_prim.set);
	
	if (!loc->wx)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)÷╠wx╣]←w");
	
	*stkhd++ = retain_cell(loc->wx);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳wc)╠÷╣wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->wc)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←⍳╠wc╣)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->wc);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←╠⍳╣wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊(i←╠⍳wc╣)÷wx]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+⌊╠(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+╠⌊╣(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1+╠⌊(i←⍳wc)÷wx╣]←w");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×1╠+╣⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1╣+⌊(i←⍳wc)÷wx]←w");
	
		CHK(fill_array(arr, dat), cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1╣+⌊(i←⍳wc)÷wx]←w");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax×╠1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+ax╠×╣1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->ax)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+╠ax╣×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->ax);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i+╠ax×1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[i╠+╣ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->i)
		CHK(6, cleanup, L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[╠i╣+ax×1+⌊(i←⍳wc)÷wx]←w");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z[╠i+ax×1+⌊(i←⍳wc)÷wx╣]←w");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z╠[i+ax×1+⌊(i←⍳wc)÷wx]╣←w");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ z╠[i+ax×1+⌊(i←⍳wc)÷wx]╣←w");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array_box *bx = loc->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[98] 	z←(c×fx⌷s)⍴0 ⋄ z[i+wx×⌊(i←⍳ac)÷ax]←a ⋄ ╠z[i+ax×1+⌊(i←⍳wc)÷wx]←w╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[99] 	s⍴╠z╣	");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[99] 	s╠⍴╣z	");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s->value)
		CHK(6, cleanup, L"[99] 	╠s╣⍴z	");
	
	*stkhd++ = retain_cell(loc->s->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[99] 	╠s⍴z╣	");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[77] cat←╠{╣");
	return err;
}

int
ptr8866(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *s;
		struct cell_array *pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *axis;
		struct cell_array_box *noax;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->s = NULL;
	loc->pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->noax->value)
		CHK(6, cleanup, L"[80] 		╠noax╣:'ravel_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(lex->noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	israv:╠{╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[80] 		noax:'ravel_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!ravel_ibeam)
				CHK(6, cleanup, L"[80] 		noax:╠'ravel_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[81] 		1≢≢,╠axis╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[81] 		1≢≢╠,╣axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢≢╠,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1≢╠≢╣,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢╠≢,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1╠≢╣≢,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[81] 		╠1≢≢,axis╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[81] 		1≢≢,axis:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		axis=⌈╠axis╣:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[82] 		axis=╠⌈╣axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] 		axis=╠⌈axis╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[82] 		axis╠=╣⌈axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		╠axis╣=⌈axis:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[82] 		╠axis=⌈axis╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[82] 		axis=⌈axis:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴╠⍵╣)⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴╣⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴⍵╣)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)╠↓╣s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈╠axis╣)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←╠⌈╣axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←╠⌈axis╣)↓s←⍴⍵)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,╠(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s),1╠,╣(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),╠1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s)╠,╣1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->s)
		CHK(6, cleanup, L"[83] 		((pr↑╠s╣),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[83] 		((pr╠↑╣s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[83] 		((╠pr╣↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		(╠(pr↑s)╣,1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[79] 	israv:╠{╣");
	return err;
}

int
ptr8867(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *s;
		struct cell_array *pr;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_array_box *axis;
		struct cell_array_box *noax;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->s = NULL;
	loc->pr = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!lex->noax->value)
		CHK(6, cleanup, L"[80] 		╠noax╣:'ravel_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(lex->noax->value);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[80] 		noax:'ravel_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!ravel_ibeam)
				CHK(6, cleanup, L"[80] 		noax:╠'ravel_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(ravel_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[81] 		1≢≢,╠axis╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[81] 		1≢≢╠,╣axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢≢╠,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1≢╠≢╣,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[81] 		1≢╠≢,axis╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[81] 		1╠≢╣≢,axis:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[81] 		╠1╣≢≢,axis:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[81] 		╠1≢≢,axis╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[80] 		noax:╠'ravel_ibeam'⌶ ⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[81] 		1≢≢,axis:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[81] 		1≢≢,axis:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		axis=⌈╠axis╣:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[82] 		axis=╠⌈╣axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] 		axis=╠⌈axis╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[82] 		axis╠=╣⌈axis:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[82] 		╠axis╣=⌈axis:⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[82] 		╠axis=⌈axis╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] 		1≢≢,axis:╠⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[82] 		axis=⌈axis:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←⍴╠⍵╣)⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴╣⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←⌈axis)↓s←╠⍴⍵╣)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈axis)╠↓╣s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←⌈╠axis╣)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[83] 		((pr↑s),1,(pr←╠⌈╣axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,(pr←╠⌈axis╣)↓s←⍴⍵)⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pr);
	loc->pr = retain_cell(stkhd[-1]);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),1,╠(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s),1╠,╣(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[83] 		((pr↑s),╠1╣,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		((pr↑s),╠1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[83] 		((pr↑s)╠,╣1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->s)
		CHK(6, cleanup, L"[83] 		((pr↑╠s╣),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[83] 		((pr╠↑╣s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->pr)
		CHK(6, cleanup, L"[83] 		((╠pr╣↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
	*stkhd++ = retain_cell(loc->pr);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		(╠(pr↑s)╣,1,(pr←⌈axis)↓s←⍴⍵)⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)╣⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[83] 		╠((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[79] 	israv:╠{╣");
	return err;
}

int
ptr8868(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fx;
		struct cell_array_box *axis;
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr╠≠╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧╠lr╣≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧(rr≢0)∧╠lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)╠∧╣lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr╠≢╣0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(╠rr╣≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)╣∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)╠∧╣(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr╠≢╣0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(╠lr╣≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)╣∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)∧(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[90] 	axis≠fx←⌈axis:╠⍺{╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr╠≢╣0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(╠rr╣≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣╠(rr≢0)╣⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]╠⍣╣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[╠axis╣]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,╣[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis╣]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)╣⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[╠fx╣],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,╣[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,[fx╣],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢╠⍺╣),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)╠⊢╣⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)╠⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr╠≢╣0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(╠lr╣≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣╠(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]╠⍣╣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[╠axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(╠,╣[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(╠,[axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(╠,[axis]⍣(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
	return err;
}

int
ptr8869(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fx;
		struct cell_array_box *axis;
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠╠rr╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr╠≠╣rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧╠lr╣≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧(rr≢0)∧╠lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)╠∧╣lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢╠0╣)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr╠≢╣0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[91] 		(lr≢0)∧(╠rr╣≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)╣∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		(lr≢0)∧╠(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[91] 		(lr≢0)╠∧╣(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢╠0╣)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[91] 		(lr╠≢╣0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[91] 		(╠lr╣≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)╣∧(rr≢0)∧lr≠rr:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[91] 		╠(lr≢0)∧(rr≢0)∧lr≠rr╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[91] 		(lr≢0)∧(rr≢0)∧lr≠rr:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)╠⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢╠0╣)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr╠≢╣0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->rr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(╠rr╣≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣╠(rr≢0)╣⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]╠⍣╣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx],[╠axis╣]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,╣[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis╣]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)╣⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[fx]╠,[axis]⍣(rr≢0)⊢⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺),[╠fx╣],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,╣[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)⊢⍺)╠,[fx╣],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)⊢╠⍺╣),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr≢0)╠⊢╣⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣(lr≢0)╠⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[92] 		(,[axis]⍣(lr≢╠0╣)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(lr╠≢╣0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[92] 		(,[axis]⍣(╠lr╣≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		(,[axis]⍣╠(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.pow)
		CHK(6, cleanup, L"[92] 		(,[axis]╠⍣╣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.pow);
	
	if (!lex->axis->value)
		CHK(6, cleanup, L"[92] 		(,[╠axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(lex->axis->value);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[92] 		(╠,╣[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *aa = stkhd[-1];
		struct cell_array *axis = stkhd[-2];
		struct cell_func *dst;
	
		CHK(derive_func_opts(&dst, aa, 1), cleanup,
		    L"[92] 		(╠,[axis╣]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		dst->opts[0] = axis;
	
		release_func(aa);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[92] 		(╠,[axis]⍣(lr≢0)╣⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺)╣,[fx],[axis]⍣(rr≢0)⊢⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[92] 		╠(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[90] 	axis≠fx←⌈axis:⍺╠{╣");
	return err;
}

int
ptr8870(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fx;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[95] 	lx←{fx╠≥╣⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{╠fx╣≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{╠fx≥⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴╠⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴╣⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx╠⌷╣⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx╣⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx⌷⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	return err;
}

int
ptr8871(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fx;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.gte)
		CHK(6, cleanup, L"[95] 	lx←{fx╠≥╣⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.gte);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{╠fx╣≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{╠fx≥⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥╠⍺╣:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:╠1╣ ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴╠⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴╣⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷╠⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx╠⌷╣⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->fx->value)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx╣⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(lex->fx->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ ╠fx⌷⍴⍵╣} ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←╠{fx≥⍺:1 ⋄ fx⌷⍴⍵}╣ ⋄ vc←{⍺≡0:c ⋄ ≢⍵}");
	return err;
}

int
ptr8872(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *c;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺╠≡╣0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺╣≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺≡0╣:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!lex->c->value)
				CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:╠c╣ ⋄ ≢⍵}");
			
			*stkhd++ = retain_cell(lex->c->value);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	return err;
}

int
ptr8873(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *c;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺╠≡╣0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺╣≡0:c ⋄ ≢⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{╠⍺≡0╣:c ⋄ ≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡╠0╣:c ⋄ ≢⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!lex->c->value)
				CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:╠c╣ ⋄ ≢⍵}");
			
			*stkhd++ = retain_cell(lex->c->value);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←{⍺≡0:c ⋄ ╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[95] 	lx←{fx≥⍺:1 ⋄ fx⌷⍴⍵} ⋄ vc←╠{⍺≡0:c ⋄ ≢⍵}╣");
	return err;
}

int
ptr8874(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>╠rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr╠>╣rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{╠lr╣>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{╠lr>rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[97] 	╠s←⍴⍺{lr>rr:⍺ ⋄ ⍵}⍵╣ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:╠⍺╣ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	return err;
}

int
ptr8875(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rr;
		struct cell_array_box *lr;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->rr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>╠rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->rr->value);
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr╠>╣rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!lex->lr->value)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{╠lr╣>rr:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(lex->lr->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[97] 	s←⍴⍺{╠lr>rr╣:⍺ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:╠⍺╣ ⋄ ⍵}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[97] 	s←⍴⍺{lr>rr:⍺ ⋄ ╠⍵╣}⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] 	s←⍴⍺╠{lr>rr:⍺ ⋄ ⍵}╣⍵ ⋄ s[fx]←ax+wx ⋄ c←×⌿fx↑s ⋄ ac←lr vc a ⋄ wc←rr vc w ");
	return err;
}

int
ptr8876(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *d;
		struct cell_array *pd;
		struct cell_array *mx;
		struct cell_array *nd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->d = NULL;
	loc->pd = NULL;
	loc->mx = NULL;
	loc->nd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[104]    ╠is_simple╣ ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    ╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8877, ptr8878, 0), cleanup, 
				    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[105]    0≡≢,╠⍵╣:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[105]    0≡≢╠,╣⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[105]    0≡≢╠,⍵╣:(×d)+d←∇⊃⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[105]    0≡╠≢╣,⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[105]    0≡╠≢,⍵╣:(×d)+d←∇⊃⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[105]    0╠≡╣≢,⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[105]    ╠0╣≡≢,⍵:(×d)+d←∇⊃⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[105]    ╠0╣≡≢,⍵:(×d)+d←∇⊃⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[105]    ╠0≡≢,⍵╣:(×d)+d←∇⊃⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105]    0≡≢,╠⍵╣:(×d)+d←∇⊃⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←∇⊃╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.dis)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←∇╠⊃╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:(×d)+d←∇╠⊃⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←╠∇╣⊃⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:(×d)+d←╠∇⊃⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->d);
			loc->d = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)╠+╣d←∇⊃⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!loc->d)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×╠d╣)+d←∇⊃⍵");
			
			*stkhd++ = retain_cell(loc->d);
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(╠×╣d)+d←∇⊃⍵");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:╠(×d)╣+d←∇⊃⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:╠(×d)+d←∇⊃⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨,╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨╠,╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨╠,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇╠¨╣,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!self)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇╣¨,⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇¨╣,⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->d);
	loc->d = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←╠|╣d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←╠|d←∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pd);
	loc->pd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈╠⌿╣pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[106]    nd←1+mx←╠⌈╣⌿pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[106]    nd←1+mx←╠⌈⌿╣pd←|d←∇¨,⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←╠⌈⌿pd←|d←∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->mx);
	loc->mx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[106]    nd←1╠+╣mx←⌈⌿pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106]    nd←╠1╣+mx←⌈⌿pd←|d←∇¨,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[106]    nd←╠1╣+mx←⌈⌿pd←|d←∇¨,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[106]    nd←╠1+mx←⌈⌿pd←|d←∇¨,⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->nd);
	loc->nd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->mx)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠╠mx╣:-nd");
	
	*stkhd++ = retain_cell(loc->mx);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd╠≠╣mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!loc->pd)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨╠pd╣≠mx:-nd");
	
	*stkhd++ = retain_cell(loc->pd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿(d<0)∨╠pd≠mx╣:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)╠∨╣pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107]    ∨⌿(d<╠0╣)∨pd≠mx:-nd");
	
		CHK(fill_array(arr, dat), cleanup, L"[107]    ∨⌿(d<╠0╣)∨pd≠mx:-nd");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[107]    ∨⌿(d╠<╣0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->d)
		CHK(6, cleanup, L"[107]    ∨⌿(╠d╣<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(loc->d);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿╠(d<0)╣∨pd≠mx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿╠(d<0)∨pd≠mx╣:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[107]    ∨╠⌿╣(d<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[107]    ╠∨╣⌿(d<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[107]    ╠∨⌿╣(d<0)∨pd≠mx:-nd");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107]    ╠∨⌿(d<0)∨pd≠mx╣:-nd");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107]    ∨⌿(d<0)∨pd≠╠mx╣:-nd");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!loc->nd)
				CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠mx:-╠nd╣");
			
			*stkhd++ = retain_cell(loc->nd);
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠mx:╠-╣nd");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107]    ∨⌿(d<0)∨pd≠mx:╠-nd╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->nd)
		CHK(6, cleanup, L"[108]    ╠nd╣");
	
	*stkhd++ = retain_cell(loc->nd);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[103] depth←╠{╣");
	return err;
}

int
ptr8877(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr8878(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr8879(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *d;
		struct cell_array *pd;
		struct cell_array *mx;
		struct cell_array *nd;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->d = NULL;
	loc->pd = NULL;
	loc->mx = NULL;
	loc->nd = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[104]    ╠is_simple╣ ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    ╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8880, ptr8881, 0), cleanup, 
				    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[105]    0≡≢,╠⍵╣:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[105]    0≡≢╠,╣⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[105]    0≡≢╠,⍵╣:(×d)+d←∇⊃⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[105]    0≡╠≢╣,⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[105]    0≡╠≢,⍵╣:(×d)+d←∇⊃⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[105]    0╠≡╣≢,⍵:(×d)+d←∇⊃⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[105]    ╠0╣≡≢,⍵:(×d)+d←∇⊃⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[105]    ╠0╣≡≢,⍵:(×d)+d←∇⊃⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[105]    ╠0≡≢,⍵╣:(×d)+d←∇⊃⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[105]    0≡≢,╠⍵╣:(×d)+d←∇⊃⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←∇⊃╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.dis)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←∇╠⊃╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:(×d)+d←∇╠⊃⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)+d←╠∇╣⊃⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:(×d)+d←╠∇⊃⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			release_cell(loc->d);
			loc->d = retain_cell(stkhd[-1]);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×d)╠+╣d←∇⊃⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!loc->d)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(×╠d╣)+d←∇⊃⍵");
			
			*stkhd++ = retain_cell(loc->d);
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[105]    0≡≢,⍵:(╠×╣d)+d←∇⊃⍵");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:╠(×d)╣+d←∇⊃⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[105]    0≡≢,⍵:╠(×d)+d←∇⊃⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨,╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨╠,╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←∇¨╠,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←∇╠¨╣,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!self)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇╣¨,⍵");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇¨╣,⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←|d←╠∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->d);
	loc->d = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈⌿pd←╠|╣d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←⌈⌿pd←╠|d←∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->pd);
	loc->pd = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[106]    nd←1+mx←⌈╠⌿╣pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.max)
		CHK(6, cleanup, L"[106]    nd←1+mx←╠⌈╣⌿pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.max);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[106]    nd←1+mx←╠⌈⌿╣pd←|d←∇¨,⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106]    nd←1+mx←╠⌈⌿pd←|d←∇¨,⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->mx);
	loc->mx = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[106]    nd←1╠+╣mx←⌈⌿pd←|d←∇¨,⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106]    nd←╠1╣+mx←⌈⌿pd←|d←∇¨,⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[106]    nd←╠1╣+mx←⌈⌿pd←|d←∇¨,⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[106]    nd←╠1+mx←⌈⌿pd←|d←∇¨,⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->nd);
	loc->nd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->mx)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠╠mx╣:-nd");
	
	*stkhd++ = retain_cell(loc->mx);
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd╠≠╣mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!loc->pd)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨╠pd╣≠mx:-nd");
	
	*stkhd++ = retain_cell(loc->pd);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿(d<0)∨╠pd≠mx╣:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[107]    ∨⌿(d<0)╠∨╣pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[107]    ∨⌿(d<╠0╣)∨pd≠mx:-nd");
	
		CHK(fill_array(arr, dat), cleanup, L"[107]    ∨⌿(d<╠0╣)∨pd≠mx:-nd");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[107]    ∨⌿(d╠<╣0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->d)
		CHK(6, cleanup, L"[107]    ∨⌿(╠d╣<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(loc->d);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿╠(d<0)╣∨pd≠mx:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[107]    ∨⌿╠(d<0)∨pd≠mx╣:-nd");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[107]    ∨╠⌿╣(d<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[107]    ╠∨╣⌿(d<0)∨pd≠mx:-nd");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[107]    ╠∨⌿╣(d<0)∨pd≠mx:-nd");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[107]    ╠∨⌿(d<0)∨pd≠mx╣:-nd");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[107]    ∨⌿(d<0)∨pd≠╠mx╣:-nd");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!loc->nd)
				CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠mx:-╠nd╣");
			
			*stkhd++ = retain_cell(loc->nd);
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[107]    ∨⌿(d<0)∨pd≠mx:╠-╣nd");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[107]    ∨⌿(d<0)∨pd≠mx:╠-nd╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->nd)
		CHK(6, cleanup, L"[108]    ╠nd╣");
	
	*stkhd++ = retain_cell(loc->nd);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[103] depth←╠{╣");
	return err;
}

int
ptr8880(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr8881(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[104]    is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[104]    is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[104]    is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[104]    is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr8882(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴╠⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[114] nqv←{⍬≡╠⍴╣⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡╠⍴⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[114] nqv←{⍬╠≡╣⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] nqv←{╠⍬╣≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[114] nqv←{╠⍬╣≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[114] nqv←{╠⍬≡⍴⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] ╠nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] nqv←{⍬≡⍴⍵:╠1╣ ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] nqv←{⍬≡⍴⍵:╠1╣ ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴╠⍵╣} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃╠⍴╣⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃╠⍴⍵╣} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ╠⊃╣⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ╠⊃⍴⍵╣} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[114] nqv←╠{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵}╣ ambiv ('nqv_ibeam'⌶)");
	return err;
}

int
ptr8883(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴╠⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[114] nqv←{⍬≡╠⍴╣⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡╠⍴⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[114] nqv←{⍬╠≡╣⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] nqv←{╠⍬╣≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[114] nqv←{╠⍬╣≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[114] nqv←{╠⍬≡⍴⍵╣:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ╠⊃⍴⍵╣} ambiv ('nqv_ibeam'⌶)");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[114] nqv←{⍬≡⍴⍵:╠1╣ ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
			
				CHK(fill_array(arr, dat), cleanup, L"[114] nqv←{⍬≡⍴⍵:╠1╣ ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴╠⍵╣} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃╠⍴╣⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ⊃╠⍴⍵╣} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ╠⊃╣⍴⍵} ambiv ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[114] nqv←{⍬≡⍴⍵:1 ⋄ ╠⊃⍴⍵╣} ambiv ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[114] nqv←╠{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵}╣ ambiv ('nqv_ibeam'⌶)");
	return err;
}

int
ptr8884(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *any;
		struct cell_func_box *is_span;
		struct cell_func_box *is_integer;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[118] 	is_span ╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[118] 	╠is_span╣ ⍺:⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 	╠is_span ⍺╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[118] 	is_span ╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[118] 	is_span ⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[119] 	0≡is_integer squeeze ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[119] 	0≡is_integer ╠squeeze╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[119] 	0≡is_integer ╠squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[119] 	0≡╠is_integer╣ squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[119] 	0≡╠is_integer squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[119] 	0╠≡╣is_integer squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[119] 	╠0╣≡is_integer squeeze ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[119] 	╠0╣≡is_integer squeeze ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[119] 	╠0≡is_integer squeeze ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[119] 	0≡is_integer squeeze ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[119] 	0≡is_integer squeeze ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[119] 	0≡is_integer squeeze ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[119] 	0≡is_integer squeeze ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[119] 	0≡is_integer squeeze ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[120] 	0≡≢,╠⍺╣:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[120] 	0≡≢╠,╣⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	0≡≢╠,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[120] 	0≡╠≢╣,⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	0≡╠≢,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[120] 	0╠≡╣≢,⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	╠0╣≡≢,⍺:(⍴⍺)⍴0⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	╠0╣≡≢,⍺:(⍴⍺)⍴0⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	╠0≡≢,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[120] 	0≡≢,╠⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴0⍴╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴0╠⍴╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0╣⍴⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0╣⍴⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0⍴⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)╠⍴╣0⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!alpha)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴╠⍺╣)⍴0⍴⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(╠⍴╣⍺)⍴0⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:╠(⍴⍺)╣⍴0⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:╠(⍴⍺)⍴0⍴⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢,╠⍵╣:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢╠,╣⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨⍺>≢╠,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>╠≢╣,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨⍺>╠≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺╠>╣≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!alpha)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨╠⍺╣>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨╠⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[121] 	any(⍺<0)╠∨╣⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	any(⍺<╠0╣)∨⍺>≢,⍵:⎕SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	any(⍺<╠0╣)∨⍺>≢,⍵:⎕SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[121] 	any(⍺╠<╣0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!alpha)
		CHK(6, cleanup, L"[121] 	any(╠⍺╣<0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any╠(⍺<0)╣∨⍺>≢,⍵:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any╠(⍺<0)∨⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->any->value)
		CHK(6, cleanup, L"[121] 	╠any╣(⍺<0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	╠any(⍺<0)∨⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	any(⍺<0)∨⍺>≢,╠⍵╣:⎕SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:⎕SIGNAL ╠3╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:⎕SIGNAL ╠3╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:╠⎕SIGNAL╣ 3");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	any(⍺<0)∨⍺>≢,⍵:╠⎕SIGNAL 3╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴⍺('index_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!index_ibeam)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴⍺╠('index_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(index_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴╠⍺╣('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	(⍴⍺)⍴╠⍺('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[122] 	(⍴⍺)╠⍴╣⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!alpha)
		CHK(6, cleanup, L"[122] 	(⍴╠⍺╣)⍴⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[122] 	(╠⍴╣⍺)⍴⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[122] 	╠(⍴⍺)╣⍴⍺('index_ibeam'⌶)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	╠(⍴⍺)⍴⍺('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[117] sqd_vec←╠{╣");
	return err;
}

int
ptr8885(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *any;
		struct cell_func_box *is_span;
		struct cell_func_box *is_integer;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[118] 	is_span ╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[118] 	╠is_span╣ ⍺:⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[118] 	╠is_span ⍺╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[118] 	is_span ╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[118] 	is_span ⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[119] 	0≡is_integer squeeze ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[119] 	0≡is_integer ╠squeeze╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[119] 	0≡is_integer ╠squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[119] 	0≡╠is_integer╣ squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[119] 	0≡╠is_integer squeeze ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[119] 	0╠≡╣is_integer squeeze ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[119] 	╠0╣≡is_integer squeeze ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[119] 	╠0╣≡is_integer squeeze ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[119] 	╠0≡is_integer squeeze ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[119] 	0≡is_integer squeeze ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[119] 	0≡is_integer squeeze ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[119] 	0≡is_integer squeeze ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[119] 	0≡is_integer squeeze ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[119] 	0≡is_integer squeeze ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[120] 	0≡≢,╠⍺╣:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[120] 	0≡≢╠,╣⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	0≡≢╠,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[120] 	0≡╠≢╣,⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[120] 	0≡╠≢,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[120] 	0╠≡╣≢,⍺:(⍴⍺)⍴0⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	╠0╣≡≢,⍺:(⍴⍺)⍴0⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[120] 	╠0╣≡≢,⍺:(⍴⍺)⍴0⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[120] 	╠0≡≢,⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[120] 	0≡≢,╠⍺╣:(⍴⍺)⍴0⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴0⍴╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴0╠⍴╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0╣⍴⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0╣⍴⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:(⍴⍺)⍴╠0⍴⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴⍺)╠⍴╣0⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!alpha)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(⍴╠⍺╣)⍴0⍴⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[120] 	0≡≢,⍺:(╠⍴╣⍺)⍴0⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:╠(⍴⍺)╣⍴0⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[120] 	0≡≢,⍺:╠(⍴⍺)⍴0⍴⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢,╠⍵╣:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢╠,╣⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨⍺>≢╠,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>╠≢╣,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨⍺>╠≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺╠>╣≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!alpha)
		CHK(6, cleanup, L"[121] 	any(⍺<0)∨╠⍺╣>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any(⍺<0)∨╠⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[121] 	any(⍺<0)╠∨╣⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	any(⍺<╠0╣)∨⍺>≢,⍵:⎕SIGNAL 3");
	
		CHK(fill_array(arr, dat), cleanup, L"[121] 	any(⍺<╠0╣)∨⍺>≢,⍵:⎕SIGNAL 3");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[121] 	any(⍺╠<╣0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!alpha)
		CHK(6, cleanup, L"[121] 	any(╠⍺╣<0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any╠(⍺<0)╣∨⍺>≢,⍵:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[121] 	any╠(⍺<0)∨⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->any->value)
		CHK(6, cleanup, L"[121] 	╠any╣(⍺<0)∨⍺>≢,⍵:⎕SIGNAL 3");
	
	*stkhd++ = retain_cell(lex->any->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[121] 	╠any(⍺<0)∨⍺>≢,⍵╣:⎕SIGNAL 3");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[121] 	any(⍺<0)∨⍺>≢,╠⍵╣:⎕SIGNAL 3");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {3};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:⎕SIGNAL ╠3╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:⎕SIGNAL ╠3╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[121] 	any(⍺<0)∨⍺>≢,⍵:╠⎕SIGNAL╣ 3");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[121] 	any(⍺<0)∨⍺>≢,⍵:╠⎕SIGNAL 3╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴⍺('index_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!index_ibeam)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴⍺╠('index_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(index_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[122] 	(⍴⍺)⍴╠⍺╣('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	(⍴⍺)⍴╠⍺('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[122] 	(⍴⍺)╠⍴╣⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!alpha)
		CHK(6, cleanup, L"[122] 	(⍴╠⍺╣)⍴⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[122] 	(╠⍴╣⍺)⍴⍺('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[122] 	╠(⍴⍺)╣⍴⍺('index_ibeam'⌶)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[122] 	╠(⍴⍺)⍴⍺('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[117] sqd_vec←╠{╣");
	return err;
}

int
ptr8886(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *i;
		struct cell_array *c;
		struct cell_array_box *ws;
		struct cell_array *o;
		struct cell_array *j;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *sqd_vec;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->i = NULL;
	loc->c = NULL;
	CHK(mk_array_box(&loc->ws, NULL), cleanup, L"Init mutable variable: loc->ws");
	loc->o = NULL;
	loc->j = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[124] sqd←{⍺←╠⊢╣");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	1≡⍺ ╠1╣:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	1≡⍺ ╠1╣:⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[125] 	1≡╠⍺╣ 1:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[125] 	1≡╠⍺ 1╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[125] 	1╠≡╣⍺ 1:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	╠1╣≡⍺ 1:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	╠1╣≡⍺ 1:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	╠1≡⍺ 1╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[125] 	1≡⍺ ╠1╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[125] 	1≡⍺ 1:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺╠⊣╣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺╠⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺╣⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢╠⍴╣i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢╠⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠≢╣⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠≢⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8887, ptr8888, 0), cleanup, 
		    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴╠⍵╣:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢╠⍴╣⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢╠⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡╠≢╣⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡╠≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1╠≡╣≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1╣≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1╣≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8889, ptr8890, 0), cleanup, 
		    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = k;
	}
	
	if (!loc->i)
		CHK(6, cleanup, L"[127] 	(1≡c←≢╠i╣){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[127] 	(1≡c←╠≢╣i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←╠≢i╣){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[127] 	(1╠≡╣c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(╠1╣≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(╠1╣≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	╠(1≡c←≢i)╣{⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	╠(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴╠⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->sqd_vec->value)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)╠sqd_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->sqd_vec->value);
			
			if (!loc->i)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃╠i╣)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(loc->i);
			
			if (!cdf_prim.dis)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(╠⊃╣i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:╠(⊃i)╣sqd_vec ⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:╠(⊃i)sqd_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[128] 	c>≢⍴╠⍵╣:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[128] 	c>≢╠⍴╣⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	c>≢╠⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[128] 	c>╠≢╣⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	c>╠≢⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[128] 	c╠>╣≢⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!loc->c)
		CHK(6, cleanup, L"[128] 	╠c╣>≢⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[128] 	╠c>≢⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[128] 	c>≢⍴╠⍵╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[128] 	c>≢⍴⍵:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[128] 	c>≢⍴⍵:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[128] 	c>≢⍴⍵:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[128] 	c>≢⍴⍵:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←╠⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ws->value);
	loc->ws->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳╠≢╣ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳╠≢ws←⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳╣≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳≢ws←⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c╠↑╣⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->c)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╠c╣↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╠c↑⍳≢ws←⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╠¨╣c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8891, ptr8892, 2), cleanup, 
		    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	
		k->fv[0] = retain_cell(loc->ws);
		k->fv[1] = retain_cell(lex->is_span);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╣c↑⍳≢ws←⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->i)
		CHK(6, cleanup, L"[129] 	i←╠i╣{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	i←╠i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽╠⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,╠⌽╣⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,╠⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1╠,╣⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1╣,⌽⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1╣,⌽⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.scf)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×╠⍀╣1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.scf);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×╣⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×⍀╣1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←╠⌽╣×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←╠⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->o);
	loc->o = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c╠⌷╣o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳╠c╣⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳╠c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴╠⍳╣c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴╠⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)╠⍴╣⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴╠⍵╣)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓╠⍴╣⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓╠⍴⍵)╣⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c╠↓╣⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(╠c╣↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂╠(c↓⍴⍵)╣⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂╠(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),╠⊂╣(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),╠⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o)╠,╣⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->o)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓╠o╣),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->o);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1╠↓╣o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑╠1╣↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑╠1╣↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑╠1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c╠↑╣1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×╠c╣↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×╠c↑1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i╠×╣c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->i)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(╠i╣×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿╠(i×c↑1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿╠(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+╠⌿╣(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.oup)
		CHK(6, cleanup, L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.oup);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃╠∘.+⌿╣(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃╠∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[130] 	j←╠⊃╣∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←╠⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->j);
	loc->j = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[131] 	j sqd_vec ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->sqd_vec->value)
		CHK(6, cleanup, L"[131] 	j ╠sqd_vec╣ ⍵");
	
	*stkhd++ = retain_cell(lex->sqd_vec->value);
	
	if (!loc->j)
		CHK(6, cleanup, L"[131] 	╠j╣ sqd_vec ⍵");
	
	*stkhd++ = retain_cell(loc->j);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] 	╠j sqd_vec ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[124] sqd←╠{⍺←⊢╣");
	return err;
}

int
ptr8887(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺╣⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	return err;
}

int
ptr8888(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	return err;
}

int
ptr8889(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){╠⍺╣:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	(1≡c←╠≢╣i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:╠⍵╣ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	return err;
}

int
ptr8890(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){╠⍺╣:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	╠(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:╠⍵╣ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	return err;
}

int
ptr8891(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *ws;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ╠⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[129] 	i←i{╠is_span╣ ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳╣≢ws←⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[╠⍵╣] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.brk)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws╠[╣⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.brk);
			
			if (!lex->ws->value)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳╠ws╣[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(lex->ws->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳╠ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.iot)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:╠⍳╣ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:╠⍳ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ╠⍺╣}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	return err;
}

int
ptr8892(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *ws;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ╠⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[129] 	i←i{╠is_span╣ ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[╠⍵╣] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.brk)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws╠[╣⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.brk);
			
			if (!lex->ws->value)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳╠ws╣[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(lex->ws->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳╠ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.iot)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:╠⍳╣ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:╠⍳ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ╠⍺╣}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	return err;
}

int
ptr8893(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *i;
		struct cell_array *c;
		struct cell_array_box *ws;
		struct cell_array *o;
		struct cell_array *j;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *sqd_vec;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->i = NULL;
	loc->c = NULL;
	CHK(mk_array_box(&loc->ws, NULL), cleanup, L"Init mutable variable: loc->ws");
	loc->o = NULL;
	loc->j = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	1≡⍺ ╠1╣:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	1≡⍺ ╠1╣:⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[125] 	1≡╠⍺╣ 1:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[125] 	1≡╠⍺ 1╣:⍵");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[125] 	1≡╠⍺ 1╣:⍵");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[125] 	1╠≡╣⍺ 1:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[125] 	╠1╣≡⍺ 1:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[125] 	╠1╣≡⍺ 1:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[125] 	╠1≡⍺ 1╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[125] 	1≡⍺ ╠1╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[125] 	1≡⍺ 1:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺╠⊣╣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺╣⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺⊣0╣:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢╠⍴╣i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢╠⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠≢╣⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠≢⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8894, ptr8895, 0), cleanup, 
		    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣╠0╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴╠⍵╣:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢╠⍴╣⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢╠⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡╠≢╣⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡╠≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1╠≡╣≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1╣≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1╣≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}╠1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8896, ptr8897, 0), cleanup, 
		    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = k;
	}
	
	if (!loc->i)
		CHK(6, cleanup, L"[127] 	(1≡c←≢╠i╣){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[127] 	(1≡c←╠≢╣i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[127] 	(1≡c←╠≢i╣){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[127] 	(1╠≡╣c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(╠1╣≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(╠1╣≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	╠(1≡c←≢i)╣{⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[127] 	╠(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴╠⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->sqd_vec->value)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)╠sqd_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->sqd_vec->value);
			
			if (!loc->i)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃╠i╣)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(loc->i);
			
			if (!cdf_prim.dis)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(╠⊃╣i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(cdf_prim.dis);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:╠(⊃i)╣sqd_vec ⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:╠(⊃i)sqd_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[128] 	c>≢⍴╠⍵╣:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[128] 	c>≢╠⍴╣⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	c>≢╠⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[128] 	c>╠≢╣⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	c>╠≢⍴⍵╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[128] 	c╠>╣≢⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!loc->c)
		CHK(6, cleanup, L"[128] 	╠c╣>≢⍴⍵:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[128] 	╠c>≢⍴⍵╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[128] 	c>≢⍴╠⍵╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[128] 	c>≢⍴⍵:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[128] 	c>≢⍴⍵:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[128] 	c>≢⍴⍵:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[128] 	c>≢⍴⍵:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←╠⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->ws->value);
	loc->ws->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳╠≢╣ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳╠≢ws←⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳╣≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳≢ws←⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c╠↑╣⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->c)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╠c╣↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╠c↑⍳≢ws←⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╠¨╣c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8898, ptr8899, 2), cleanup, 
		    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	
		k->fv[0] = retain_cell(loc->ws);
		k->fv[1] = retain_cell(lex->is_span);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨╣c↑⍳≢ws←⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->i)
		CHK(6, cleanup, L"[129] 	i←╠i╣{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	i←╠i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽╠⍴╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽╠⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,╠⌽╣⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,╠⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1╠,╣⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1╣,⌽⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1╣,⌽⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀╠1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.scf)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×╠⍀╣1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.scf);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×╣⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×⍀╣1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽╠×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←╠⌽╣×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←╠⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->o);
	loc->o = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c╠⌷╣o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳╠c╣⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳╠c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴╠⍳╣c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴╠⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)╠⍴╣⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴╠⍵╣)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓╠⍴╣⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c↓╠⍴⍵)╣⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(c╠↓╣⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂(╠c╣↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂╠(c↓⍴⍵)╣⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),⊂╠(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),╠⊂╣(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑1↓o),╠⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓o)╠,╣⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!loc->o)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1↓╠o╣),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->o);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑1╠↓╣o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑╠1╣↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	j←⊃∘.+⌿(i×c↑╠1╣↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×c↑╠1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.tke)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×c╠↑╣1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.tke);
	
	if (!loc->c)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i×╠c╣↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿(i×╠c↑1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(i╠×╣c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->i)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+⌿(╠i╣×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿╠(i×c↑1↓o)╣,⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	j←⊃∘.+⌿╠(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[130] 	j←⊃∘.+╠⌿╣(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.oup)
		CHK(6, cleanup, L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.oup);
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃╠∘.+╣⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[130] 	j←⊃╠∘.+⌿╣(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←⊃╠∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[130] 	j←╠⊃╣∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[130] 	j←╠⊃∘.+⌿(i×c↑1↓o),⊂(c↓⍴⍵)⍴⍳c⌷o←⌽×⍀1,⌽⍴⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->j);
	loc->j = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[131] 	j sqd_vec ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->sqd_vec->value)
		CHK(6, cleanup, L"[131] 	j ╠sqd_vec╣ ⍵");
	
	*stkhd++ = retain_cell(lex->sqd_vec->value);
	
	if (!loc->j)
		CHK(6, cleanup, L"[131] 	╠j╣ sqd_vec ⍵");
	
	*stkhd++ = retain_cell(loc->j);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] 	╠j sqd_vec ⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[124] sqd←╠{⍺←⊢╣");
	return err;
}

int
ptr8894(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←╠⍺⊣0╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	return err;
}

int
ptr8895(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[126] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}≢⍴i←⍺⊣0:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}≢⍴i←⍺⊣0:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣≢⍴i←⍺⊣0:⎕SIGNAL 4");
	return err;
}

int
ptr8896(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){╠⍺╣:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	(1≡c←╠≢╣i){⍺:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:╠⍵╣ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	return err;
}

int
ptr8897(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[127] 	(1≡c←≢i){╠⍺╣:⍵ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[127] 	╠(1≡c←≢i){⍺:⍵ ⋄ 0}1≡≢⍴⍵╣:(⊃i)sqd_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[127] 	(1≡c←≢i){⍺:╠⍵╣ ⋄ 0}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[127] 	(1≡c←≢i){⍺:⍵ ⋄ ╠0╣}1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] 	(1≡c←≢i)╠{⍺:⍵ ⋄ 0}╣1≡≢⍴⍵:(⊃i)sqd_vec ⍵");
	return err;
}

int
ptr8898(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *ws;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ╠⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[129] 	i←i{╠is_span╣ ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑╠⍳╣≢ws←⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[╠⍵╣] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.brk)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws╠[╣⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.brk);
			
			if (!lex->ws->value)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳╠ws╣[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(lex->ws->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳╠ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.iot)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:╠⍳╣ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:╠⍳ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ╠⍺╣}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	return err;
}

int
ptr8899(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *ws;
		struct cell_func_box *is_span;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ╠⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_span->value)
		CHK(6, cleanup, L"[129] 	i←i{╠is_span╣ ⍺:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(lex->is_span->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	i←i{╠is_span ⍺╣:⍳ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[╠⍵╣] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				arr->shape[0] = 1;
				CHK(alloc_array(arr), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳ws╠[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.brk)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws╠[╣⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.brk);
			
			if (!lex->ws->value)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳╠ws╣[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(lex->ws->value);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:⍳╠ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.iot)
				CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:╠⍳╣ws[⍵] ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
			*stkhd++ = retain_cell(cdf_prim.iot);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[129] 	i←i{is_span ⍺:╠⍳ws[⍵]╣ ⋄ ⍺}¨c↑⍳≢ws←⍴⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	i←i{is_span ⍺:⍳ws[⍵] ⋄ ╠⍺╣}¨c↑⍳≢ws←⍴⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[129] 	i←i╠{is_span ⍺:⍳ws[⍵] ⋄ ⍺}╣¨c↑⍳≢ws←⍴⍵");
	return err;
}

int
ptr8900(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[136] 	chk_valid_shape ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[136] 	╠chk_valid_shape╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136] 	╠chk_valid_shape ⍵╣: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136] 	chk_valid_shape ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[137] 	0≡≢,╠⍵╣:⊂⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[137] 	0≡≢╠,╣⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137] 	0≡≢╠,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[137] 	0≡╠≢╣,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[137] 	0╠≡╣≢,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	╠0╣≡≢,⍵:⊂⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[137] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[137] 	0≡≢,╠⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.par)
				CHK(6, cleanup, L"[137] 	0≡≢,⍵:╠⊂╣⍬");
			
			*stkhd++ = retain_cell(cdf_prim.par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[137] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[138] 	(,0)≡,╠⍵╣:⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[138] 	(,0)≡╠,╣⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138] 	(,0)≡╠,⍵╣:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[138] 	(,0)╠≡╣,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	(,╠0╣)≡,⍵:⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[138] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[138] 	(╠,╣0)≡,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138] 	╠(,0)╣≡,⍵:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138] 	(,0)≡,╠⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[138] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[139] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[139] 	1≡≢╠,╣⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[139] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[139] 	1≡╠≢╣,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[139] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[139] 	1╠≡╣≢,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[139] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[139] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[139] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[139] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[139] 	1≡≢,⍵:'index_gen_vec'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!index_gen_vec)
				CHK(6, cleanup, L"[139] 	1≡≢,⍵:╠'index_gen_vec'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[139] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[140] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[140] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[140] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[140] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135] index_gen←╠{╣");
	return err;
}

int
ptr8901(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[136] 	chk_valid_shape ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[136] 	╠chk_valid_shape╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[136] 	╠chk_valid_shape ⍵╣: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136] 	chk_valid_shape ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[137] 	0≡≢,╠⍵╣:⊂⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[137] 	0≡≢╠,╣⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137] 	0≡≢╠,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[137] 	0≡╠≢╣,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[137] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[137] 	0╠≡╣≢,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	╠0╣≡≢,⍵:⊂⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[137] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[137] 	0≡≢,╠⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.par)
				CHK(6, cleanup, L"[137] 	0≡≢,⍵:╠⊂╣⍬");
			
			*stkhd++ = retain_cell(cdf_prim.par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[137] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[138] 	(,0)≡,╠⍵╣:⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[138] 	(,0)≡╠,╣⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138] 	(,0)≡╠,⍵╣:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[138] 	(,0)╠≡╣,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	(,╠0╣)≡,⍵:⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[138] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[138] 	(╠,╣0)≡,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[138] 	╠(,0)╣≡,⍵:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138] 	(,0)≡,╠⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[138] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[139] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[139] 	1≡≢╠,╣⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[139] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[139] 	1≡╠≢╣,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[139] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[139] 	1╠≡╣≢,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[139] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[139] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[139] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[139] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[139] 	1≡≢,⍵:'index_gen_vec'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!index_gen_vec)
				CHK(6, cleanup, L"[139] 	1≡≢,⍵:╠'index_gen_vec'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[139] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[140] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[140] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[140] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[140] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[135] index_gen←╠{╣");
	return err;
}

int
ptr8902(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[142] index_of←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[142] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[142] index_of←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[142] index_of←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[142] index_of←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8903(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[142] index_of←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[142] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[142] index_of←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[142] index_of←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[142] index_of←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8904(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] dis←('disclose_ibeam'⌶) ambiv {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] dis←('disclose_ibeam'⌶) ambiv ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8905(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[146] dis←('disclose_ibeam'⌶) ambiv {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] dis←('disclose_ibeam'⌶) ambiv {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] dis←('disclose_ibeam'⌶) ambiv ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8906(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	0≡≡╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	0≡╠≡╣⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0≡╠≡⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	0╠≡╣≡⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	╠0╣≡≡⍵:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	0≡≡╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	0≡≡⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[151] 	'enclose_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!enclose_ibeam)
		CHK(6, cleanup, L"[151] 	╠'enclose_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[149] enclose←╠{╣");
	return err;
}

int
ptr8907(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	0≡≡╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	0≡╠≡╣⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	0≡╠≡⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	0╠≡╣≡⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	╠0╣≡≡⍵:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	0≡≡╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	0≡≡⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[151] 	'enclose_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!enclose_ibeam)
		CHK(6, cleanup, L"[151] 	╠'enclose_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[151] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[149] enclose←╠{╣");
	return err;
}

int
ptr8908(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] par←enclose ambiv {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] par←enclose ambiv {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[153] par←enclose ambiv {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[153] par←enclose ambiv {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[153] par←enclose ambiv ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8909(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] par←enclose ambiv {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] par←enclose ambiv {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[153] par←enclose ambiv {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[153] par←enclose ambiv {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[153] par←enclose ambiv ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8910(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR ╠squeeze╣ ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[156] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[156] conjugate←{1289≡╠⎕DR╣ squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[156] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[156] conjugate←{1289╠≡╣⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[156] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[156] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[156] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[156] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!conjugate_vec_ibeam)
				CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(conjugate_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[156] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[156] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣");
	return err;
}

int
ptr8911(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR ╠squeeze╣ ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[156] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[156] conjugate←{1289≡╠⎕DR╣ squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[156] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[156] conjugate←{1289╠≡╣⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[156] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[156] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[156] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[156] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!conjugate_vec_ibeam)
				CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(conjugate_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[156] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[156] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[156] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣");
	return err;
}

int
ptr8912(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[160] sub←{0-╠⍵╣} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[160] sub←{0╠-╣⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] sub←{╠0╣-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[160] sub←{╠0╣-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] sub←{╠0-⍵╣} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[160] sub←╠{0-⍵}╣ ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	return err;
}

int
ptr8913(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[160] sub←{0-╠⍵╣} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[160] sub←{0╠-╣⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] sub←{╠0╣-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[160] sub←{╠0╣-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] sub←{╠0-⍵╣} ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[160] sub←╠{0-⍵}╣ ambiv ('sub_vec_ibeam'⌶ numeric scalar)");
	return err;
}

int
ptr8914(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[164] 	1289=⎕DR ╠⍵╣:⍵÷|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[164] 	1289=╠⎕DR╣ ⍵:⍵÷|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[164] 	1289=╠⎕DR ⍵╣:⍵÷|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[164] 	1289╠=╣⎕DR ⍵:⍵÷|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[164] 	╠1289╣=⎕DR ⍵:⍵÷|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[164] 	╠1289╣=⎕DR ⍵:⍵÷|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[164] 	╠1289=⎕DR ⍵╣:⍵÷|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[164] 	1289=⎕DR ╠⍵╣:⍵÷|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵÷|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵÷╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[164] 	1289=⎕DR ⍵:⍵÷╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵╠÷╣|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			if (!omega)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:╠⍵╣÷|⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[164] 	1289=⎕DR ⍵:╠⍵÷|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[165] 	(-⍵<0)+0<╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[165] 	(-⍵<0)+0╠<╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[165] 	(-⍵<0)+╠0╣<⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[165] 	(-⍵<0)+╠0╣<⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	(-⍵<0)+╠0<⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[165] 	(-⍵<0)╠+╣0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[165] 	(-⍵<╠0╣)+0<⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[165] 	(-⍵<╠0╣)+0<⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[165] 	(-⍵╠<╣0)+0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[165] 	(-╠⍵╣<0)+0<⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	(-╠⍵<0)╣+0<⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[165] 	(╠-╣⍵<0)+0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[165] 	╠(-⍵<0)╣+0<⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	╠(-⍵<0)+0<⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[163] sign←╠{╣");
	return err;
}

int
ptr8915(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[164] 	1289=⎕DR ╠⍵╣:⍵÷|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[164] 	1289=╠⎕DR╣ ⍵:⍵÷|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[164] 	1289=╠⎕DR ⍵╣:⍵÷|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[164] 	1289╠=╣⎕DR ⍵:⍵÷|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[164] 	╠1289╣=⎕DR ⍵:⍵÷|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[164] 	╠1289╣=⎕DR ⍵:⍵÷|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[164] 	╠1289=⎕DR ⍵╣:⍵÷|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[164] 	1289=⎕DR ╠⍵╣:⍵÷|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵÷|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵÷╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[164] 	1289=⎕DR ⍵:⍵÷╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:⍵╠÷╣|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			if (!omega)
				CHK(6, cleanup, L"[164] 	1289=⎕DR ⍵:╠⍵╣÷|⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[164] 	1289=⎕DR ⍵:╠⍵÷|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[165] 	(-⍵<0)+0<╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[165] 	(-⍵<0)+0╠<╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[165] 	(-⍵<0)+╠0╣<⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[165] 	(-⍵<0)+╠0╣<⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	(-⍵<0)+╠0<⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[165] 	(-⍵<0)╠+╣0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[165] 	(-⍵<╠0╣)+0<⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[165] 	(-⍵<╠0╣)+0<⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[165] 	(-⍵╠<╣0)+0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[165] 	(-╠⍵╣<0)+0<⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	(-╠⍵<0)╣+0<⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[165] 	(╠-╣⍵<0)+0<⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[165] 	╠(-⍵<0)╣+0<⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[165] 	╠(-⍵<0)+0<⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[163] sign←╠{╣");
	return err;
}

int
ptr8916(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[170] div←{1÷╠⍵╣} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[170] div←{1╠÷╣⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[170] div←{╠1╣÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[170] div←{╠1╣÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[170] div←{╠1÷⍵╣} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[170] div←╠{1÷⍵}╣ ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	return err;
}

int
ptr8917(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[170] div←{1÷╠⍵╣} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[170] div←{1╠÷╣⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[170] div←{╠1╣÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[170] div←{╠1╣÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[170] div←{╠1÷⍵╣} ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[170] div←╠{1÷⍵}╣ ambiv ('div_vec_ibeam'⌶ numeric scalar)");
	return err;
}

int
ptr8918(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[174] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[174] 	0≡╠is_numeric╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[174] 	0≡╠is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[174] 	0╠≡╣is_numeric ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[174] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[174] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[174] 	╠0≡is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[174] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[174] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[174] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[174] 	0≡is_numeric ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[174] 	0≡is_numeric ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[175] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[175] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[175] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[175] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[175] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[175] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[175] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[175] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[175] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[175] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[176] 	'abs_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!abs_vec_ibeam)
		CHK(6, cleanup, L"[176] 	╠'abs_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(abs_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[176] 	╠'abs_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[173] absolute←╠{╣");
	return err;
}

int
ptr8919(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[174] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[174] 	0≡╠is_numeric╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[174] 	0≡╠is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[174] 	0╠≡╣is_numeric ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[174] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[174] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[174] 	╠0≡is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[174] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[174] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[174] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[174] 	0≡is_numeric ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[174] 	0≡is_numeric ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[175] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[175] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[175] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[175] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[175] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[175] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[175] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[175] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[175] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[175] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[176] 	'abs_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!abs_vec_ibeam)
		CHK(6, cleanup, L"[176] 	╠'abs_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(abs_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[176] 	╠'abs_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[173] absolute←╠{╣");
	return err;
}

int
ptr8920(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+0=╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+0╠=╣⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0╣=⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0╣=⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺╠+╣0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷╠⍺╣+0=⍺}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊⍵÷╠⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵╠÷╣⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊╠⍵╣÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊╠⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×╠⌊╣⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×╠⌊⍵÷⍺+0=⍺╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺╠×╣⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-╠⍺╣×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-╠⍺×⌊⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[178] residue←{⍵╠-╣⍺×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[178] residue←{╠⍵╣-⍺×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{╠⍵-⍺×⌊⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[178] residue←╠{⍵-⍺×⌊⍵÷⍺+0=⍺}╣");
	return err;
}

int
ptr8921(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+0=╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+0╠=╣⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0╣=⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0╣=⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊⍵÷⍺+╠0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷⍺╠+╣0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵÷╠⍺╣+0=⍺}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊⍵÷╠⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊⍵╠÷╣⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×⌊╠⍵╣÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×⌊╠⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺×╠⌊╣⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[178] residue←{⍵-⍺×╠⌊⍵÷⍺+0=⍺╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[178] residue←{⍵-⍺╠×╣⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[178] residue←{⍵-╠⍺╣×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{⍵-╠⍺×⌊⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[178] residue←{⍵╠-╣⍺×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[178] residue←{╠⍵╣-⍺×⌊⍵÷⍺+0=⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[178] residue←{╠⍵-⍺×⌊⍵÷⍺+0=⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[178] residue←╠{⍵-⍺×⌊⍵÷⍺+0=⍺}╣");
	return err;
}

int
ptr8922(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[183] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[183] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[183] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[183] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[183] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[184] 	1289=⎕DR ╠⍵╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[184] 	1289=╠⎕DR╣ ⍵:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[184] 	1289=╠⎕DR ⍵╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[184] 	1289╠=╣⎕DR ⍵:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[184] 	╠1289╣=⎕DR ⍵:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[184] 	╠1289╣=⎕DR ⍵:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[184] 	╠1289=⎕DR ⍵╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[184] 	1289=⎕DR ╠⍵╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[184] 	1289=⎕DR ⍵:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[184] 	1289=⎕DR ⍵:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[184] 	1289=⎕DR ⍵:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[184] 	1289=⎕DR ⍵:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[185] 	'floor_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!floor_vec_ibeam)
		CHK(6, cleanup, L"[185] 	╠'floor_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] 	╠'floor_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[182] floor_array←╠{╣");
	return err;
}

int
ptr8923(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[183] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[183] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[183] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[183] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[183] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[184] 	1289=⎕DR ╠⍵╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[184] 	1289=╠⎕DR╣ ⍵:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[184] 	1289=╠⎕DR ⍵╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[184] 	1289╠=╣⎕DR ⍵:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[184] 	╠1289╣=⎕DR ⍵:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[184] 	╠1289╣=⎕DR ⍵:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[184] 	╠1289=⎕DR ⍵╣:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[184] 	1289=⎕DR ╠⍵╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[184] 	1289=⎕DR ⍵:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[184] 	1289=⎕DR ⍵:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[184] 	1289=⎕DR ⍵:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[184] 	1289=⎕DR ⍵:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[185] 	'floor_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!floor_vec_ibeam)
		CHK(6, cleanup, L"[185] 	╠'floor_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] 	╠'floor_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[182] floor_array←╠{╣");
	return err;
}

int
ptr8924(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[191] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[191] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[191] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[191] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[191] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[192] 	1289=⎕DR ╠⍵╣:-⌊-⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289=╠⎕DR╣ ⍵:-⌊-⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289=╠⎕DR ⍵╣:-⌊-⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[192] 	1289╠=╣⎕DR ⍵:-⌊-⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	╠1289╣=⎕DR ⍵:-⌊-⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	╠1289╣=⎕DR ⍵:-⌊-⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	╠1289=⎕DR ⍵╣:-⌊-⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289=⎕DR ╠⍵╣:-⌊-⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-⌊-╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-⌊╠-╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:-⌊╠-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.min)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-╠⌊╣-⍵");
			
			*stkhd++ = retain_cell(cdf_prim.min);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:-╠⌊-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:╠-╣⌊-⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:╠-⌊-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[193] 	'ceil_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!ceil_vec_ibeam)
		CHK(6, cleanup, L"[193] 	╠'ceil_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(ceil_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[193] 	╠'ceil_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[190] ceil_array←╠{╣");
	return err;
}

int
ptr8925(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[191] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[191] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[191] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[191] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[191] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[192] 	1289=⎕DR ╠⍵╣:-⌊-⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289=╠⎕DR╣ ⍵:-⌊-⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289=╠⎕DR ⍵╣:-⌊-⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[192] 	1289╠=╣⎕DR ⍵:-⌊-⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	╠1289╣=⎕DR ⍵:-⌊-⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	╠1289╣=⎕DR ⍵:-⌊-⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	╠1289=⎕DR ⍵╣:-⌊-⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289=⎕DR ╠⍵╣:-⌊-⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-⌊-╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-⌊╠-╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:-⌊╠-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.min)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:-╠⌊╣-⍵");
			
			*stkhd++ = retain_cell(cdf_prim.min);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:-╠⌊-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[192] 	1289=⎕DR ⍵:╠-╣⌊-⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289=⎕DR ⍵:╠-⌊-⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[193] 	'ceil_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!ceil_vec_ibeam)
		CHK(6, cleanup, L"[193] 	╠'ceil_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(ceil_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[193] 	╠'ceil_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[190] ceil_array←╠{╣");
	return err;
}

int
ptr8926(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[204] pitimes←{3.14159265358979323846×╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[204] pitimes←{3.14159265358979323846╠×╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592653589793};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[204] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[204] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[204] pitimes←{╠3.14159265358979323846×⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[204] pitimes←╠{3.14159265358979323846×⍵}╣");
	return err;
}

int
ptr8927(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[204] pitimes←{3.14159265358979323846×╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[204] pitimes←{3.14159265358979323846╠×╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592653589793};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[204] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[204] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[204] pitimes←{╠3.14159265358979323846×⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[204] pitimes←╠{3.14159265358979323846×⍵}╣");
	return err;
}

int
ptr8928(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[206] 	0≠≡╠⍺╣:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[206] 	0≠╠≡╣⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[206] 	0≠╠≡⍺╣:⍺ ∇¨⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[206] 	0╠≠╣≡⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[206] 	╠0╣≠≡⍺:⍺ ∇¨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[206] 	╠0╣≠≡⍺:⍺ ∇¨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[206] 	╠0≠≡⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[206] 	0≠≡╠⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ∇¨╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.map)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ∇╠¨╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.map);
			
			if (!self)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ╠∇╣¨⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[206] 	0≠≡⍺:⍺ ╠∇¨╣⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:╠⍺╣ ∇¨⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[206] 	0≠≡⍺:╠⍺ ∇¨⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[207] 	0=╠⍺╣:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[207] 	0╠=╣⍺:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[207] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[207] 	╠0=⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[207] 	0=╠⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:(1-╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[207] 	0=⍺:(1╠-╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:╠(1-⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:╠(1-⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[208] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[208] 	1╠=╣⍺:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[208] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[208] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[208] 	╠1=⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[208] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[208] 	1=⍺:'sin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sin_vec_ibeam)
				CHK(6, cleanup, L"[208] 	1=⍺:╠'sin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[208] 	1=⍺:╠'sin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[209] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[209] 	¯1╠=╣⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[209] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[209] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[209] 	╠¯1=⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[209] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[209] 	¯1=⍺:'arcsin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsin_vec_ibeam)
				CHK(6, cleanup, L"[209] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[209] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[210] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[210] 	2╠=╣⍺:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[210] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[210] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[210] 	╠2=⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[210] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[210] 	2=⍺:'cos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cos_vec_ibeam)
				CHK(6, cleanup, L"[210] 	2=⍺:╠'cos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[210] 	2=⍺:╠'cos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[211] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[211] 	¯2╠=╣⍺:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[211] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[211] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[211] 	╠¯2=⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[211] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[211] 	¯2=⍺:'arccos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccos_vec_ibeam)
				CHK(6, cleanup, L"[211] 	¯2=⍺:╠'arccos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[211] 	¯2=⍺:╠'arccos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[212] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[212] 	3╠=╣⍺:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[212] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[212] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[212] 	╠3=⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[212] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[212] 	3=⍺:'tan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tan_vec_ibeam)
				CHK(6, cleanup, L"[212] 	3=⍺:╠'tan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[212] 	3=⍺:╠'tan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[213] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[213] 	¯3╠=╣⍺:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[213] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[213] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[213] 	╠¯3=⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[213] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[213] 	¯3=⍺:'arctan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctan_vec_ibeam)
				CHK(6, cleanup, L"[213] 	¯3=⍺:╠'arctan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[213] 	¯3=⍺:╠'arctan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[214] 	4=╠⍺╣:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[214] 	4╠=╣⍺:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[214] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[214] 	╠4=⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[214] 	4=╠⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:(1+╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[214] 	4=⍺:(1╠+╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:╠(1+⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:╠(1+⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[215] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[215] 	¯4╠=╣⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	╠¯4=⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵╠+╣1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵╣+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)╠÷╣⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵╠-╣1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((╠⍵╣-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×(╠(⍵-1)╣÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)╠×╣((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵╠+╣1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(╠⍵╣+1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:╠(⍵+1)╣×((⍵-1)÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:╠(⍵+1)×((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[216] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[216] 	5╠=╣⍺:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[216] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[216] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[216] 	╠5=⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[216] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[216] 	5=⍺:'sinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sinh_vec_ibeam)
				CHK(6, cleanup, L"[216] 	5=⍺:╠'sinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[216] 	5=⍺:╠'sinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[217] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[217] 	¯5╠=╣⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[217] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[217] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[217] 	╠¯5=⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[217] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[217] 	¯5=⍺:'arcsinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[217] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[217] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[218] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[218] 	6╠=╣⍺:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[218] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[218] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[218] 	╠6=⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[218] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[218] 	6=⍺:'cosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cosh_vec_ibeam)
				CHK(6, cleanup, L"[218] 	6=⍺:╠'cosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[218] 	6=⍺:╠'cosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[219] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[219] 	¯6╠=╣⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[219] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[219] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[219] 	╠¯6=⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[219] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[219] 	¯6=⍺:'arccosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccosh_vec_ibeam)
				CHK(6, cleanup, L"[219] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[219] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[220] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[220] 	7╠=╣⍺:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[220] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[220] 	╠7=⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[220] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[220] 	7=⍺:'tanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tanh_vec_ibeam)
				CHK(6, cleanup, L"[220] 	7=⍺:╠'tanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[220] 	7=⍺:╠'tanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[221] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[221] 	¯7╠=╣⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[221] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[221] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[221] 	╠¯7=⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[221] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[221] 	¯7=⍺:'arctanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctanh_vec_ibeam)
				CHK(6, cleanup, L"[221] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[221] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[222] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[222] 	8╠=╣⍺:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	╠8=⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+⍵*2)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+⍵╠*╣2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+╠⍵╣*2)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:(-1+╠⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1╠+╣⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:(-╠1+⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[222] 	8=⍺:(╠-╣1+⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	8=⍺:╠(-1+⍵*2)╣*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:╠(-1+⍵*2)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[223] 	¯8=╠⍺╣:-8○⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[223] 	¯8╠=╣⍺:-8○⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	╠¯8╣=⍺:-8○⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[223] 	╠¯8╣=⍺:-8○⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	╠¯8=⍺╣:-8○⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[223] 	¯8=╠⍺╣:-8○⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[223] 	¯8=⍺:-8○╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cir)
				CHK(6, cleanup, L"[223] 	¯8=⍺:-8╠○╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	¯8=⍺:-╠8╣○⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[223] 	¯8=⍺:-╠8╣○⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[223] 	¯8=⍺:-╠8○⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[223] 	¯8=⍺:╠-╣8○⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[223] 	¯8=⍺:╠-8○⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[224] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[224] 	9╠=╣⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	╠9=⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8929, ptr8930, 0), cleanup, 
				    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[225] 	¯9=╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[225] 	¯9╠=╣⍺:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] 	╠¯9╣=⍺:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] 	╠¯9╣=⍺:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[225] 	╠¯9=⍺╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[225] 	¯9=╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[225] 	¯9=⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[226] 	10=╠⍺╣:|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[226] 	10╠=╣⍺:|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[226] 	╠10╣=⍺:|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[226] 	╠10╣=⍺:|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[226] 	╠10=⍺╣:|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[226] 	10=╠⍺╣:|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[226] 	10=⍺:|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[226] 	10=⍺:╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[226] 	10=⍺:╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[227] 	¯10=╠⍺╣:+⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[227] 	¯10╠=╣⍺:+⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	╠¯10╣=⍺:+⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[227] 	╠¯10╣=⍺:+⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[227] 	╠¯10=⍺╣:+⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[227] 	¯10=╠⍺╣:+⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[227] 	¯10=⍺:+╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[227] 	¯10=⍺:╠+╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[227] 	¯10=⍺:╠+⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[228] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[228] 	11╠=╣⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	╠11=⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8931, ptr8932, 0), cleanup, 
				    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[229] 	¯11=╠⍺╣:⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[229] 	¯11╠=╣⍺:⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	╠¯11╣=⍺:⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[229] 	╠¯11╣=⍺:⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[229] 	╠¯11=⍺╣:⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[229] 	¯11=╠⍺╣:⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	¯11=⍺:⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[229] 	¯11=⍺:⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[229] 	¯11=⍺:⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[229] 	¯11=⍺:╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[229] 	¯11=⍺:╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[230] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[230] 	12╠=╣⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[230] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[230] 	╠12=⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[230] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[231] 	¯12=╠⍺╣:*⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[231] 	¯12╠=╣⍺:*⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	╠¯12╣=⍺:*⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[231] 	╠¯12╣=⍺:*⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	╠¯12=⍺╣:*⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	¯12=╠⍺╣:*⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	¯12=⍺:*⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[231] 	¯12=⍺:*⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[231] 	¯12=⍺:*⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[231] 	¯12=⍺:*╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[231] 	¯12=⍺:*╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[231] 	¯12=⍺:╠*╣⍵×0J1");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[231] 	¯12=⍺:╠*⍵×0J1╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[232] 	⎕SIGNAL ╠11╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[232] 	⎕SIGNAL ╠11╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[232] 	╠⎕SIGNAL╣ 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[232] 	╠⎕SIGNAL 11╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[205] trig←╠{╣");
	return err;
}

int
ptr8929(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[224] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr8930(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[224] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr8931(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr8932(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr8933(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[206] 	0≠≡╠⍺╣:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[206] 	0≠╠≡╣⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[206] 	0≠╠≡⍺╣:⍺ ∇¨⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[206] 	0╠≠╣≡⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[206] 	╠0╣≠≡⍺:⍺ ∇¨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[206] 	╠0╣≠≡⍺:⍺ ∇¨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[206] 	╠0≠≡⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[206] 	0≠≡╠⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ∇¨╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.map)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ∇╠¨╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.map);
			
			if (!self)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:⍺ ╠∇╣¨⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[206] 	0≠≡⍺:⍺ ╠∇¨╣⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[206] 	0≠≡⍺:╠⍺╣ ∇¨⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[206] 	0≠≡⍺:╠⍺ ∇¨⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[207] 	0=╠⍺╣:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[207] 	0╠=╣⍺:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[207] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[207] 	╠0=⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[207] 	0=╠⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[207] 	0=⍺:(1-╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:(1-╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[207] 	0=⍺:(1╠-╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[207] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[207] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:╠(1-⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	0=⍺:╠(1-⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[208] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[208] 	1╠=╣⍺:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[208] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[208] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[208] 	╠1=⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[208] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[208] 	1=⍺:'sin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sin_vec_ibeam)
				CHK(6, cleanup, L"[208] 	1=⍺:╠'sin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[208] 	1=⍺:╠'sin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[209] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[209] 	¯1╠=╣⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[209] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[209] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[209] 	╠¯1=⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[209] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[209] 	¯1=⍺:'arcsin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsin_vec_ibeam)
				CHK(6, cleanup, L"[209] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[209] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[210] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[210] 	2╠=╣⍺:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[210] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[210] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[210] 	╠2=⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[210] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[210] 	2=⍺:'cos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cos_vec_ibeam)
				CHK(6, cleanup, L"[210] 	2=⍺:╠'cos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[210] 	2=⍺:╠'cos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[211] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[211] 	¯2╠=╣⍺:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[211] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[211] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[211] 	╠¯2=⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[211] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[211] 	¯2=⍺:'arccos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccos_vec_ibeam)
				CHK(6, cleanup, L"[211] 	¯2=⍺:╠'arccos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[211] 	¯2=⍺:╠'arccos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[212] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[212] 	3╠=╣⍺:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[212] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[212] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[212] 	╠3=⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[212] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[212] 	3=⍺:'tan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tan_vec_ibeam)
				CHK(6, cleanup, L"[212] 	3=⍺:╠'tan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[212] 	3=⍺:╠'tan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[213] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[213] 	¯3╠=╣⍺:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[213] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[213] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[213] 	╠¯3=⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[213] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[213] 	¯3=⍺:'arctan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctan_vec_ibeam)
				CHK(6, cleanup, L"[213] 	¯3=⍺:╠'arctan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[213] 	¯3=⍺:╠'arctan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[214] 	4=╠⍺╣:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[214] 	4╠=╣⍺:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[214] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[214] 	╠4=⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[214] 	4=╠⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[214] 	4=⍺:(1+╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:(1+╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[214] 	4=⍺:(1╠+╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[214] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[214] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:╠(1+⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[214] 	4=⍺:╠(1+⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[215] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[215] 	¯4╠=╣⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	╠¯4=⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵╠+╣1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵╣+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-1)╠÷╣⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((⍵╠-╣1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)×((╠⍵╣-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×(╠(⍵-1)╣÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵+1)╠×╣((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(⍵╠+╣1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[215] 	¯4=⍺:(╠⍵╣+1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:╠(⍵+1)╣×((⍵-1)÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[215] 	¯4=⍺:╠(⍵+1)×((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[216] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[216] 	5╠=╣⍺:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[216] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[216] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[216] 	╠5=⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[216] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[216] 	5=⍺:'sinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sinh_vec_ibeam)
				CHK(6, cleanup, L"[216] 	5=⍺:╠'sinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[216] 	5=⍺:╠'sinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[217] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[217] 	¯5╠=╣⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[217] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[217] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[217] 	╠¯5=⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[217] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[217] 	¯5=⍺:'arcsinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[217] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[217] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[218] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[218] 	6╠=╣⍺:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[218] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[218] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[218] 	╠6=⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[218] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[218] 	6=⍺:'cosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cosh_vec_ibeam)
				CHK(6, cleanup, L"[218] 	6=⍺:╠'cosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[218] 	6=⍺:╠'cosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[219] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[219] 	¯6╠=╣⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[219] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[219] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[219] 	╠¯6=⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[219] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[219] 	¯6=⍺:'arccosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccosh_vec_ibeam)
				CHK(6, cleanup, L"[219] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[219] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[220] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[220] 	7╠=╣⍺:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[220] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[220] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[220] 	╠7=⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[220] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[220] 	7=⍺:'tanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tanh_vec_ibeam)
				CHK(6, cleanup, L"[220] 	7=⍺:╠'tanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[220] 	7=⍺:╠'tanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[221] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[221] 	¯7╠=╣⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[221] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[221] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[221] 	╠¯7=⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[221] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[221] 	¯7=⍺:'arctanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctanh_vec_ibeam)
				CHK(6, cleanup, L"[221] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[221] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[222] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[222] 	8╠=╣⍺:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	╠8=⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+⍵*2)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+⍵╠*╣2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1+╠⍵╣*2)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:(-1+╠⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[222] 	8=⍺:(-1╠+╣⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:(-╠1+⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[222] 	8=⍺:(╠-╣1+⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	8=⍺:╠(-1+⍵*2)╣*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[222] 	8=⍺:╠(-1+⍵*2)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[223] 	¯8=╠⍺╣:-8○⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[223] 	¯8╠=╣⍺:-8○⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	╠¯8╣=⍺:-8○⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[223] 	╠¯8╣=⍺:-8○⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	╠¯8=⍺╣:-8○⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[223] 	¯8=╠⍺╣:-8○⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[223] 	¯8=⍺:-8○╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cir)
				CHK(6, cleanup, L"[223] 	¯8=⍺:-8╠○╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[223] 	¯8=⍺:-╠8╣○⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[223] 	¯8=⍺:-╠8╣○⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[223] 	¯8=⍺:-╠8○⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[223] 	¯8=⍺:╠-╣8○⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[223] 	¯8=⍺:╠-8○⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[224] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[224] 	9╠=╣⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	╠9=⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8934, ptr8935, 0), cleanup, 
				    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[225] 	¯9=╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[225] 	¯9╠=╣⍺:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] 	╠¯9╣=⍺:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] 	╠¯9╣=⍺:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[225] 	╠¯9=⍺╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[225] 	¯9=╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[225] 	¯9=⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[226] 	10=╠⍺╣:|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[226] 	10╠=╣⍺:|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[226] 	╠10╣=⍺:|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[226] 	╠10╣=⍺:|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[226] 	╠10=⍺╣:|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[226] 	10=╠⍺╣:|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[226] 	10=⍺:|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[226] 	10=⍺:╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[226] 	10=⍺:╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[227] 	¯10=╠⍺╣:+⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[227] 	¯10╠=╣⍺:+⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[227] 	╠¯10╣=⍺:+⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[227] 	╠¯10╣=⍺:+⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[227] 	╠¯10=⍺╣:+⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[227] 	¯10=╠⍺╣:+⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[227] 	¯10=⍺:+╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[227] 	¯10=⍺:╠+╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[227] 	¯10=⍺:╠+⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[228] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[228] 	11╠=╣⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	╠11=⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8936, ptr8937, 0), cleanup, 
				    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[229] 	¯11=╠⍺╣:⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[229] 	¯11╠=╣⍺:⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	╠¯11╣=⍺:⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[229] 	╠¯11╣=⍺:⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[229] 	╠¯11=⍺╣:⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[229] 	¯11=╠⍺╣:⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[229] 	¯11=⍺:⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[229] 	¯11=⍺:⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[229] 	¯11=⍺:⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[229] 	¯11=⍺:╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[229] 	¯11=⍺:╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[230] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[230] 	12╠=╣⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[230] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[230] 	╠12=⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[230] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[230] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[230] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[231] 	¯12=╠⍺╣:*⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[231] 	¯12╠=╣⍺:*⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	╠¯12╣=⍺:*⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[231] 	╠¯12╣=⍺:*⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	╠¯12=⍺╣:*⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	¯12=╠⍺╣:*⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[231] 	¯12=⍺:*⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[231] 	¯12=⍺:*⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[231] 	¯12=⍺:*⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[231] 	¯12=⍺:*╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[231] 	¯12=⍺:*╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[231] 	¯12=⍺:╠*╣⍵×0J1");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[231] 	¯12=⍺:╠*⍵×0J1╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[232] 	⎕SIGNAL ╠11╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[232] 	⎕SIGNAL ╠11╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[232] 	╠⎕SIGNAL╣ 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[232] 	╠⎕SIGNAL 11╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[205] trig←╠{╣");
	return err;
}

int
ptr8934(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[224] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr8935(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[224] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[224] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[224] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[224] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[224] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[224] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr8936(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr8937(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[228] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[228] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr8938(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠╠⌊╣⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠╠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺╠≠╣⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!alpha)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧╠⍺╣≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧╠⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)╠∧╣⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<╠0╣)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<╠0╣)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵╠<╣0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(╠⍵╣<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧╠(⍵<0)╣∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧╠(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)╠∧╣(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊╠⍵╣)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=╠⌊╣⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=╠⌊⍵)╣∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵╠=╣⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(╠⍵╣=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,╠(⍵=⌊⍵)╣∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,╠(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[238] 	∨⌿╠,╣(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿╠,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[238] 	∨╠⌿╣,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[238] 	╠∨╣⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[238] 	╠∨⌿╣,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	╠∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!⍵-╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!⍵╠-╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!╠⍵╣-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	(!⍵)÷(!⍺)×!╠⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×╠!╣⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	(!⍵)÷(!⍺)×╠!⍵-⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)╠×╣!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!╠⍺╣)×!⍵-⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(╠!╣⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	(!⍵)÷╠(!⍺)╣×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	(!⍵)÷╠(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[239] 	(!⍵)╠÷╣(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[239] 	(!╠⍵╣)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(╠!╣⍵)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	╠(!⍵)╣÷(!⍺)×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	╠(!⍵)÷(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] binomial←╠{╣");
	return err;
}

int
ptr8939(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠╠⌊╣⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠╠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺╠≠╣⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!alpha)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧╠⍺╣≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧╠⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)╠∧╣⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<╠0╣)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<╠0╣)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵╠<╣0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(╠⍵╣<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧╠(⍵<0)╣∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=⌊⍵)∧╠(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)╠∧╣(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊╠⍵╣)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵=╠⌊╣⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿,(⍵=╠⌊⍵)╣∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[238] 	∨⌿,(⍵╠=╣⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	if (!omega)
		CHK(6, cleanup, L"[238] 	∨⌿,(╠⍵╣=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,╠(⍵=⌊⍵)╣∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[238] 	∨⌿,╠(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[238] 	∨⌿╠,╣(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	∨⌿╠,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[238] 	∨╠⌿╣,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[238] 	╠∨╣⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[238] 	╠∨⌿╣,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] 	╠∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[238] 	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!⍵-╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!⍵╠-╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×!╠⍵╣-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	(!⍵)÷(!⍺)×!╠⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)×╠!╣⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	(!⍵)÷(!⍺)×╠!⍵-⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!⍺)╠×╣!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(!╠⍺╣)×!⍵-⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(!⍵)÷(╠!╣⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	(!⍵)÷╠(!⍺)╣×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	(!⍵)÷╠(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[239] 	(!⍵)╠÷╣(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[239] 	(!╠⍵╣)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[239] 	(╠!╣⍵)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] 	╠(!⍵)╣÷(!⍺)×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] 	╠(!⍵)÷(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[237] binomial←╠{╣");
	return err;
}

int
ptr8940(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[244] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[244] notscl←{╠is_bool╣ ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] notscl←{╠is_bool ⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[244] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!not_vec_ibeam)
				CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[244] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[244] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8941(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[244] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[244] notscl←{╠is_bool╣ ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] notscl←{╠is_bool ⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[244] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!not_vec_ibeam)
				CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[244] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[244] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8942(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[245] without←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[245] without←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[245] without←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[245] without←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[245] without←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8943(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[245] without←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[245] without←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[245] without←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[245] without←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[245] without←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8944(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->z = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[250] 	⍺ ╠both_bool╣ ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[250] 	╠⍺╣ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[250] 	╠⍺ both_bool ⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[250] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!and_vec_ibeam)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:⍺╠('and_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(and_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:╠⍺╣('and_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[250] 	⍺ both_bool ⍵:╠⍺('and_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←⍺∨╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←⍺╠∨╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	if (!alpha)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←╠⍺╣∨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷z+0=z←╠⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z);
	loc->z = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0╠=╣z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	⍺×⍵÷z+╠0╣=z←⍺∨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[251] 	⍺×⍵÷z+╠0╣=z←⍺∨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷z+╠0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z╠+╣0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->z)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷╠z╣+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(loc->z);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷╠z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[251] 	⍺×⍵╠÷╣z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[251] 	⍺×╠⍵╣÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×╠⍵÷z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[251] 	⍺╠×╣⍵÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[251] 	╠⍺╣×⍵÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	╠⍺×⍵÷z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] logand←╠{╣");
	return err;
}

int
ptr8945(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	loc->z = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[250] 	⍺ ╠both_bool╣ ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[250] 	╠⍺╣ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[250] 	╠⍺ both_bool ⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[250] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!and_vec_ibeam)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:⍺╠('and_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(and_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[250] 	⍺ both_bool ⍵:╠⍺╣('and_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[250] 	⍺ both_bool ⍵:╠⍺('and_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←⍺∨╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←⍺╠∨╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	if (!alpha)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0=z←╠⍺╣∨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷z+0=z←╠⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z);
	loc->z = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z+0╠=╣z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[251] 	⍺×⍵÷z+╠0╣=z←⍺∨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[251] 	⍺×⍵÷z+╠0╣=z←⍺∨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷z+╠0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷z╠+╣0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->z)
		CHK(6, cleanup, L"[251] 	⍺×⍵÷╠z╣+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(loc->z);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×⍵÷╠z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[251] 	⍺×⍵╠÷╣z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[251] 	⍺×╠⍵╣÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	⍺×╠⍵÷z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[251] 	⍺╠×╣⍵÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[251] 	╠⍺╣×⍵÷z+0=z←⍺∨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[251] 	╠⍺×⍵÷z+0=z←⍺∨⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] logand←╠{╣");
	return err;
}

int
ptr8946(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[253] and←{⎕SIGNAL ╠2╣}ambiv (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[253] and←{⎕SIGNAL ╠2╣}ambiv (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[253] and←{╠⎕SIGNAL╣ 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[253] and←{╠⎕SIGNAL 2╣}ambiv (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] and←╠{⎕SIGNAL 2}╣ambiv (logand numeric scalar)");
	return err;
}

int
ptr8947(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[253] and←{⎕SIGNAL ╠2╣}ambiv (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[253] and←{⎕SIGNAL ╠2╣}ambiv (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[253] and←{╠⎕SIGNAL╣ 2}ambiv (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[253] and←{╠⎕SIGNAL 2╣}ambiv (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] and←╠{⎕SIGNAL 2}╣ambiv (logand numeric scalar)");
	return err;
}

int
ptr8948(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
		struct cell_func_box *both_integer;
		struct cell_func_box *is_bool;
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[257] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[257] 	⍺ ╠both_bool╣ ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[257] 	╠⍺╣ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[257] 	╠⍺ both_bool ⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[257] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lor_vec_ibeam)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:⍺╠('lor_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(lor_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:╠⍺╣('lor_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[257] 	⍺ both_bool ⍵:╠⍺('lor_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ╠⍵╣:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧╠is_integer╣ ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] 	(is_bool ⍺)∧╠is_integer ⍵╣:⍺+(~⍺)×|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)╠∧╣is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!alpha)
		CHK(6, cleanup, L"[258] 	(is_bool ╠⍺╣)∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[258] 	(╠is_bool╣ ⍺)∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] 	╠(is_bool ⍺)╣∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[258] 	╠(is_bool ⍺)∧is_integer ⍵╣:⍺+(~⍺)×|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[258] 	(is_bool ⍺)∧is_integer ╠⍵╣:⍺+(~⍺)×|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)╠×╣|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!alpha)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~╠⍺╣)×|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(╠~╣⍺)×|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+╠(~⍺)╣×|⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+╠(~⍺)×|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺╠+╣(~⍺)×|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!alpha)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:╠⍺╣+(~⍺)×|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:╠⍺+(~⍺)×|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ╠⍺╣:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧╠is_integer╣ ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	(is_bool ⍵)∧╠is_integer ⍺╣:⍵+(~⍵)×|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)╠∧╣is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	(is_bool ╠⍵╣)∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[259] 	(╠is_bool╣ ⍵)∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	╠(is_bool ⍵)╣∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠(is_bool ⍵)∧is_integer ⍺╣:⍵+(~⍵)×|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	(is_bool ⍵)∧is_integer ╠⍺╣:⍵+(~⍵)×|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×|╠⍺╣");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×╠|╣⍺");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×╠|⍺╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)╠×╣|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~╠⍵╣)×|⍺");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(╠~╣⍵)×|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+╠(~⍵)╣×|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+╠(~⍵)×|⍺╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵╠+╣(~⍵)×|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:╠⍵╣+(~⍵)×|⍺");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:╠⍵+(~⍵)×|⍺╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ╠⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_integer->value)
		CHK(6, cleanup, L"[260] 	⍺ ╠both_integer╣ ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(lex->both_integer->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	╠⍺╣ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠⍺ both_integer ⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ╠⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8949, ptr8950, 0), cleanup, 
				    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
			
				*stkhd++ = k;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|╠⍺╣){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(╠|╣⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:╠(|⍺)╣{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:╠(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8951, ptr8952, 0), cleanup, 
		    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	
		*stkhd++ = k;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|╠⍺╣){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(╠|╣⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	╠(|⍺)╣{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	╠(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] logor←╠{╣");
	return err;
}

int
ptr8949(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵╠≠╣0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵╣≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨╠⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨╣⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){╠~╣∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){╠~∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ⍵:╠(|⍺)╣{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8950(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵╠≠╣0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵╣≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨╠⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨╣⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){╠~╣∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){╠~∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8951(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵╠>╣1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←╠⍵╣>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←╠⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨╠⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[261] 	(|⍺){~╠∨╣⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){╠~╣∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){╠~∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[261] 	╠(|⍺)╣{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8952(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵╠>╣1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←╠⍵╣>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←╠⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨╠⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[261] 	(|⍺){~╠∨╣⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){╠~╣∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){╠~∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8953(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *both_bool;
		struct cell_func_box *both_integer;
		struct cell_func_box *is_bool;
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[257] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[257] 	⍺ ╠both_bool╣ ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[257] 	╠⍺╣ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[257] 	╠⍺ both_bool ⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[257] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lor_vec_ibeam)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:⍺╠('lor_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(lor_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[257] 	⍺ both_bool ⍵:╠⍺╣('lor_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[257] 	⍺ both_bool ⍵:╠⍺('lor_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ╠⍵╣:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧╠is_integer╣ ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] 	(is_bool ⍺)∧╠is_integer ⍵╣:⍺+(~⍺)×|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[258] 	(is_bool ⍺)╠∧╣is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!alpha)
		CHK(6, cleanup, L"[258] 	(is_bool ╠⍺╣)∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[258] 	(╠is_bool╣ ⍺)∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[258] 	╠(is_bool ⍺)╣∧is_integer ⍵:⍺+(~⍺)×|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[258] 	╠(is_bool ⍺)∧is_integer ⍵╣:⍺+(~⍺)×|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[258] 	(is_bool ⍺)∧is_integer ╠⍵╣:⍺+(~⍺)×|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)╠×╣|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!alpha)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(~╠⍺╣)×|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+(╠~╣⍺)×|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+╠(~⍺)╣×|⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺+╠(~⍺)×|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:⍺╠+╣(~⍺)×|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!alpha)
				CHK(6, cleanup, L"[258] 	(is_bool ⍺)∧is_integer ⍵:╠⍺╣+(~⍺)×|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[258] 	(is_bool ⍺)∧is_integer ⍵:╠⍺+(~⍺)×|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ╠⍺╣:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧╠is_integer╣ ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	(is_bool ⍵)∧╠is_integer ⍺╣:⍵+(~⍵)×|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[259] 	(is_bool ⍵)╠∧╣is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	(is_bool ╠⍵╣)∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[259] 	(╠is_bool╣ ⍵)∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	╠(is_bool ⍵)╣∧is_integer ⍺:⍵+(~⍵)×|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠(is_bool ⍵)∧is_integer ⍺╣:⍵+(~⍵)×|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	(is_bool ⍵)∧is_integer ╠⍺╣:⍵+(~⍵)×|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×|╠⍺╣");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×╠|╣⍺");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×╠|⍺╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)╠×╣|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(~╠⍵╣)×|⍺");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+(╠~╣⍵)×|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+╠(~⍵)╣×|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵+╠(~⍵)×|⍺╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:⍵╠+╣(~⍵)×|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[259] 	(is_bool ⍵)∧is_integer ⍺:╠⍵╣+(~⍵)×|⍺");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[259] 	(is_bool ⍵)∧is_integer ⍺:╠⍵+(~⍵)×|⍺╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ╠⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_integer->value)
		CHK(6, cleanup, L"[260] 	⍺ ╠both_integer╣ ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(lex->both_integer->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	╠⍺╣ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠⍺ both_integer ⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ╠⍵╣:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr8954, ptr8955, 0), cleanup, 
				    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
			
				*stkhd++ = k;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|╠⍺╣){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(╠|╣⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:╠(|⍺)╣{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[260] 	⍺ both_integer ⍵:╠(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╠|⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr8956, ptr8957, 0), cleanup, 
		    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	
		*stkhd++ = k;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|╠⍺╣){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(╠|╣⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	╠(|⍺)╣{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	╠(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] logor←╠{╣");
	return err;
}

int
ptr8954(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵╠≠╣0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵╣≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨╠⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨╣⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){╠~╣∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){╠~∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ⍵:╠(|⍺)╣{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8955(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠╠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵╠≠╣0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵╣≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←╠⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨╠⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨╣⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿╣m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~╠∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){╠~╣∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){╠~∨⌿m←⍵≠0╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	⍺ both_integer ⍵:(|⍺)╠{~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8956(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵╠>╣1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←╠⍵╣>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←╠⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨╠⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[261] 	(|⍺){~╠∨╣⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){╠~╣∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){╠~∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[261] 	╠(|⍺)╣{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8957(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct {
		struct cell_array *m;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->m = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {1E-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>╠1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.gth)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵╠>╣1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.gth);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←╠⍵╣>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←╠⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->m);
	loc->m = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨╠⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!cdf_prim.lor)
		CHK(6, cleanup, L"[261] 	(|⍺){~╠∨╣⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿╣m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~╠∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){╠~╣∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){╠~∨⌿m←⍵>1e¯12╣:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alpha)
				CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:╠⍺╣ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|╠⍺╣}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵╠|╣⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵╣|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×╠⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m╠×╣⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m╣×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+╠m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)╠+╣m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~╠m╣)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~╣m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×╠~m)╣+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵╠×╣~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(╠⍵╣×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)╣+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇╠(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!self)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)╠∇╣(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(self);
	
	if (!omega)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×╠⍵╣)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m╠×╣⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m╣×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+╠m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)╠+╣m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!loc->m)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~╠m╣)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(loc->m);
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~╣m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×╠~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺╠×╣~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((╠⍺╣×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ (╠(⍺×~m)╣+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)╣∇(⍵×~m)+m×⍵|⍺}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[261] 	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ╠((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺╣}|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[261] 	(|⍺)╠{~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}╣|⍵");
	return err;
}

int
ptr8958(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] lor←{⎕SIGNAL ╠2╣}ambiv (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[263] lor←{⎕SIGNAL ╠2╣}ambiv (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[263] lor←{╠⎕SIGNAL╣ 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] lor←{╠⎕SIGNAL 2╣}ambiv (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[263] lor←╠{⎕SIGNAL 2}╣ambiv (logor numeric scalar)");
	return err;
}

int
ptr8959(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] lor←{⎕SIGNAL ╠2╣}ambiv (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[263] lor←{⎕SIGNAL ╠2╣}ambiv (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[263] lor←{╠⎕SIGNAL╣ 2}ambiv (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] lor←{╠⎕SIGNAL 2╣}ambiv (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[263] lor←╠{⎕SIGNAL 2}╣ambiv (logor numeric scalar)");
	return err;
}

int
ptr8960(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] nan←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] nan←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[266] nan←{╠⎕SIGNAL╣ 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] nan←{╠⎕SIGNAL 2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] nan←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr8961(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] nan←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] nan←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[266] nan←{╠⎕SIGNAL╣ 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] nan←{╠⎕SIGNAL 2╣}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] nan←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr8962(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ ╠both_bool╣ ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{╠⍺╣ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[266] nan←{⎕SIGNAL 2}ambiv{╠⍺ both_bool ⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.and)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺╠∧╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.and);
			
			if (!alpha)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺╣∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~╣⍺∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] nan←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8963(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ ╠both_bool╣ ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{╠⍺╣ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[266] nan←{⎕SIGNAL 2}ambiv{╠⍺ both_bool ⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.and)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺╠∧╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.and);
			
			if (!alpha)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺╣∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~╣⍺∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[266] nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[266] nan←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8964(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[269] nor←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[269] nor←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[269] nor←{╠⎕SIGNAL╣ 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[269] nor←{╠⎕SIGNAL 2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] nor←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr8965(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[269] nor←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[269] nor←{⎕SIGNAL ╠2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[269] nor←{╠⎕SIGNAL╣ 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[269] nor←{╠⎕SIGNAL 2╣}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] nor←╠{⎕SIGNAL 2}╣ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr8966(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ ╠both_bool╣ ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{╠⍺╣ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[269] nor←{⎕SIGNAL 2}ambiv{╠⍺ both_bool ⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.lor)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺╠∨╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.lor);
			
			if (!alpha)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺╣∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~╣⍺∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] nor←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8967(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ ╠both_bool╣ ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{╠⍺╣ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[269] nor←{⎕SIGNAL 2}ambiv{╠⍺ both_bool ⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.lor)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺╠∨╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.lor);
			
			if (!alpha)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺╣∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~╠⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~╣⍺∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:╠~⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[269] nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[269] nor←{⎕SIGNAL 2}ambiv╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr8968(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[273] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[274] 	⍺('lth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lth_vec_ibeam)
		CHK(6, cleanup, L"[274] 	⍺╠('lth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[274] 	╠⍺╣('lth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	╠⍺('lth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[272] lessthan←╠{╣");
	return err;
}

int
ptr8969(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[273] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[273] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[274] 	⍺('lth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lth_vec_ibeam)
		CHK(6, cleanup, L"[274] 	⍺╠('lth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[274] 	╠⍺╣('lth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[274] 	╠⍺('lth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[272] lessthan←╠{╣");
	return err;
}

int
ptr8970(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[276] lth←{⎕SIGNAL ╠2╣} ambiv (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[276] lth←{⎕SIGNAL ╠2╣} ambiv (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[276] lth←{╠⎕SIGNAL╣ 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[276] lth←{╠⎕SIGNAL 2╣} ambiv (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] lth←╠{⎕SIGNAL 2}╣ ambiv (lessthan numeric scalar)");
	return err;
}

int
ptr8971(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[276] lth←{⎕SIGNAL ╠2╣} ambiv (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[276] lth←{⎕SIGNAL ╠2╣} ambiv (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[276] lth←{╠⎕SIGNAL╣ 2} ambiv (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[276] lth←{╠⎕SIGNAL 2╣} ambiv (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] lth←╠{⎕SIGNAL 2}╣ ambiv (lessthan numeric scalar)");
	return err;
}

int
ptr8972(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[280] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[280] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[281] 	⍺('lte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lte_vec_ibeam)
		CHK(6, cleanup, L"[281] 	⍺╠('lte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[281] 	╠⍺╣('lte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠⍺('lte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] lesseql←╠{╣");
	return err;
}

int
ptr8973(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[280] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[280] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[281] 	⍺('lte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lte_vec_ibeam)
		CHK(6, cleanup, L"[281] 	⍺╠('lte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[281] 	╠⍺╣('lte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠⍺('lte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[279] lesseql←╠{╣");
	return err;
}

int
ptr8974(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[283] lte←{⎕SIGNAL ╠2╣}ambiv (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[283] lte←{⎕SIGNAL ╠2╣}ambiv (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[283] lte←{╠⎕SIGNAL╣ 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[283] lte←{╠⎕SIGNAL 2╣}ambiv (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[283] lte←╠{⎕SIGNAL 2}╣ambiv (lesseql numeric scalar)");
	return err;
}

int
ptr8975(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[283] lte←{⎕SIGNAL ╠2╣}ambiv (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[283] lte←{⎕SIGNAL ╠2╣}ambiv (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[283] lte←{╠⎕SIGNAL╣ 2}ambiv (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[283] lte←{╠⎕SIGNAL 2╣}ambiv (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[283] lte←╠{⎕SIGNAL 2}╣ambiv (lesseql numeric scalar)");
	return err;
}

int
ptr8976(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *eql_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[288] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[288] 	⍺ ╠both_numeric╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[288] 	╠⍺╣ both_numeric ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[288] 	╠⍺ both_numeric ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[288] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[288] 	⍺ both_numeric ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[289] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[289] 	⍺ ╠both_char╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[289] 	╠⍺╣ both_char ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[289] 	╠⍺ both_char ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[289] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[289] 	⍺ both_char ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[290] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[290] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[287] equal←╠{╣");
	return err;
}

int
ptr8977(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *eql_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[288] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[288] 	⍺ ╠both_numeric╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[288] 	╠⍺╣ both_numeric ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[288] 	╠⍺ both_numeric ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[288] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[288] 	⍺ both_numeric ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[288] 	⍺ both_numeric ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[289] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[289] 	⍺ ╠both_char╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[289] 	╠⍺╣ both_char ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[289] 	╠⍺ both_char ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[289] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[289] 	⍺ both_char ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[289] 	⍺ both_char ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[290] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[290] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[287] equal←╠{╣");
	return err;
}

int
ptr8978(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[292] eql←{⎕SIGNAL ╠2╣}ambiv (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[292] eql←{⎕SIGNAL ╠2╣}ambiv (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[292] eql←{╠⎕SIGNAL╣ 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[292] eql←{╠⎕SIGNAL 2╣}ambiv (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[292] eql←╠{⎕SIGNAL 2}╣ambiv (equal scalar)");
	return err;
}

int
ptr8979(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[292] eql←{⎕SIGNAL ╠2╣}ambiv (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[292] eql←{⎕SIGNAL ╠2╣}ambiv (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[292] eql←{╠⎕SIGNAL╣ 2}ambiv (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[292] eql←{╠⎕SIGNAL 2╣}ambiv (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[292] eql←╠{⎕SIGNAL 2}╣ambiv (equal scalar)");
	return err;
}

int
ptr8980(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[296] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[296] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[296] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[296] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[296] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[297] 	⍺('gte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gte_vec_ibeam)
		CHK(6, cleanup, L"[297] 	⍺╠('gte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[297] 	╠⍺╣('gte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[297] 	╠⍺('gte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[295] greatereql←╠{╣");
	return err;
}

int
ptr8981(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[296] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[296] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[296] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[296] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[296] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[296] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[297] 	⍺('gte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gte_vec_ibeam)
		CHK(6, cleanup, L"[297] 	⍺╠('gte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[297] 	╠⍺╣('gte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[297] 	╠⍺('gte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[295] greatereql←╠{╣");
	return err;
}

int
ptr8982(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[299] gte←{⎕SIGNAL ╠2╣}ambiv (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[299] gte←{⎕SIGNAL ╠2╣}ambiv (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[299] gte←{╠⎕SIGNAL╣ 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[299] gte←{╠⎕SIGNAL 2╣}ambiv (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[299] gte←╠{⎕SIGNAL 2}╣ambiv (greatereql numeric scalar)");
	return err;
}

int
ptr8983(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[299] gte←{⎕SIGNAL ╠2╣}ambiv (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[299] gte←{⎕SIGNAL ╠2╣}ambiv (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[299] gte←{╠⎕SIGNAL╣ 2}ambiv (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[299] gte←{╠⎕SIGNAL 2╣}ambiv (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[299] gte←╠{⎕SIGNAL 2}╣ambiv (greatereql numeric scalar)");
	return err;
}

int
ptr8984(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[303] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[303] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[303] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[303] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[303] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[303] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[304] 	⍺('gth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gth_vec_ibeam)
		CHK(6, cleanup, L"[304] 	⍺╠('gth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[304] 	╠⍺╣('gth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[304] 	╠⍺('gth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[302] greaterthan←╠{╣");
	return err;
}

int
ptr8985(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[303] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[303] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[303] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[303] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[303] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[303] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[303] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[304] 	⍺('gth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gth_vec_ibeam)
		CHK(6, cleanup, L"[304] 	⍺╠('gth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[304] 	╠⍺╣('gth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[304] 	╠⍺('gth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[302] greaterthan←╠{╣");
	return err;
}

int
ptr8986(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[306] gth←{⎕SIGNAL ╠2╣}ambiv (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[306] gth←{⎕SIGNAL ╠2╣}ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[306] gth←{╠⎕SIGNAL╣ 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[306] gth←{╠⎕SIGNAL 2╣}ambiv (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[306] gth←╠{⎕SIGNAL 2}╣ambiv (greaterthan numeric scalar)");
	return err;
}

int
ptr8987(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[306] gth←{⎕SIGNAL ╠2╣}ambiv (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[306] gth←{⎕SIGNAL ╠2╣}ambiv (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[306] gth←{╠⎕SIGNAL╣ 2}ambiv (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[306] gth←{╠⎕SIGNAL 2╣}ambiv (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[306] gth←╠{⎕SIGNAL 2}╣ambiv (greaterthan numeric scalar)");
	return err;
}

int
ptr8988(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] firstocc←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] firstocc←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[309] firstocc←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] firstocc←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[309] firstocc←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8989(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[309] firstocc←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[309] firstocc←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[309] firstocc←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[309] firstocc←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[309] firstocc←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8990(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *neq_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[312] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[312] 	⍺ ╠both_numeric╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[312] 	╠⍺╣ both_numeric ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[312] 	╠⍺ both_numeric ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[312] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[312] 	⍺ both_numeric ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[313] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[313] 	⍺ ╠both_char╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[313] 	╠⍺╣ both_char ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[313] 	╠⍺ both_char ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[313] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[313] 	⍺ both_char ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[314] 	╠1╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[314] 	╠1╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[311] noteq←╠{╣");
	return err;
}

int
ptr8991(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *neq_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[312] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[312] 	⍺ ╠both_numeric╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[312] 	╠⍺╣ both_numeric ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[312] 	╠⍺ both_numeric ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[312] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[312] 	⍺ both_numeric ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[312] 	⍺ both_numeric ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[313] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[313] 	⍺ ╠both_char╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[313] 	╠⍺╣ both_char ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[313] 	╠⍺ both_char ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[313] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[313] 	⍺ both_char ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[313] 	⍺ both_char ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[314] 	╠1╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[314] 	╠1╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[311] noteq←╠{╣");
	return err;
}

int
ptr8992(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[319] mix←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[319] mix←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[319] mix←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[319] mix←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[319] mix←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8993(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[319] mix←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[319] mix←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[319] mix←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[319] mix←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[319] mix←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8994(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[320] take←{(⊂⍳⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[320] take←{(⊂⍳⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[320] take←{(⊂⍳╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[320] take←{(⊂╠⍳╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[320] take←{(⊂╠⍳⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[320] take←{(╠⊂╣⍳⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[320] take←{╠(⊂⍳⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[320] take←{╠(⊂⍳⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[320] take←╠{(⊂⍳⍺)⌷⍵}╣");
	return err;
}

int
ptr8995(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[320] take←{(⊂⍳⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[320] take←{(⊂⍳⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[320] take←{(⊂⍳╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[320] take←{(⊂╠⍳╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[320] take←{(⊂╠⍳⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[320] take←{(╠⊂╣⍳⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[320] take←{╠(⊂⍳⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[320] take←{╠(⊂⍳⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[320] take←╠{(⊂⍳⍺)⌷⍵}╣");
	return err;
}

int
ptr8996(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[324] split←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[324] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[324] split←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[324] split←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[324] split←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8997(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[324] split←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[324] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[324] split←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[324] split←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[324] split←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr8998(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)╠-╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢╠⍵╣)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(╠≢╣⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+╠⍳╣(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺╠+╣⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[325] drop←{(⊂╠⍺╣+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[325] drop←{(╠⊂╣⍺+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[325] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	return err;
}

int
ptr8999(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)-╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢⍵)╠-╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(≢╠⍵╣)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+⍳(╠≢╣⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺+╠⍳╣(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[325] drop←{(⊂⍺╠+╣⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[325] drop←{(⊂╠⍺╣+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[325] drop←{(╠⊂╣⍺+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[325] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[325] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[325] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	return err;
}

int
ptr9000(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢╠⍵╣)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳╠≢╣⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+╠⍳╣≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1╠+╣⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[329] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[329] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)╠-╣1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢╠⍵╣)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(╠≢╣⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[329] reverse_last←{(╠⊂╣(≢⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[329] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	return err;
}

int
ptr9001(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳≢╠⍵╣)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+⍳╠≢╣⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1+╠⍳╣≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)-1╠+╣⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[329] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[329] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢⍵)╠-╣1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(≢╠⍵╣)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[329] reverse_last←{(⊂(╠≢╣⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[329] reverse_last←{(╠⊂╣(≢⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[329] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[329] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[329] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	return err;
}

int
ptr9002(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[330] rotate_last←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[330] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[330] rotate_last←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[330] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[330] rotate_last←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr9003(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[330] rotate_last←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[330] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[330] rotate_last←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[330] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[330] rotate_last←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr9004(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[334] com←{2╠=╣⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{╠2=⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alphaalpha)
				CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':╠⍺⍺╣ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←╠⍵╣ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ╠⍺⍺╣ ⍺}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵╣ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[334] com←╠{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}╣");
	return err;
}

int
ptr9005(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[334] com←{2╠=╣⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{╠2=⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alphaalpha)
				CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':╠⍺⍺╣ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ╠⍺⍺╣ ⍺}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵╣ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[334] com←╠{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}╣");
	return err;
}

int
ptr9006(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[334] com←{2╠=╣⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{╠2=⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alphaalpha)
				CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':╠⍺⍺╣ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←╠⍵╣ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ╠⍺⍺╣ ⍺}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵╣ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[334] com←╠{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}╣");
	return err;
}

int
ptr9007(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		arr->shape[0] = 1;
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[334] com←{2╠=╣⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		CHK(fill_array(arr, dat), cleanup, L"[334] com←{╠2╣=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{╠2=⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[334] com←{2=╠⎕NC'⍺⍺'╣:⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!alphaalpha)
				CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':╠⍺⍺╣ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ╠⍺⍺╣ ⍺}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!omega)
		CHK(6, cleanup, L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵╣ ⍺⍺ ⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[334] com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ╠⍵ ⍺⍺ ⍺╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[334] com←╠{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}╣");
	return err;
}

int
ptr9008(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[337] map←{⍺←╠⊢╣ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ ╠veach╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺╣ veach ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺ veach╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺╣ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze╣ ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] map←╠{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}╣");
	return err;
}

int
ptr9009(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ ╠veach╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺╣ veach ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺╣ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺╣ veach ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺╣ veach ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺ veach╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze╣ ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] map←╠{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}╣");
	return err;
}

int
ptr9010(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[337] map←{⍺←╠⊢╣ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ ╠veach╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺╣ veach ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺ veach╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺╣ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze╣ ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] map←╠{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}╣");
	return err;
}

int
ptr9011(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_moper_box *veach;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->veach->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ ╠veach╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->veach->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺╣ veach ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ╠⍺⍺ veach╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺╣ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ╠⍺ ⍺⍺ veach ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze╣ ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴squeeze ⍺ ⍺⍺ veach ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[337] map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴squeeze ⍺ ⍺⍺ veach ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[337] map←╠{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}╣");
	return err;
}

int
ptr9012(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[341] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[341] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->zs);
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0╠≡╣c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	╠0≡c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!identity_ibeam)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺╠('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(identity_ibeam);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴╠⍺⍺╣('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs╠⍴╣⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:╠zs╣⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:╠zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9013, ptr9014, 2), cleanup, 
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->op);
		k->fv[1] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[343] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[343] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[343] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[340] reduce←╠{╣");
	return err;
}

int
ptr9013(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9014(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9015(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[341] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[341] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->zs);
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0╠≡╣c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	╠0≡c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!identity_ibeam)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺╠('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(identity_ibeam);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴╠⍺⍺╣('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs╠⍴╣⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:╠zs╣⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:╠zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9016, ptr9017, 2), cleanup, 
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->op);
		k->fv[1] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[343] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[343] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[343] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[340] reduce←╠{╣");
	return err;
}

int
ptr9016(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9017(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9018(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[341] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[341] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->zs);
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0╠≡╣c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	╠0≡c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!identity_ibeam)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺╠('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(identity_ibeam);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴╠⍺⍺╣('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs╠⍴╣⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:╠zs╣⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:╠zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9019, ptr9020, 2), cleanup, 
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->op);
		k->fv[1] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[343] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[343] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[343] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[340] reduce←╠{╣");
	return err;
}

int
ptr9019(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9020(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9021(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[341] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[341] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[341] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[341] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->s);
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->c);
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[341] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->zs);
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0╠≡╣c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	╠0╣≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	╠0≡c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡╠c╣:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)╠⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!identity_ibeam)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺╠('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(identity_ibeam);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴╠⍺⍺╣('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)╣⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴╠⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs╠⍴╣⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:╠zs╣⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:╠zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[342] 	0≡c:zs⍴⍺⍺('identity_ibeam'⌶⌶)⍬ ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9022, ptr9023, 2), cleanup, 
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->op);
		k->fv[1] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[343] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[343] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[343] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[340] reduce←╠{╣");
	return err;
}

int
ptr9022(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9023(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z╣⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[343] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[343] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[343] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[343] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr9024(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[345] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[345] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[345] nwreduce←{op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[346] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[346] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rc->value);
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc╣-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9025, ptr9026, 3), cleanup, 
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->op);
		k->fv[2] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[347] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[347] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr9025(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9026(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9027(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[345] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[345] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[345] nwreduce←{op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[346] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[346] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rc->value);
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc╣-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9028, ptr9029, 3), cleanup, 
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->op);
		k->fv[2] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[347] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[347] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr9028(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9029(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9030(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[345] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[345] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[345] nwreduce←{op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[346] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[346] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rc->value);
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc╣-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9031, ptr9032, 3), cleanup, 
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->op);
		k->fv[2] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[347] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[347] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr9031(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9032(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9033(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[345] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[345] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[345] nwreduce←{op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	release_cell(loc->op->value);
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[346] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[346] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->rc->value);
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc╣-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[346] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	release_cell(loc->z->value);
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9034, ptr9035, 3), cleanup, 
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->op);
		k->fv[2] = retain_cell(loc->z);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[347] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[347] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[347] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[347] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[345] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr9034(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9035(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	if (!lex->z->value)
		CHK(6, cleanup, L"[347] 	z⊣(⌽⍳⍺-1){╠z╣⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *orig = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[347] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(orig);
		release_array(x);
		release_func(fn);
		stkhd -= 2;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[347] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr9036(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[349] rdf←{⍺←╠⊢╣ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡╠⍺╣ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[350] 	1╠≡╣⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	╠1≡⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr9037(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡╠⍺╣ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[350] 	1╠≡╣⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	╠1≡⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr9038(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[349] rdf←{⍺←╠⊢╣ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡╠⍺╣ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[350] 	1╠≡╣⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	╠1≡⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr9039(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[349] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡╠⍺╣ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[350] 	1≡╠⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[350] 	1╠≡╣⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[350] 	╠1╣≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	╠1≡⍺ 1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[350] 	1≡⍺ ╠1╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[350] 	1≡⍺ 1:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[350] 	1≡⍺ 1:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[350] 	1≡⍺ 1:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[349] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr9040(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[354] rpf←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[354] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[354] rpf←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[354] rpf←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[354] rpf←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr9041(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[354] rpf←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[354] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[354] rpf←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[354] rpf←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[354] rpf←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr9042(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array_box *X;
		struct cell_array_box *fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_array_box(&loc->X, NULL), cleanup, L"Init mutable variable: loc->X");
	CHK(mk_array_box(&loc->fn, NULL), cleanup, L"Init mutable variable: loc->fn");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,╠⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[357] scf←{X←╠,╣⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←╠,⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->X->value);
	loc->X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←╠⍺⍺╣ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	release_cell(loc->fn->value);
	loc->fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳╣≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1╠+╣⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}╠¨╣1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9043, ptr9044, 2), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	
		k->fv[0] = retain_cell(loc->fn);
		k->fv[1] = retain_cell(loc->X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨╣1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)╠⍴╣{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴╠⍵╣)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (╠⍴╣⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)╣⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze╣ (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←╠{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}╣");
	return err;
}

int
ptr9043(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9044(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9045(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array_box *X;
		struct cell_array_box *fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_array_box(&loc->X, NULL), cleanup, L"Init mutable variable: loc->X");
	CHK(mk_array_box(&loc->fn, NULL), cleanup, L"Init mutable variable: loc->fn");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,╠⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[357] scf←{X←╠,╣⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←╠,⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->X->value);
	loc->X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←╠⍺⍺╣ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	release_cell(loc->fn->value);
	loc->fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳╣≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1╠+╣⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}╠¨╣1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9046, ptr9047, 2), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	
		k->fv[0] = retain_cell(loc->fn);
		k->fv[1] = retain_cell(loc->X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨╣1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)╠⍴╣{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴╠⍵╣)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (╠⍴╣⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)╣⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze╣ (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←╠{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}╣");
	return err;
}

int
ptr9046(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9047(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_array_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9048(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array_box *X;
		struct cell_func_box *fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_array_box(&loc->X, NULL), cleanup, L"Init mutable variable: loc->X");
	CHK(mk_func_box(&loc->fn, NULL), cleanup, L"Init mutable variable: loc->fn");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,╠⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[357] scf←{X←╠,╣⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←╠,⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->X->value);
	loc->X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←╠⍺⍺╣ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	release_cell(loc->fn->value);
	loc->fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳╣≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1╠+╣⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}╠¨╣1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9049, ptr9050, 2), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	
		k->fv[0] = retain_cell(loc->fn);
		k->fv[1] = retain_cell(loc->X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨╣1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)╠⍴╣{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴╠⍵╣)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (╠⍴╣⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)╣⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze╣ (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←╠{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}╣");
	return err;
}

int
ptr9049(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9050(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9051(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array_box *X;
		struct cell_func_box *fn;
	} loc_frm, *loc;

	loc = &loc_frm;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;

	lex = (struct lex_vars *)deldel->fv;

	CHK(mk_array_box(&loc->X, NULL), cleanup, L"Init mutable variable: loc->X");
	CHK(mk_func_box(&loc->fn, NULL), cleanup, L"Init mutable variable: loc->fn");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,╠⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[357] scf←{X←╠,╣⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←╠,⍵╣ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->X->value);
	loc->X->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←╠⍺⍺╣ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	release_cell(loc->fn->value);
	loc->fn->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳╠≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳╣≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+╠⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1╠+╣⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1╣+⍳≢⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨╠1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}╠¨╣1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr9052, ptr9053, 2), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	
		k->fv[0] = retain_cell(loc->fn);
		k->fv[1] = retain_cell(loc->X);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨╣1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)╠⍴╣{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴╠⍵╣)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (╠⍴╣⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)╣⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze ╠(⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze╣ (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ ╠squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←╠{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳⍵]}¨1+⍳≢⍵}╣");
	return err;
}

int
ptr9052(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9053(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;

	struct lex_vars {
		struct cell_func_box *fn;
		struct cell_array_box *X;
	} *lex;

	lex = (struct lex_vars *)self->fv;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[⍳╠⍵╣]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳╣⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X[╠⍳⍵╣]}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[⍳⍵]╣}¨1+⍳≢⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿X╠[╣⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!lex->X->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X╣[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->X->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn⌿╠X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{fn╠⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!lex->fn->value)
		CHK(6, cleanup, L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn╣⌿X[⍳⍵]}¨1+⍳≢⍵}");
	
	*stkhd++ = retain_cell(lex->fn->value);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿╣X[⍳⍵]}¨1+⍳≢⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴{╠fn⌿X[⍳⍵]╣}¨1+⍳≢⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[357] scf←{X←,⍵ ⋄ fn←⍺⍺ ⋄ squeeze (⍴⍵)⍴╠{fn⌿X[⍳⍵]}╣¨1+⍳≢⍵}");
	return err;
}

int
ptr9054(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9055(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9056(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9057(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9058(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9059(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9060(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9061(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[360] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[360] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[360] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[360] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[360] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[360] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[360] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr9062(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *y;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->y = NULL;
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,╠⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,╣⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←╠≢╣,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←╠≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->y);
	loc->y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)╠×╣y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,╠⍺╣)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢╠,╣⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢╠,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(╠≢╣,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[363] oup←{i←╠⍳╣(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←╠⍳(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|╠i╣]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y╠|╣i]}");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y╣|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y|i╣]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[╣y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,╠⍵╣)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(╠,╣⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)╣[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺╠¨╣(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺╣¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺¨╣(,⍵)[y|i]}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷╠y╣]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i╠÷╣y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i╣÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊╣i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[╣⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,╠⍺╣)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(╠,╣⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)╣[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)╠⍴╣(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴╠⍵╣)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴╣⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺)╠,╣⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴╠⍺╣),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((╠⍴╣⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ (╠(⍴⍺)╣,⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[363] oup←╠{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}╣");
	return err;
}

int
ptr9063(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *y;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->y = NULL;
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,╠⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,╣⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←╠≢╣,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←╠≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->y);
	loc->y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)╠×╣y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,╠⍺╣)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢╠,╣⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢╠,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(╠≢╣,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[363] oup←{i←╠⍳╣(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←╠⍳(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|╠i╣]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y╠|╣i]}");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y╣|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y|i╣]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[╣y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,╠⍵╣)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(╠,╣⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)╣[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺╠¨╣(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺╣¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺¨╣(,⍵)[y|i]}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷╠y╣]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i╠÷╣y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i╣÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊╣i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[╣⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,╠⍺╣)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(╠,╣⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)╣[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)╠⍴╣(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴╠⍵╣)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴╣⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺)╠,╣⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴╠⍺╣),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((╠⍴╣⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ (╠(⍴⍺)╣,⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[363] oup←╠{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}╣");
	return err;
}

int
ptr9064(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *y;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->y = NULL;
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,╠⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,╣⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←╠≢╣,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←╠≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->y);
	loc->y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)╠×╣y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,╠⍺╣)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢╠,╣⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢╠,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(╠≢╣,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[363] oup←{i←╠⍳╣(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←╠⍳(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|╠i╣]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y╠|╣i]}");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y╣|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y|i╣]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[╣y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,╠⍵╣)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(╠,╣⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)╣[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺╠¨╣(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺╣¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺¨╣(,⍵)[y|i]}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷╠y╣]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i╠÷╣y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i╣÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊╣i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[╣⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,╠⍺╣)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(╠,╣⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)╣[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)╠⍴╣(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴╠⍵╣)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴╣⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺)╠,╣⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴╠⍺╣),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((╠⍴╣⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ (╠(⍴⍺)╣,⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[363] oup←╠{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}╣");
	return err;
}

int
ptr9065(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *y;
		struct cell_array *i;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->y = NULL;
	loc->i = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,╠⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,╣⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢╠,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←╠≢╣,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←╠≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->y);
	loc->y = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)╠×╣y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,╠⍺╣)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢╠,╣⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢╠,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[363] oup←{i←⍳(╠≢╣,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)╣×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳╠(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[363] oup←{i←╠⍳╣(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←╠⍳(≢,⍺)×y←≢,⍵╣ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	release_cell(loc->i);
	loc->i = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|╠i╣]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y╠|╣i]}");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y╣|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[╠y|i╣]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[y|i]╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)╠[╣y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,╠⍵╣)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(╠,╣⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)╣[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨╠(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺╠¨╣(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺╣¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]╠⍺⍺¨╣(,⍵)[y|i]}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!loc->y)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷╠y╣]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->y);
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i╠÷╣y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!loc->i)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i╣÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(loc->i);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊╠i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.min)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊╣i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.min);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[╠⌊i÷y╣]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		arr->shape[0] = 1;
		CHK(alloc_array(arr), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.brk)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[╣⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.brk);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,╠⍺╣)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(╠,╣⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)╣[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴╠(,⍺)[⌊i÷y]╣⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)╠[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)╠⍴╣(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴╠⍵╣)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴╣⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),╠⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺)╠,╣⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	if (!alpha)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴╠⍺╣),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((╠⍴╣⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ (╠(⍴⍺)╣,⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)╣⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[363] oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ╠((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[363] oup←╠{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}╣");
	return err;
}

int
ptr9066(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[366] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9067(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[366] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9068(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[366] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9069(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[366] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9070(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9071(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 3;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
		dat[2] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		CHK(alloc_array(arr), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9072(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	release_cell(alpha);
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9073(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[366] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[366] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[366] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr9074(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 4;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
				dat[3] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9075(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 4;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
				dat[3] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				arr->shape[0] = 3;
				CHK(alloc_array(arr), cleanup,
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9076(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9077(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[374] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9078(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9079(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				arr->shape[0] = 2;
				CHK(alloc_array(arr), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9080(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

int
ptr9081(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;

	loc = &loc_frm;

	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[370] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	release_cell(loc->type);
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[371] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[371] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[371] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[371] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[371] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[371] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[372] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[372] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[372] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[372] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[372] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[372] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[373] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[373] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[373] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[373] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[373] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[373] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[374] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[374] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[374] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[374] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[374] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[375] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[375] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[375] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[369] jot←╠{╣");
	return err;
}

EXPORT int
q_signal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->q_signal;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
q_signal_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_signal, z, l, r, L"q_signal");
}

EXPORT int
q_dr(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->q_dr;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
q_dr_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_dr, z, l, r, L"q_dr");
}

EXPORT int
squeeze(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->squeeze->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
squeeze_dwa(void *z, void *l, void *r)
{
	return call_dwa(squeeze, z, l, r, L"squeeze");
}

EXPORT int
is_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_simple->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_simple, z, l, r, L"is_simple");
}

EXPORT int
is_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_numeric->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_numeric, z, l, r, L"is_numeric");
}

EXPORT int
is_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_char->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_char, z, l, r, L"is_char");
}

EXPORT int
is_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_integer->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_integer, z, l, r, L"is_integer");
}

EXPORT int
is_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_bool->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_bool, z, l, r, L"is_bool");
}

EXPORT int
is_span(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->is_span->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
is_span_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_span, z, l, r, L"is_span");
}

EXPORT int
max_shp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->max_shp->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
max_shp_dwa(void *z, void *l, void *r)
{
	return call_dwa(max_shp, z, l, r, L"max_shp");
}

EXPORT int
has_nat_vals(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->has_nat_vals->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
has_nat_vals_dwa(void *z, void *l, void *r)
{
	return call_dwa(has_nat_vals, z, l, r, L"has_nat_vals");
}

EXPORT int
chk_scl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->chk_scl->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
chk_scl_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_scl, z, l, r, L"chk_scl");
}

EXPORT int
chk_valid_shape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->chk_valid_shape->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
chk_valid_shape_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_valid_shape, z, l, r, L"chk_valid_shape");
}

EXPORT int
both_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->both_simple->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
both_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_simple, z, l, r, L"both_simple");
}

EXPORT int
both_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->both_numeric->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
both_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_numeric, z, l, r, L"both_numeric");
}

EXPORT int
both_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->both_integer->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
both_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_integer, z, l, r, L"both_integer");
}

EXPORT int
both_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->both_char->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
both_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_char, z, l, r, L"both_char");
}

EXPORT int
both_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->both_bool->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
both_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_bool, z, l, r, L"both_bool");
}

EXPORT int
any(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->any->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
any_dwa(void *z, void *l, void *r)
{
	return call_dwa(any, z, l, r, L"any");
}

EXPORT int
idx_shp_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->idx_shp_check;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
idx_shp_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(idx_shp_check, z, l, r, L"idx_shp_check");
}

EXPORT int
idx_rng_check(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->idx_rng_check;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
idx_rng_check_dwa(void *z, void *l, void *r)
{
	return call_dwa(idx_rng_check, z, l, r, L"idx_rng_check");
}

EXPORT int
set(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->set;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
set_dwa(void *z, void *l, void *r)
{
	return call_dwa(set, z, l, r, L"set");
}

EXPORT int
brk(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->brk;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
brk_dwa(void *z, void *l, void *r)
{
	return call_dwa(brk, z, l, r, L"brk");
}

EXPORT int
rgt(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->rgt;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
rgt_dwa(void *z, void *l, void *r)
{
	return call_dwa(rgt, z, l, r, L"rgt");
}

EXPORT int
lft(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lft;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lft_dwa(void *z, void *l, void *r)
{
	return call_dwa(lft, z, l, r, L"lft");
}

EXPORT int
reshape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->reshape;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
reshape_dwa(void *z, void *l, void *r)
{
	return call_dwa(reshape, z, l, r, L"reshape");
}

EXPORT int
rho(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->rho;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
rho_dwa(void *z, void *l, void *r)
{
	return call_dwa(rho, z, l, r, L"rho");
}

EXPORT int
cat(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cat;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cat_dwa(void *z, void *l, void *r)
{
	return call_dwa(cat, z, l, r, L"cat");
}

EXPORT int
depth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->depth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
depth_dwa(void *z, void *l, void *r)
{
	return call_dwa(depth, z, l, r, L"depth");
}

EXPORT int
same(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->same->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
same_dwa(void *z, void *l, void *r)
{
	return call_dwa(same, z, l, r, L"same");
}

EXPORT int
eqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->eqv;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
eqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(eqv, z, l, r, L"eqv");
}

EXPORT int
nqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->nqv;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
nqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(nqv, z, l, r, L"nqv");
}

EXPORT int
sqd_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->sqd_vec->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
sqd_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(sqd_vec, z, l, r, L"sqd_vec");
}

EXPORT int
sqd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->sqd;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
sqd_dwa(void *z, void *l, void *r)
{
	return call_dwa(sqd, z, l, r, L"sqd");
}

EXPORT int
index_gen(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->index_gen;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
index_gen_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_gen, z, l, r, L"index_gen");
}

EXPORT int
index_of(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->index_of;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
index_of_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_of, z, l, r, L"index_of");
}

EXPORT int
iot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->iot;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
iot_dwa(void *z, void *l, void *r)
{
	return call_dwa(iot, z, l, r, L"iot");
}

EXPORT int
dis(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->dis;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
dis_dwa(void *z, void *l, void *r)
{
	return call_dwa(dis, z, l, r, L"dis");
}

EXPORT int
enclose(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->enclose;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
enclose_dwa(void *z, void *l, void *r)
{
	return call_dwa(enclose, z, l, r, L"enclose");
}

EXPORT int
par(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->par;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
par_dwa(void *z, void *l, void *r)
{
	return call_dwa(par, z, l, r, L"par");
}

EXPORT int
conjugate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->conjugate;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
conjugate_dwa(void *z, void *l, void *r)
{
	return call_dwa(conjugate, z, l, r, L"conjugate");
}

EXPORT int
add(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->add;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
add_dwa(void *z, void *l, void *r)
{
	return call_dwa(add, z, l, r, L"add");
}

EXPORT int
sub(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->sub;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
sub_dwa(void *z, void *l, void *r)
{
	return call_dwa(sub, z, l, r, L"sub");
}

EXPORT int
sign(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->sign;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
sign_dwa(void *z, void *l, void *r)
{
	return call_dwa(sign, z, l, r, L"sign");
}

EXPORT int
mul(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->mul;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
mul_dwa(void *z, void *l, void *r)
{
	return call_dwa(mul, z, l, r, L"mul");
}

EXPORT int
div(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->div;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
div_dwa(void *z, void *l, void *r)
{
	return call_dwa(div, z, l, r, L"div");
}

EXPORT int
absolute(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->absolute;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
absolute_dwa(void *z, void *l, void *r)
{
	return call_dwa(absolute, z, l, r, L"absolute");
}

EXPORT int
residue(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->residue;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
residue_dwa(void *z, void *l, void *r)
{
	return call_dwa(residue, z, l, r, L"residue");
}

EXPORT int
res(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->res;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
res_dwa(void *z, void *l, void *r)
{
	return call_dwa(res, z, l, r, L"res");
}

EXPORT int
floor_array(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->floor_array;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
floor_array_dwa(void *z, void *l, void *r)
{
	return call_dwa(floor_array, z, l, r, L"floor_array");
}

EXPORT int
min(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->min;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
min_dwa(void *z, void *l, void *r)
{
	return call_dwa(min, z, l, r, L"min");
}

EXPORT int
ceil_array(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->ceil_array;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
ceil_array_dwa(void *z, void *l, void *r)
{
	return call_dwa(ceil_array, z, l, r, L"ceil_array");
}

EXPORT int
max(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->max;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
max_dwa(void *z, void *l, void *r)
{
	return call_dwa(max, z, l, r, L"max");
}

EXPORT int
exp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->exp;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
exp_dwa(void *z, void *l, void *r)
{
	return call_dwa(exp, z, l, r, L"exp");
}

EXPORT int
log(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->log;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
log_dwa(void *z, void *l, void *r)
{
	return call_dwa(log, z, l, r, L"log");
}

EXPORT int
pitimes(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->pitimes;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
pitimes_dwa(void *z, void *l, void *r)
{
	return call_dwa(pitimes, z, l, r, L"pitimes");
}

EXPORT int
trig(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->trig;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
trig_dwa(void *z, void *l, void *r)
{
	return call_dwa(trig, z, l, r, L"trig");
}

EXPORT int
cir(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->cir;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
cir_dwa(void *z, void *l, void *r)
{
	return call_dwa(cir, z, l, r, L"cir");
}

EXPORT int
binomial(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->binomial;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
binomial_dwa(void *z, void *l, void *r)
{
	return call_dwa(binomial, z, l, r, L"binomial");
}

EXPORT int
fac(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->fac;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
fac_dwa(void *z, void *l, void *r)
{
	return call_dwa(fac, z, l, r, L"fac");
}

EXPORT int
notscl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->notscl;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
notscl_dwa(void *z, void *l, void *r)
{
	return call_dwa(notscl, z, l, r, L"notscl");
}

EXPORT int
without(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->without;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
without_dwa(void *z, void *l, void *r)
{
	return call_dwa(without, z, l, r, L"without");
}

EXPORT int
not(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->not;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
not_dwa(void *z, void *l, void *r)
{
	return call_dwa(not, z, l, r, L"not");
}

EXPORT int
logand(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->logand;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
logand_dwa(void *z, void *l, void *r)
{
	return call_dwa(logand, z, l, r, L"logand");
}

EXPORT int
and(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->and;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
and_dwa(void *z, void *l, void *r)
{
	return call_dwa(and, z, l, r, L"and");
}

EXPORT int
logor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->logor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
logor_dwa(void *z, void *l, void *r)
{
	return call_dwa(logor, z, l, r, L"logor");
}

EXPORT int
lor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lor_dwa(void *z, void *l, void *r)
{
	return call_dwa(lor, z, l, r, L"lor");
}

EXPORT int
nan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->nan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
nan_dwa(void *z, void *l, void *r)
{
	return call_dwa(nan, z, l, r, L"nan");
}

EXPORT int
nor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->nor;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
nor_dwa(void *z, void *l, void *r)
{
	return call_dwa(nor, z, l, r, L"nor");
}

EXPORT int
lessthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lessthan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lessthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(lessthan, z, l, r, L"lessthan");
}

EXPORT int
lth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lth_dwa(void *z, void *l, void *r)
{
	return call_dwa(lth, z, l, r, L"lth");
}

EXPORT int
lesseql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lesseql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lesseql_dwa(void *z, void *l, void *r)
{
	return call_dwa(lesseql, z, l, r, L"lesseql");
}

EXPORT int
lte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->lte;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
lte_dwa(void *z, void *l, void *r)
{
	return call_dwa(lte, z, l, r, L"lte");
}

EXPORT int
eql_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->eql_vec->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
eql_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(eql_vec, z, l, r, L"eql_vec");
}

EXPORT int
equal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->equal;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
equal_dwa(void *z, void *l, void *r)
{
	return call_dwa(equal, z, l, r, L"equal");
}

EXPORT int
eql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->eql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
eql_dwa(void *z, void *l, void *r)
{
	return call_dwa(eql, z, l, r, L"eql");
}

EXPORT int
greatereql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->greatereql;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
greatereql_dwa(void *z, void *l, void *r)
{
	return call_dwa(greatereql, z, l, r, L"greatereql");
}

EXPORT int
gte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->gte;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
gte_dwa(void *z, void *l, void *r)
{
	return call_dwa(gte, z, l, r, L"gte");
}

EXPORT int
greaterthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->greaterthan;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
greaterthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(greaterthan, z, l, r, L"greaterthan");
}

EXPORT int
gth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->gth;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
gth_dwa(void *z, void *l, void *r)
{
	return call_dwa(gth, z, l, r, L"gth");
}

EXPORT int
firstocc(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->firstocc;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
firstocc_dwa(void *z, void *l, void *r)
{
	return call_dwa(firstocc, z, l, r, L"firstocc");
}

EXPORT int
neq_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->neq_vec->value;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
neq_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(neq_vec, z, l, r, L"neq_vec");
}

EXPORT int
noteq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->noteq;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
noteq_dwa(void *z, void *l, void *r)
{
	return call_dwa(noteq, z, l, r, L"noteq");
}

EXPORT int
neq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->neq;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
neq_dwa(void *z, void *l, void *r)
{
	return call_dwa(neq, z, l, r, L"neq");
}

EXPORT int
mix(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->mix;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
mix_dwa(void *z, void *l, void *r)
{
	return call_dwa(mix, z, l, r, L"mix");
}

EXPORT int
take(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->take;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
take_dwa(void *z, void *l, void *r)
{
	return call_dwa(take, z, l, r, L"take");
}

EXPORT int
tke(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->tke;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
tke_dwa(void *z, void *l, void *r)
{
	return call_dwa(tke, z, l, r, L"tke");
}

EXPORT int
split(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->split;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
split_dwa(void *z, void *l, void *r)
{
	return call_dwa(split, z, l, r, L"split");
}

EXPORT int
drop(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->drop;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
drop_dwa(void *z, void *l, void *r)
{
	return call_dwa(drop, z, l, r, L"drop");
}

EXPORT int
drp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->drp;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
drp_dwa(void *z, void *l, void *r)
{
	return call_dwa(drp, z, l, r, L"drp");
}

EXPORT int
reverse_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->reverse_last;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
reverse_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(reverse_last, z, l, r, L"reverse_last");
}

EXPORT int
rotate_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->rotate_last;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
rotate_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(rotate_last, z, l, r, L"rotate_last");
}

EXPORT int
rot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->rot;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
rot_dwa(void *z, void *l, void *r)
{
	return call_dwa(rot, z, l, r, L"rot");
}

EXPORT int
rpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;
	int err;

	CHKFN(cdf_prim_init(), fail);

	loc = &cdf_prim;
	self = loc->rpf;

	if (l == NULL) {
		CHKFN(self->fptr_mon(z, r, self), fail);
	} else {
		CHKFN(self->fptr_dya(z, l, r, self), fail);
	}

fail:
	return err;
}

EXPORT int
rpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(rpf, z, l, r, L"rpf");
}

