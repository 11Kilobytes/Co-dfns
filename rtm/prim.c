#include "codfns.h"
#include "prim.h"

EXPORT int
DyalogGetInterpreterFunctions(void *p)
{
    return set_dwafns(p);
}

extern struct cell_func *q_signal_ibeam;
extern struct cell_func *q_dr_ibeam;
extern struct cell_moper *q_veach_ibeam;
extern struct cell_doper *q_ambiv_ibeam;
extern struct cell_func *squeeze_ibeam;
extern struct cell_func *is_simple_ibeam;
extern struct cell_func *is_numeric_ibeam;
extern struct cell_func *is_char_ibeam;
extern struct cell_func *is_integer_ibeam;
extern struct cell_func *max_shp_ibeam;
extern struct cell_func *has_nat_vals_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *shape_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *same_ibeam;
extern struct cell_func *nqv_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_gen_vec;
extern struct cell_func *index_gen_vec;
extern struct cell_func *disclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *conjugate_vec;
extern struct cell_func *conjugate_vec;
extern struct cell_func *add_vec_ibeam;
extern struct cell_func *sub_vec_ibeam;
extern struct cell_func *mul_vec_ibeam;
extern struct cell_func *div_vec_ibeam;
extern struct cell_func *abs_ibeam;
extern struct cell_func *abs_ibeam;
extern struct cell_func *floor_vec_ibeam;
extern struct cell_func *floor_vec_ibeam;
extern struct cell_func *min_vec_ibeam;
extern struct cell_func *max_vec_ibeam;
extern struct cell_func *ceil_vec_ibeam;
extern struct cell_func *pow_vec_ibeam;
extern struct cell_func *exp_vec_ibeam;
extern struct cell_func *log_vec_ibeam;
extern struct cell_func *nlg_vec_ibeam;
extern struct cell_func *sin_vec_ibeam;
extern struct cell_func *arcsin_vec_ibeam;
extern struct cell_func *cos_vec_ibeam;
extern struct cell_func *arccos_vec_ibeam;
extern struct cell_func *tan_vec_ibeam;
extern struct cell_func *arctan_vec_ibeam;
extern struct cell_func *sinh_vec_ibeam;
extern struct cell_func *arcsinh_vec_ibeam;
extern struct cell_func *cosh_vec_ibeam;
extern struct cell_func *arccosh_vec_ibeam;
extern struct cell_func *tanh_vec_ibeam;
extern struct cell_func *arctanh_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *sin_vec_ibeam;
extern struct cell_func *arcsin_vec_ibeam;
extern struct cell_func *cos_vec_ibeam;
extern struct cell_func *arccos_vec_ibeam;
extern struct cell_func *tan_vec_ibeam;
extern struct cell_func *arctan_vec_ibeam;
extern struct cell_func *sinh_vec_ibeam;
extern struct cell_func *arcsinh_vec_ibeam;
extern struct cell_func *cosh_vec_ibeam;
extern struct cell_func *arccosh_vec_ibeam;
extern struct cell_func *tanh_vec_ibeam;
extern struct cell_func *arctanh_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *realpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *imagpart_vec_ibeam;
extern struct cell_func *trig_vec_ibeam;
extern struct cell_func *factorial_vec_ibeam;
extern struct cell_func *not_vec_ibeam;
extern struct cell_func *not_vec_ibeam;
extern struct cell_func *and_vec_ibeam;
extern struct cell_func *and_vec_ibeam;
extern struct cell_func *lor_vec_ibeam;
extern struct cell_func *lor_vec_ibeam;
extern struct cell_func *lth_vec_ibeam;
extern struct cell_func *lth_vec_ibeam;
extern struct cell_func *lte_vec_ibeam;
extern struct cell_func *lte_vec_ibeam;
extern struct cell_func *eql_vec_ibeam;
extern struct cell_func *gte_vec_ibeam;
extern struct cell_func *gte_vec_ibeam;
extern struct cell_func *gth_vec_ibeam;
extern struct cell_func *gth_vec_ibeam;
extern struct cell_func *neq_vec_ibeam;

int ptr5127(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5128(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5129(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5130(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5131(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5132(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5133(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5134(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5135(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5136(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5137(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5138(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5139(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5140(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5141(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5142(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5143(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5144(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5145(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5146(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5147(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5148(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5149(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5150(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5151(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5152(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5153(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5154(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5155(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5156(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5157(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5158(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5159(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5160(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5161(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5162(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5163(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5164(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5165(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5166(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5167(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5168(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5169(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5170(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5171(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5172(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5173(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5174(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5175(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5176(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5177(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5178(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5179(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5180(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5181(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5182(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5183(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5184(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5185(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5186(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5187(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5188(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5189(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5190(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5191(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5192(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5193(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5194(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5195(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5196(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5197(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5198(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5199(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5200(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5201(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5202(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5203(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5204(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5205(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5206(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5207(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5208(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5209(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5210(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5211(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5212(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5213(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5214(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5215(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5216(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5217(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5218(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5219(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5220(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5221(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5222(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5223(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5224(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5225(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5226(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5227(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5228(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5229(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5230(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5231(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5232(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5233(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5234(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5235(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5236(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5237(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5238(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5239(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5240(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5241(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5242(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5243(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5244(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5245(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5246(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5247(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5248(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5249(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5250(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5251(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5252(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5253(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5254(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5255(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5256(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5257(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5258(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5259(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5260(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5261(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5262(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5263(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5264(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5265(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5266(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5267(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5268(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5269(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5270(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5271(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5272(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5273(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5274(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5275(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5276(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5277(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5278(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5279(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5280(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5281(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5282(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5283(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5284(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5285(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5286(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5287(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5288(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5289(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5290(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5291(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5292(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5293(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5294(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5295(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5296(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5297(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5298(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5299(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5300(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5301(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5302(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5303(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5304(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5305(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5306(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5307(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5308(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5309(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5310(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5311(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5312(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5313(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5314(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5315(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5316(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5317(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5318(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5319(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5320(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5321(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5322(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5323(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5324(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5325(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5326(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5327(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5328(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5329(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5330(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5331(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5332(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5333(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5334(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr5335(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr5336(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);

int cdf_prim_flag = 0;

wchar_t *cdf_prim_names[] = {L"q_signal", L"q_dr", L"q_veach", L"q_ambiv", L"squeeze", L"is_simple", L"is_numeric", L"is_char", L"is_integer", L"is_bool", L"max_shp", L"has_nat_vals", L"chk_scl", L"chk_valid_shape", L"both_simple", L"both_numeric", L"both_char", L"both_bool", L"numeric", L"scalar", L"rgt", L"lft", L"reshape", L"rho", L"cat", L"depth", L"eqv", L"nqv", L"materialize", L"index", L"sqd", L"index_gen", L"index_of", L"iot", L"dis", L"enclose", L"par", L"conjugate", L"add", L"negate", L"sub", L"sign", L"mul", L"recip", L"div", L"absolute", L"residue", L"res", L"floor_array", L"min", L"max", L"exp", L"log", L"pitimes", L"trig", L"cir", L"binomial", L"fac", L"notscl", L"without", L"not", L"logand", L"and", L"logor", L"lor", L"nan", L"nor", L"lessthan", L"lth", L"lesseql", L"lte", L"eql_vec", L"equal", L"eql", L"greatereql", L"gte", L"greaterthan", L"gth", L"firstocc", L"neq_vec", L"noteq", L"neq", L"split", L"drop", L"drp", L"reverse_last", L"rotate_last", L"rot", L"map_monadic", L"map_dyadic", L"map", L"reduce", L"nwreduce", L"rdf", L"rpf", L"dot", L"pow", L"jot"};

EXPORT int
cdf_prim_init(void)
{
	struct cdf_prim_loc *loc;
	void *stk[128];
	void **stkhd;
	int err;

	if (cdf_prim_flag)
		return 0;

	stkhd = &stk[0];
	cdf_prim_flag = 1;
	cdf_prim_init();

	loc = &cdf_prim;
	loc->__count = 98;
	loc->__names = cdf_prim_names;
	loc->q_signal = NULL;
	loc->q_dr = NULL;
	loc->q_veach = NULL;
	loc->q_ambiv = NULL;
	CHK(mk_func_box(&loc->squeeze, NULL), cleanup, L"Init mutable variable: loc->squeeze");
	CHK(mk_func_box(&loc->is_simple, NULL), cleanup, L"Init mutable variable: loc->is_simple");
	CHK(mk_func_box(&loc->is_numeric, NULL), cleanup, L"Init mutable variable: loc->is_numeric");
	CHK(mk_func_box(&loc->is_char, NULL), cleanup, L"Init mutable variable: loc->is_char");
	CHK(mk_func_box(&loc->is_integer, NULL), cleanup, L"Init mutable variable: loc->is_integer");
	CHK(mk_func_box(&loc->is_bool, NULL), cleanup, L"Init mutable variable: loc->is_bool");
	CHK(mk_func_box(&loc->max_shp, NULL), cleanup, L"Init mutable variable: loc->max_shp");
	CHK(mk_func_box(&loc->has_nat_vals, NULL), cleanup, L"Init mutable variable: loc->has_nat_vals");
	CHK(mk_func_box(&loc->chk_scl, NULL), cleanup, L"Init mutable variable: loc->chk_scl");
	CHK(mk_func_box(&loc->chk_valid_shape, NULL), cleanup, L"Init mutable variable: loc->chk_valid_shape");
	CHK(mk_func_box(&loc->both_simple, NULL), cleanup, L"Init mutable variable: loc->both_simple");
	CHK(mk_func_box(&loc->both_numeric, NULL), cleanup, L"Init mutable variable: loc->both_numeric");
	CHK(mk_func_box(&loc->both_char, NULL), cleanup, L"Init mutable variable: loc->both_char");
	CHK(mk_func_box(&loc->both_bool, NULL), cleanup, L"Init mutable variable: loc->both_bool");
	loc->numeric = NULL;
	loc->scalar = NULL;
	loc->rgt = NULL;
	loc->lft = NULL;
	loc->reshape = NULL;
	loc->rho = NULL;
	loc->cat = NULL;
	loc->depth = NULL;
	loc->eqv = NULL;
	loc->nqv = NULL;
	loc->materialize = NULL;
	loc->index = NULL;
	loc->sqd = NULL;
	loc->index_gen = NULL;
	loc->index_of = NULL;
	loc->iot = NULL;
	loc->dis = NULL;
	loc->enclose = NULL;
	loc->par = NULL;
	loc->conjugate = NULL;
	loc->add = NULL;
	loc->negate = NULL;
	loc->sub = NULL;
	loc->sign = NULL;
	loc->mul = NULL;
	loc->recip = NULL;
	loc->div = NULL;
	loc->absolute = NULL;
	loc->residue = NULL;
	loc->res = NULL;
	loc->floor_array = NULL;
	loc->min = NULL;
	loc->max = NULL;
	loc->exp = NULL;
	loc->log = NULL;
	loc->pitimes = NULL;
	loc->trig = NULL;
	loc->cir = NULL;
	loc->binomial = NULL;
	loc->fac = NULL;
	loc->notscl = NULL;
	loc->without = NULL;
	loc->not = NULL;
	loc->logand = NULL;
	loc->and = NULL;
	loc->logor = NULL;
	loc->lor = NULL;
	loc->nan = NULL;
	loc->nor = NULL;
	loc->lessthan = NULL;
	loc->lth = NULL;
	loc->lesseql = NULL;
	loc->lte = NULL;
	CHK(mk_func_box(&loc->eql_vec, NULL), cleanup, L"Init mutable variable: loc->eql_vec");
	loc->equal = NULL;
	loc->eql = NULL;
	loc->greatereql = NULL;
	loc->gte = NULL;
	loc->greaterthan = NULL;
	loc->gth = NULL;
	loc->firstocc = NULL;
	CHK(mk_func_box(&loc->neq_vec, NULL), cleanup, L"Init mutable variable: loc->neq_vec");
	loc->noteq = NULL;
	loc->neq = NULL;
	loc->split = NULL;
	loc->drop = NULL;
	loc->drp = NULL;
	loc->reverse_last = NULL;
	loc->rotate_last = NULL;
	loc->rot = NULL;
	loc->map_monadic = NULL;
	CHK(mk_moper_box(&loc->map_dyadic, NULL), cleanup, L"Init mutable variable: loc->map_dyadic");
	loc->map = NULL;
	CHK(mk_moper_box(&loc->reduce, NULL), cleanup, L"Init mutable variable: loc->reduce");
	CHK(mk_moper_box(&loc->nwreduce, NULL), cleanup, L"Init mutable variable: loc->nwreduce");
	loc->rdf = NULL;
	loc->rpf = NULL;
	loc->dot = NULL;
	loc->pow = NULL;
	loc->jot = NULL;

	err = 0;

	if (debug_info)
		release_array(debug_info);

	debug_info = NULL;

	if (!q_signal_ibeam)
		CHK(6, cleanup, L"[4] q_signal←╠'q_signal_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(q_signal_ibeam);
	
	loc->q_signal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!q_dr_ibeam)
		CHK(6, cleanup, L"[5] q_dr←╠'q_dr_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(q_dr_ibeam);
	
	loc->q_dr = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!q_veach_ibeam)
		CHK(6, cleanup, L"[6] q_veach←╠'q_veach_ibeam'⌶⌶╣");
	
	*stkhd++ = retain_cell(q_veach_ibeam);
	
	loc->q_veach = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!q_ambiv_ibeam)
		CHK(6, cleanup, L"[7] q_ambiv←╠'q_ambiv_ibeam'⌶⌶⌶╣");
	
	*stkhd++ = retain_cell(q_ambiv_ibeam);
	
	loc->q_ambiv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!squeeze_ibeam)
		CHK(6, cleanup, L"[10] squeeze←╠'squeeze_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(squeeze_ibeam);
	
	loc->squeeze->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_simple_ibeam)
		CHK(6, cleanup, L"[11] is_simple←╠'is_simple_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_simple_ibeam);
	
	loc->is_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_numeric_ibeam)
		CHK(6, cleanup, L"[12] is_numeric←╠'is_numeric_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_numeric_ibeam);
	
	loc->is_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_char_ibeam)
		CHK(6, cleanup, L"[13] is_char←╠'is_char_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_char_ibeam);
	
	loc->is_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!is_integer_ibeam)
		CHK(6, cleanup, L"[14] is_integer←╠'is_integer_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(is_integer_ibeam);
	
	loc->is_integer->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5127, ptr5128, 1), cleanup, 
		    L"[15] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	loc->is_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!max_shp_ibeam)
		CHK(6, cleanup, L"[16] max_shp←╠'max_shp_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(max_shp_ibeam);
	
	loc->max_shp->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!has_nat_vals_ibeam)
		CHK(6, cleanup, L"[17] has_nat_vals←╠'has_nat_vals_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(has_nat_vals_ibeam);
	
	loc->has_nat_vals->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5129, ptr5130, 0), cleanup, 
		    L"[18] chk_scl←╠{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	
		*stkhd++ = k;
	}
	
	loc->chk_scl->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5131, ptr5136, 1), cleanup, 
		    L"[19] chk_valid_shape←╠{╣");
	
		k->fv[0] = retain_cell(loc->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	loc->chk_valid_shape->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5141, ptr5142, 1), cleanup, 
		    L"[24] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	loc->both_simple->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5143, ptr5144, 1), cleanup, 
		    L"[25] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	loc->both_numeric->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5145, ptr5146, 1), cleanup, 
		    L"[26] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_char);
	
		*stkhd++ = k;
	}
	
	loc->both_char->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5147, ptr5148, 1), cleanup, 
		    L"[27] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_bool);
	
		*stkhd++ = k;
	}
	
	loc->both_bool->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5149, ptr5150, ptr5151, ptr5152, 1), cleanup, 
		    L"[28] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	loc->numeric = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5153, ptr5154, ptr5155, ptr5156, 3), cleanup, 
		    L"[29] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	
		k->fv[0] = retain_cell(loc->both_simple);
		k->fv[1] = retain_cell(loc->chk_scl);
		k->fv[2] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->scalar = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5157, ptr5158, 0), cleanup, 
		    L"[32] rgt←╠{⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->rgt = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5161, ptr5162, 0), cleanup, 
		    L"[35] lft←{⍵} ⎕AMBIV ╠{⍺}╣");
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[35] lft←{⍵} ╠⎕AMBIV╣ {⍺}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5159, ptr5160, 0), cleanup, 
		    L"[35] lft←╠{⍵}╣ ⎕AMBIV {⍺}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[35] lft←╠{⍵} ⎕AMBIV {⍺}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->lft = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5163, ptr5164, 1), cleanup, 
		    L"[38] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->reshape = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->reshape)
		CHK(6, cleanup, L"[39] rho←('shape_ibeam'⌶) ⎕AMBIV ╠reshape╣");
	
	*stkhd++ = retain_cell(loc->reshape);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[39] rho←('shape_ibeam'⌶) ╠⎕AMBIV╣ reshape");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!shape_ibeam)
		CHK(6, cleanup, L"[39] rho←╠('shape_ibeam'⌶)╣ ⎕AMBIV reshape");
	
	*stkhd++ = retain_cell(shape_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[39] rho←╠('shape_ibeam'⌶) ⎕AMBIV reshape╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rho = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5165, ptr5166, 0), cleanup, 
		    L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[42] cat←('ravel_ibeam'⌶) ╠⎕AMBIV╣ {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!ravel_ibeam)
		CHK(6, cleanup, L"[42] cat←╠('ravel_ibeam'⌶)╣ ⎕AMBIV {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(ravel_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[42] cat←╠('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->cat = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5167, ptr5170, 1), cleanup, 
		    L"[45] depth←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	loc->depth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!same_ibeam)
		CHK(6, cleanup, L"[49] eqv←depth ⎕AMBIV ╠('same_ibeam'⌶)╣");
	
	*stkhd++ = retain_cell(same_ibeam);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[49] eqv←depth ╠⎕AMBIV╣ ('same_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->depth)
		CHK(6, cleanup, L"[49] eqv←╠depth╣ ⎕AMBIV ('same_ibeam'⌶)");
	
	*stkhd++ = retain_cell(loc->depth);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[49] eqv←╠depth ⎕AMBIV ('same_ibeam'⌶)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->eqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!nqv_ibeam)
		CHK(6, cleanup, L"[52] nqv←{⊃⍴⍵} ⎕AMBIV ╠('nqv_ibeam'⌶)╣");
	
	*stkhd++ = retain_cell(nqv_ibeam);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[52] nqv←{⊃⍴⍵} ╠⎕AMBIV╣ ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5173, ptr5174, 0), cleanup, 
		    L"[52] nqv←╠{⊃⍴⍵}╣ ⎕AMBIV ('nqv_ibeam'⌶)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[52] nqv←╠{⊃⍴⍵} ⎕AMBIV ('nqv_ibeam'⌶)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->nqv = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5175, ptr5176, 0), cleanup, 
		    L"[55] materialize←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->materialize = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5177, ptr5180, 1), cleanup, 
		    L"[56] index←╠{idx←⊃⍺ ⋄ rnk←≢⍴idx╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->index = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->index)
		CHK(6, cleanup, L"[61] sqd←materialize ⎕AMBIV ╠index╣");
	
	*stkhd++ = retain_cell(loc->index);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[61] sqd←materialize ╠⎕AMBIV╣ index");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->materialize)
		CHK(6, cleanup, L"[61] sqd←╠materialize╣ ⎕AMBIV index");
	
	*stkhd++ = retain_cell(loc->materialize);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[61] sqd←╠materialize ⎕AMBIV index╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->sqd = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5183, ptr5184, 1), cleanup, 
		    L"[64] index_gen←╠{╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->index_gen = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5185, ptr5186, 0), cleanup, 
		    L"[71] index_of←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->index_of = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->index_of)
		CHK(6, cleanup, L"[72] iot←index_gen ⎕AMBIV ╠index_of╣");
	
	*stkhd++ = retain_cell(loc->index_of);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[72] iot←index_gen ╠⎕AMBIV╣ index_of");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->index_gen)
		CHK(6, cleanup, L"[72] iot←╠index_gen╣ ⎕AMBIV index_of");
	
	*stkhd++ = retain_cell(loc->index_gen);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[72] iot←╠index_gen ⎕AMBIV index_of╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->iot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5187, ptr5188, 0), cleanup, 
		    L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[75] dis←('disclose_ibeam'⌶) ╠⎕AMBIV╣ {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!disclose_ibeam)
		CHK(6, cleanup, L"[75] dis←╠('disclose_ibeam'⌶)╣ ⎕AMBIV {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(disclose_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[75] dis←╠('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->dis = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5189, ptr5190, 0), cleanup, 
		    L"[78] enclose←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->enclose = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5191, ptr5192, 0), cleanup, 
		    L"[82] par←enclose ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[82] par←enclose ╠⎕AMBIV╣ {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->enclose)
		CHK(6, cleanup, L"[82] par←╠enclose╣ ⎕AMBIV {⎕SIGNAL 16}");
	
	*stkhd++ = retain_cell(loc->enclose);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[82] par←╠enclose ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->par = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5193, ptr5194, 1), cleanup, 
		    L"[85] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	loc->conjugate = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[86] add←conjugate ⎕AMBIV ('add_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[86] add←conjugate ⎕AMBIV ('add_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!add_vec_ibeam)
		CHK(6, cleanup, L"[86] add←conjugate ⎕AMBIV (╠'add_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(add_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[86] add←conjugate ⎕AMBIV (╠'add_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[86] add←conjugate ⎕AMBIV ╠('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[86] add←conjugate ╠⎕AMBIV╣ ('add_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->conjugate)
		CHK(6, cleanup, L"[86] add←╠conjugate╣ ⎕AMBIV ('add_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->conjugate);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[86] add←╠conjugate ⎕AMBIV ('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->add = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5195, ptr5196, 0), cleanup, 
		    L"[89] negate←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->negate = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[90] sub←negate ⎕AMBIV ('sub_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[90] sub←negate ⎕AMBIV ('sub_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!sub_vec_ibeam)
		CHK(6, cleanup, L"[90] sub←negate ⎕AMBIV (╠'sub_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(sub_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[90] sub←negate ⎕AMBIV (╠'sub_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[90] sub←negate ⎕AMBIV ╠('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[90] sub←negate ╠⎕AMBIV╣ ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->negate)
		CHK(6, cleanup, L"[90] sub←╠negate╣ ⎕AMBIV ('sub_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->negate);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[90] sub←╠negate ⎕AMBIV ('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->sub = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5197, ptr5198, 0), cleanup, 
		    L"[93] sign←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->sign = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[94] mul←sign ⎕AMBIV ('mul_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[94] mul←sign ⎕AMBIV ('mul_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!mul_vec_ibeam)
		CHK(6, cleanup, L"[94] mul←sign ⎕AMBIV (╠'mul_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(mul_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[94] mul←sign ⎕AMBIV (╠'mul_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[94] mul←sign ⎕AMBIV ╠('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[94] mul←sign ╠⎕AMBIV╣ ('mul_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->sign)
		CHK(6, cleanup, L"[94] mul←╠sign╣ ⎕AMBIV ('mul_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->sign);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[94] mul←╠sign ⎕AMBIV ('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->mul = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5199, ptr5200, 0), cleanup, 
		    L"[97] recip←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->recip = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[98] div←recip ⎕AMBIV ('div_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[98] div←recip ⎕AMBIV ('div_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!div_vec_ibeam)
		CHK(6, cleanup, L"[98] div←recip ⎕AMBIV (╠'div_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(div_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[98] div←recip ⎕AMBIV (╠'div_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[98] div←recip ⎕AMBIV ╠('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[98] div←recip ╠⎕AMBIV╣ ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->recip)
		CHK(6, cleanup, L"[98] div←╠recip╣ ⎕AMBIV ('div_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->recip);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[98] div←╠recip ⎕AMBIV ('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->div = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5201, ptr5202, 1), cleanup, 
		    L"[101] absolute←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	loc->absolute = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5203, ptr5204, 0), cleanup, 
		    L"[106] residue←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->residue = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->residue)
		CHK(6, cleanup, L"[107] res←absolute ⎕AMBIV ╠residue╣");
	
	*stkhd++ = retain_cell(loc->residue);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[107] res←absolute ╠⎕AMBIV╣ residue");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->absolute)
		CHK(6, cleanup, L"[107] res←╠absolute╣ ⎕AMBIV residue");
	
	*stkhd++ = retain_cell(loc->absolute);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[107] res←╠absolute ⎕AMBIV residue╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->res = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5205, ptr5206, 1), cleanup, 
		    L"[110] floor_array←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->floor_array = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[114] min←floor_array numeric ⎕AMBIV ('min_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[114] min←floor_array numeric ⎕AMBIV ('min_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!min_vec_ibeam)
		CHK(6, cleanup, L"[114] min←floor_array numeric ⎕AMBIV (╠'min_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(min_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[114] min←floor_array numeric ⎕AMBIV (╠'min_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[114] min←floor_array numeric ⎕AMBIV ╠('min_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[114] min←floor_array numeric ╠⎕AMBIV╣ ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[114] min←floor_array ╠numeric╣ ⎕AMBIV ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->floor_array)
		CHK(6, cleanup, L"[114] min←╠floor_array╣ numeric ⎕AMBIV ('min_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->floor_array);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[114] min←╠floor_array numeric╣ ⎕AMBIV ('min_vec_ibeam'⌶ numeric scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[114] min←╠floor_array numeric ⎕AMBIV ('min_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->min = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[117] max←'ceil_vec_ibeam'⌶ ⎕AMBIV ('max_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[117] max←'ceil_vec_ibeam'⌶ ⎕AMBIV ('max_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!max_vec_ibeam)
		CHK(6, cleanup, L"[117] max←'ceil_vec_ibeam'⌶ ⎕AMBIV (╠'max_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(max_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[117] max←'ceil_vec_ibeam'⌶ ⎕AMBIV (╠'max_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[117] max←'ceil_vec_ibeam'⌶ ⎕AMBIV ╠('max_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[117] max←'ceil_vec_ibeam'⌶ ╠⎕AMBIV╣ ('max_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!ceil_vec_ibeam)
		CHK(6, cleanup, L"[117] max←╠'ceil_vec_ibeam'⌶╣ ⎕AMBIV ('max_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(ceil_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[117] max←╠'ceil_vec_ibeam'⌶ ⎕AMBIV ('max_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->max = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[120] exp←'exp_vec_ibeam'⌶ ⎕AMBIV ('pow_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[120] exp←'exp_vec_ibeam'⌶ ⎕AMBIV ('pow_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!pow_vec_ibeam)
		CHK(6, cleanup, L"[120] exp←'exp_vec_ibeam'⌶ ⎕AMBIV (╠'pow_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(pow_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[120] exp←'exp_vec_ibeam'⌶ ⎕AMBIV (╠'pow_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[120] exp←'exp_vec_ibeam'⌶ ⎕AMBIV ╠('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[120] exp←'exp_vec_ibeam'⌶ ╠⎕AMBIV╣ ('pow_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!exp_vec_ibeam)
		CHK(6, cleanup, L"[120] exp←╠'exp_vec_ibeam'⌶╣ ⎕AMBIV ('pow_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(exp_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[120] exp←╠'exp_vec_ibeam'⌶ ⎕AMBIV ('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->exp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[123] log←'nlg_vec_ibeam'⌶ ⎕AMBIV ('log_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[123] log←'nlg_vec_ibeam'⌶ ⎕AMBIV ('log_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!log_vec_ibeam)
		CHK(6, cleanup, L"[123] log←'nlg_vec_ibeam'⌶ ⎕AMBIV (╠'log_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(log_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[123] log←'nlg_vec_ibeam'⌶ ⎕AMBIV (╠'log_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[123] log←'nlg_vec_ibeam'⌶ ⎕AMBIV ╠('log_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[123] log←'nlg_vec_ibeam'⌶ ╠⎕AMBIV╣ ('log_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!nlg_vec_ibeam)
		CHK(6, cleanup, L"[123] log←╠'nlg_vec_ibeam'⌶╣ ⎕AMBIV ('log_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(nlg_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[123] log←╠'nlg_vec_ibeam'⌶ ⎕AMBIV ('log_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->log = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5207, ptr5208, 0), cleanup, 
		    L"[126] pitimes←╠{3.14159265358979323846×⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->pitimes = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5209, ptr5214, 0), cleanup, 
		    L"[127] trig←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->trig = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[156] cir←pitimes ⎕AMBIV ('trig_vec_ibeam'⌶ numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[156] cir←pitimes ⎕AMBIV ('trig_vec_ibeam'⌶ ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!trig_vec_ibeam)
		CHK(6, cleanup, L"[156] cir←pitimes ⎕AMBIV (╠'trig_vec_ibeam'⌶╣ numeric scalar)");
	
	*stkhd++ = retain_cell(trig_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[156] cir←pitimes ⎕AMBIV (╠'trig_vec_ibeam'⌶ numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[156] cir←pitimes ⎕AMBIV ╠('trig_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[156] cir←pitimes ╠⎕AMBIV╣ ('trig_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->pitimes)
		CHK(6, cleanup, L"[156] cir←╠pitimes╣ ⎕AMBIV ('trig_vec_ibeam'⌶ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->pitimes);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[156] cir←╠pitimes ⎕AMBIV ('trig_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->cir = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5219, ptr5220, 1), cleanup, 
		    L"[159] binomial←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->binomial = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->binomial)
		CHK(6, cleanup, L"[163] fac←'factorial_vec_ibeam'⌶ ⎕AMBIV ╠binomial╣");
	
	*stkhd++ = retain_cell(loc->binomial);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[163] fac←'factorial_vec_ibeam'⌶ ╠⎕AMBIV╣ binomial");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!factorial_vec_ibeam)
		CHK(6, cleanup, L"[163] fac←╠'factorial_vec_ibeam'⌶╣ ⎕AMBIV binomial");
	
	*stkhd++ = retain_cell(factorial_vec_ibeam);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[163] fac←╠'factorial_vec_ibeam'⌶ ⎕AMBIV binomial╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->fac = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5221, ptr5222, 1), cleanup, 
		    L"[166] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->is_bool);
	
		*stkhd++ = k;
	}
	
	loc->notscl = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5223, ptr5224, 0), cleanup, 
		    L"[167] without←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->without = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->without)
		CHK(6, cleanup, L"[168] not←notscl ⎕AMBIV ╠without╣");
	
	*stkhd++ = retain_cell(loc->without);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[168] not←notscl ╠⎕AMBIV╣ without");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->notscl)
		CHK(6, cleanup, L"[168] not←╠notscl╣ ⎕AMBIV without");
	
	*stkhd++ = retain_cell(loc->notscl);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[168] not←╠notscl ⎕AMBIV without╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->not = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5225, ptr5226, 1), cleanup, 
		    L"[171] logand←╠{╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	loc->logand = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[175] and←{⎕SIGNAL 2}⎕AMBIV (logand numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[175] and←{⎕SIGNAL 2}⎕AMBIV (logand ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->logand)
		CHK(6, cleanup, L"[175] and←{⎕SIGNAL 2}⎕AMBIV (╠logand╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->logand);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[175] and←{⎕SIGNAL 2}⎕AMBIV (╠logand numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[175] and←{⎕SIGNAL 2}⎕AMBIV ╠(logand numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[175] and←{⎕SIGNAL 2}╠⎕AMBIV╣ (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5227, ptr5228, 0), cleanup, 
		    L"[175] and←╠{⎕SIGNAL 2}╣⎕AMBIV (logand numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[175] and←╠{⎕SIGNAL 2}⎕AMBIV (logand numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->and = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5229, ptr5230, 1), cleanup, 
		    L"[178] logor←╠{╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	loc->logor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[182] lor←{⎕SIGNAL 2}⎕AMBIV (logor numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[182] lor←{⎕SIGNAL 2}⎕AMBIV (logor ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->logor)
		CHK(6, cleanup, L"[182] lor←{⎕SIGNAL 2}⎕AMBIV (╠logor╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->logor);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[182] lor←{⎕SIGNAL 2}⎕AMBIV (╠logor numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[182] lor←{⎕SIGNAL 2}⎕AMBIV ╠(logor numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[182] lor←{⎕SIGNAL 2}╠⎕AMBIV╣ (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5231, ptr5232, 0), cleanup, 
		    L"[182] lor←╠{⎕SIGNAL 2}╣⎕AMBIV (logor numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[182] lor←╠{⎕SIGNAL 2}⎕AMBIV (logor numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->lor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5235, ptr5236, 1), cleanup, 
		    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}╠⎕AMBIV╣{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5233, ptr5234, 0), cleanup, 
		    L"[185] nan←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[185] nan←╠{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->nan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5239, ptr5240, 1), cleanup, 
		    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_bool);
	
		*stkhd++ = k;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}╠⎕AMBIV╣{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5237, ptr5238, 0), cleanup, 
		    L"[188] nor←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[188] nor←╠{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->nor = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5241, ptr5242, 0), cleanup, 
		    L"[191] lessthan←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->lessthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[195] lth←{⎕SIGNAL 2} ⎕AMBIV (lessthan numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[195] lth←{⎕SIGNAL 2} ⎕AMBIV (lessthan ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->lessthan)
		CHK(6, cleanup, L"[195] lth←{⎕SIGNAL 2} ⎕AMBIV (╠lessthan╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->lessthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[195] lth←{⎕SIGNAL 2} ⎕AMBIV (╠lessthan numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[195] lth←{⎕SIGNAL 2} ⎕AMBIV ╠(lessthan numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[195] lth←{⎕SIGNAL 2} ╠⎕AMBIV╣ (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5243, ptr5244, 0), cleanup, 
		    L"[195] lth←╠{⎕SIGNAL 2}╣ ⎕AMBIV (lessthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[195] lth←╠{⎕SIGNAL 2} ⎕AMBIV (lessthan numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->lth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5245, ptr5246, 0), cleanup, 
		    L"[198] lesseql←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->lesseql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[202] lte←{⎕SIGNAL 2}⎕AMBIV (lesseql numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[202] lte←{⎕SIGNAL 2}⎕AMBIV (lesseql ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->lesseql)
		CHK(6, cleanup, L"[202] lte←{⎕SIGNAL 2}⎕AMBIV (╠lesseql╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->lesseql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[202] lte←{⎕SIGNAL 2}⎕AMBIV (╠lesseql numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[202] lte←{⎕SIGNAL 2}⎕AMBIV ╠(lesseql numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[202] lte←{⎕SIGNAL 2}╠⎕AMBIV╣ (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5247, ptr5248, 0), cleanup, 
		    L"[202] lte←╠{⎕SIGNAL 2}╣⎕AMBIV (lesseql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[202] lte←╠{⎕SIGNAL 2}⎕AMBIV (lesseql numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->lte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!eql_vec_ibeam)
		CHK(6, cleanup, L"[205] eql_vec←╠'eql_vec_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(eql_vec_ibeam);
	
	loc->eql_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5249, ptr5250, 3), cleanup, 
		    L"[206] equal←╠{╣");
	
		k->fv[0] = retain_cell(loc->eql_vec);
		k->fv[1] = retain_cell(loc->both_char);
		k->fv[2] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	loc->equal = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[211] eql←{⎕SIGNAL 2}⎕AMBIV (equal ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->equal)
		CHK(6, cleanup, L"[211] eql←{⎕SIGNAL 2}⎕AMBIV (╠equal╣ scalar)");
	
	*stkhd++ = retain_cell(loc->equal);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[211] eql←{⎕SIGNAL 2}⎕AMBIV ╠(equal scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[211] eql←{⎕SIGNAL 2}╠⎕AMBIV╣ (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5251, ptr5252, 0), cleanup, 
		    L"[211] eql←╠{⎕SIGNAL 2}╣⎕AMBIV (equal scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[211] eql←╠{⎕SIGNAL 2}⎕AMBIV (equal scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->eql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5253, ptr5254, 0), cleanup, 
		    L"[214] greatereql←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->greatereql = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[218] gte←{⎕SIGNAL 2}⎕AMBIV (greatereql numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[218] gte←{⎕SIGNAL 2}⎕AMBIV (greatereql ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->greatereql)
		CHK(6, cleanup, L"[218] gte←{⎕SIGNAL 2}⎕AMBIV (╠greatereql╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->greatereql);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[218] gte←{⎕SIGNAL 2}⎕AMBIV (╠greatereql numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[218] gte←{⎕SIGNAL 2}⎕AMBIV ╠(greatereql numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[218] gte←{⎕SIGNAL 2}╠⎕AMBIV╣ (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5255, ptr5256, 0), cleanup, 
		    L"[218] gte←╠{⎕SIGNAL 2}╣⎕AMBIV (greatereql numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[218] gte←╠{⎕SIGNAL 2}⎕AMBIV (greatereql numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->gte = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5257, ptr5258, 0), cleanup, 
		    L"[221] greaterthan←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->greaterthan = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[225] gth←{⎕SIGNAL 2}⎕AMBIV (greaterthan numeric ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->numeric)
		CHK(6, cleanup, L"[225] gth←{⎕SIGNAL 2}⎕AMBIV (greaterthan ╠numeric╣ scalar)");
	
	*stkhd++ = retain_cell(loc->numeric);
	
	if (!loc->greaterthan)
		CHK(6, cleanup, L"[225] gth←{⎕SIGNAL 2}⎕AMBIV (╠greaterthan╣ numeric scalar)");
	
	*stkhd++ = retain_cell(loc->greaterthan);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[225] gth←{⎕SIGNAL 2}⎕AMBIV (╠greaterthan numeric╣ scalar)");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[225] gth←{⎕SIGNAL 2}⎕AMBIV ╠(greaterthan numeric scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[225] gth←{⎕SIGNAL 2}╠⎕AMBIV╣ (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5259, ptr5260, 0), cleanup, 
		    L"[225] gth←╠{⎕SIGNAL 2}╣⎕AMBIV (greaterthan numeric scalar)");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[225] gth←╠{⎕SIGNAL 2}⎕AMBIV (greaterthan numeric scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->gth = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5261, ptr5262, 0), cleanup, 
		    L"[228] firstocc←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->firstocc = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!neq_vec_ibeam)
		CHK(6, cleanup, L"[229] neq_vec←╠'neq_vec_ibeam'⌶╣");
	
	*stkhd++ = retain_cell(neq_vec_ibeam);
	
	loc->neq_vec->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5263, ptr5264, 3), cleanup, 
		    L"[230] noteq←╠{╣");
	
		k->fv[0] = retain_cell(loc->neq_vec);
		k->fv[1] = retain_cell(loc->both_char);
		k->fv[2] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	loc->noteq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->scalar)
		CHK(6, cleanup, L"[235] neq←firstocc ⎕AMBIV (noteq ╠scalar╣)");
	
	*stkhd++ = retain_cell(loc->scalar);
	
	if (!loc->noteq)
		CHK(6, cleanup, L"[235] neq←firstocc ⎕AMBIV (╠noteq╣ scalar)");
	
	*stkhd++ = retain_cell(loc->noteq);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[235] neq←firstocc ⎕AMBIV ╠(noteq scalar)╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[235] neq←firstocc ╠⎕AMBIV╣ (noteq scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->firstocc)
		CHK(6, cleanup, L"[235] neq←╠firstocc╣ ⎕AMBIV (noteq scalar)");
	
	*stkhd++ = retain_cell(loc->firstocc);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[235] neq←╠firstocc ⎕AMBIV (noteq scalar)╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->neq = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5265, ptr5266, 0), cleanup, 
		    L"[238] split←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->split = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5267, ptr5268, 0), cleanup, 
		    L"[239] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->drop = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->drop)
		CHK(6, cleanup, L"[240] drp←split ⎕AMBIV ╠drop╣");
	
	*stkhd++ = retain_cell(loc->drop);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[240] drp←split ╠⎕AMBIV╣ drop");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->split)
		CHK(6, cleanup, L"[240] drp←╠split╣ ⎕AMBIV drop");
	
	*stkhd++ = retain_cell(loc->split);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[240] drp←╠split ⎕AMBIV drop╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->drp = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5269, ptr5270, 0), cleanup, 
		    L"[243] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->reverse_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5271, ptr5272, 0), cleanup, 
		    L"[244] rotate_last←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->rotate_last = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rotate_last)
		CHK(6, cleanup, L"[245] rot←reverse_last ⎕AMBIV ╠rotate_last╣");
	
	*stkhd++ = retain_cell(loc->rotate_last);
	
	if (!cdf_prim.q_ambiv)
		CHK(6, cleanup, L"[245] rot←reverse_last ╠⎕AMBIV╣ rotate_last");
	
	*stkhd++ = retain_cell(cdf_prim.q_ambiv);
	
	if (!loc->reverse_last)
		CHK(6, cleanup, L"[245] rot←╠reverse_last╣ ⎕AMBIV rotate_last");
	
	*stkhd++ = retain_cell(loc->reverse_last);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_func *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), cleanup,
		    L"[245] rot←╠reverse_last ⎕AMBIV rotate_last╣");
	
		release_func(x);
		release_doper(op);
		release_func(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5273, ptr5274, 0), cleanup, 
		    L"[248] map_monadic←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->map_monadic = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5275, ptr5276, ptr5277, ptr5278, 2), cleanup, 
		    L"[249] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	
		k->fv[0] = retain_cell(loc->chk_scl);
		k->fv[1] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->map_dyadic->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5279, ptr5280, ptr5281, ptr5282, 1), cleanup, 
		    L"[250] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	
		k->fv[0] = retain_cell(loc->map_dyadic);
	
		*stkhd++ = k;
	}
	
	loc->map = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5283, ptr5286, ptr5289, ptr5292, 0), cleanup, 
		    L"[253] reduce←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->reduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5295, ptr5298, ptr5301, ptr5304, 1), cleanup, 
		    L"[258] nwreduce←╠{op←⍺⍺¨╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->nwreduce->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr5307, ptr5308, ptr5309, ptr5310, 2), cleanup, 
		    L"[262] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	
		k->fv[0] = retain_cell(loc->nwreduce);
		k->fv[1] = retain_cell(loc->reduce);
	
		*stkhd++ = k;
	}
	
	loc->rdf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5311, ptr5312, 0), cleanup, 
		    L"[267] rpf←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->rpf = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr5313, ptr5314, ptr5315, ptr5316, ptr5317, ptr5318, ptr5319, ptr5320, 0), cleanup, 
		    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->dot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr5321, ptr5322, ptr5323, ptr5324, ptr5325, ptr5326, ptr5327, ptr5328, 0), cleanup, 
		    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->pow = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr5329, ptr5330, ptr5331, ptr5332, ptr5333, ptr5334, ptr5335, ptr5336, 0), cleanup, 
		    L"[276] jot←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->jot = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr5127(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[15] is_bool←{11≡⎕DR squeeze ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[15] is_bool←{11≡⎕DR ╠squeeze╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[15] is_bool←{11≡⎕DR ╠squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[15] is_bool←{11≡╠⎕DR╣ squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[15] is_bool←{11≡╠⎕DR squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[15] is_bool←{11╠≡╣⎕DR squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[15] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[15] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[15] is_bool←{╠11≡⎕DR squeeze ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[15] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	return err;
}

int
ptr5128(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[15] is_bool←{11≡⎕DR squeeze ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[15] is_bool←{11≡⎕DR ╠squeeze╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[15] is_bool←{11≡⎕DR ╠squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[15] is_bool←{11≡╠⎕DR╣ squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[15] is_bool←{11≡╠⎕DR squeeze ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[15] is_bool←{11╠≡╣⎕DR squeeze ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[15] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[15] is_bool←{╠11╣≡⎕DR squeeze ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[15] is_bool←{╠11≡⎕DR squeeze ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[15] is_bool←╠{11≡⎕DR squeeze ⍵}╣");
	return err;
}

int
ptr5129(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡╠⍴╣⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)╠≡╣⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴╠⍺╣)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(╠⍴╣⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,╣⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢╣,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1╠≡╣≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,╣⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢╣,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1╠≡╣≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴╣⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢╣⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)╠≡╣≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴╠⍺╣)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴╣⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (╠≢╣⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL╣ 5 ⋄ ⎕SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL╣ 4}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[18] chk_scl←╠{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	return err;
}

int
ptr5130(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡╠⍴╣⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)╠≡╣⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴╠⍺╣)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(╠⍴╣⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴╠⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,╣⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢╣,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1╠≡╣≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,╠⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,╣⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢╣,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1╠≡╣≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,╠⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴╣⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢╣⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)╠≡╣≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!alpha)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴╠⍺╣)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴╣⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (╠≢╣⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴╠⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL╣ 5 ⋄ ⎕SIGNAL 4}");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL╣ 4}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[18] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[18] chk_scl←╠{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	return err;
}

int
ptr5131(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5132, ptr5133, 0), cleanup, 
		    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5134, ptr5135, 1), cleanup, 
		    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[19] chk_valid_shape←╠{╣");
	return err;
}

int
ptr5132(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr5133(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr5134(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[21] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr5135(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[21] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr5136(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5137, ptr5138, 0), cleanup, 
		    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╠⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 4");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5139, ptr5140, 1), cleanup, 
		    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[21] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[22] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[19] chk_valid_shape←╠{╣");
	return err;
}

int
ptr5137(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr5138(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴╠⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[20] 	{rnk←≢╠⍴╣⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[20] 	{rnk←╠≢╣⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[20] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡╠rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0╠≡╣rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{╠rnk←≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡╠rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1╠≡╣rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[20] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	return err;
}

int
ptr5139(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[21] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr5140(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[21] 	{has_nat_vals ╠⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->has_nat_vals->value)
		CHK(6, cleanup, L"[21] 	{╠has_nat_vals╣ ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->has_nat_vals->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[21] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[21] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[21] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	return err;
}

int
ptr5141(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[24] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[24] both_simple←{╠is_simple╣ ⍺:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[24] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_simple->value)
				CHK(6, cleanup, L"[24] both_simple←{is_simple ⍺:╠is_simple╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[24] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[24] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5142(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[24] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[24] both_simple←{╠is_simple╣ ⍺:is_simple ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[24] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] both_simple←{is_simple ╠⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_simple->value)
				CHK(6, cleanup, L"[24] both_simple←{is_simple ⍺:╠is_simple╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_simple->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[24] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[24] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[24] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5143(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[25] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[25] both_numeric←{╠is_numeric╣ ⍺:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[25] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_numeric->value)
				CHK(6, cleanup, L"[25] both_numeric←{is_numeric ⍺:╠is_numeric╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[25] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[25] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5144(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[25] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[25] both_numeric←{╠is_numeric╣ ⍺:is_numeric ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[25] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] both_numeric←{is_numeric ╠⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_numeric->value)
				CHK(6, cleanup, L"[25] both_numeric←{is_numeric ⍺:╠is_numeric╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_numeric->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[25] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[25] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[25] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5145(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_char;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[26] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_char->value)
		CHK(6, cleanup, L"[26] both_char←{╠is_char╣ ⍺:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_char←{╠is_char ⍺╣:is_char ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[26] both_char←{is_char ⍺:is_char ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_char->value)
				CHK(6, cleanup, L"[26] both_char←{is_char ⍺:╠is_char╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_char←{is_char ⍺:╠is_char ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5146(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_char;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[26] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_char->value)
		CHK(6, cleanup, L"[26] both_char←{╠is_char╣ ⍺:is_char ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_char->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[26] both_char←{╠is_char ⍺╣:is_char ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[26] both_char←{is_char ╠⍺╣:is_char ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[26] both_char←{is_char ⍺:is_char ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_char->value)
				CHK(6, cleanup, L"[26] both_char←{is_char ⍺:╠is_char╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_char->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[26] both_char←{is_char ⍺:╠is_char ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[26] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[26] both_char←{is_char ⍺:is_char ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[26] both_char←╠{is_char ⍺:is_char ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5147(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[27] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[27] both_bool←{╠is_bool╣ ⍺:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[27] both_bool←{╠is_bool ⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[27] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_bool->value)
				CHK(6, cleanup, L"[27] both_bool←{is_bool ⍺:╠is_bool╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[27] both_bool←{is_bool ⍺:╠is_bool ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[27] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5148(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[27] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[27] both_bool←{╠is_bool╣ ⍺:is_bool ⍵ ⋄ 0}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[27] both_bool←{╠is_bool ⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[27] both_bool←{is_bool ╠⍺╣:is_bool ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ╠⍵╣ ⋄ 0}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->is_bool->value)
				CHK(6, cleanup, L"[27] both_bool←{is_bool ⍺:╠is_bool╣ ⍵ ⋄ 0}");
			
			*stkhd++ = retain_cell(lex->is_bool->value);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[27] both_bool←{is_bool ⍺:╠is_bool ⍵╣ ⋄ 0}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[27] both_bool←{is_bool ⍺:is_bool ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[27] both_bool←╠{is_bool ⍺:is_bool ⍵ ⋄ 0}╣");
	return err;
}

int
ptr5149(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[28] numeric←{⍺ ╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[28] numeric←{╠⍺╣ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[28] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5150(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[28] numeric←{⍺ ╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[28] numeric←{╠⍺╣ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[28] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5151(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[28] numeric←{⍺ ╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[28] numeric←{╠⍺╣ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[28] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5152(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[28] numeric←{⍺ ╠both_numeric╣ ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[28] numeric←{╠⍺╣ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[28] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[28] numeric←{⍺ both_numeric ╠⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ╠⍺⍺╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:╠⍺╣ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[28] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[28] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[28] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5153(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!self)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺╣ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s╠⍴╣⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s╣⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5154(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!self)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺╣ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s╠⍴╣⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s╣⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5155(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!self)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺╣ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s╠⍴╣⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s╣⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5156(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *both_simple;
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_simple->value)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ ╠both_simple╣ ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->both_simple->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺╣ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ╠⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ╠⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ╠⍺⍺╣ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺╣ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s╠⍴╣⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->s)
				CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s╣⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
			*stkhd++ = retain_cell(loc->s);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!self)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(self);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺╣ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s╠⍴╣⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s╣⍴⍺ ∇ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[29] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[29] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5157(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[32] rgt←{╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] rgt←╠{⍵}╣");
	return err;
}

int
ptr5158(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[32] rgt←{╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[32] rgt←╠{⍵}╣");
	return err;
}

int
ptr5159(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[35] lft←{╠⍵╣} ⎕AMBIV {⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] lft←╠{⍵}╣ ⎕AMBIV {⍺}");
	return err;
}

int
ptr5160(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[35] lft←{╠⍵╣} ⎕AMBIV {⍺}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] lft←╠{⍵}╣ ⎕AMBIV {⍺}");
	return err;
}

int
ptr5161(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[35] lft←{⍵} ⎕AMBIV {╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] lft←{⍵} ⎕AMBIV ╠{⍺}╣");
	return err;
}

int
ptr5162(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[35] lft←{⍵} ⎕AMBIV {╠⍺╣}");
	
	*stkhd++ = retain_cell(alpha);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[35] lft←{⍵} ⎕AMBIV ╠{⍺}╣");
	return err;
}

int
ptr5163(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[38] reshape←{╠chk_valid_shape╣ ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!reshape_ibeam)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ⍺╠('reshape_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(reshape_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺╣('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[38] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr5164(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[38] reshape←{╠chk_valid_shape╣ ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[38] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[38] reshape←{chk_valid_shape ╠⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!reshape_ibeam)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ⍺╠('reshape_ibeam'⌶)╣⍵}");
	
	*stkhd++ = retain_cell(reshape_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[38] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺╣('reshape_ibeam'⌶)⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[38] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[38] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	return err;
}

int
ptr5165(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5166(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[42] cat←('ravel_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5167(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[46] 	╠is_simple╣ ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5168, ptr5169, 0), cleanup, 
				    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[47] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[47] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[45] depth←╠{╣");
	return err;
}

int
ptr5168(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr5169(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr5170(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_simple->value)
		CHK(6, cleanup, L"[46] 	╠is_simple╣ ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(lex->is_simple->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ╠⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5171, ptr5172, 0), cleanup, 
				    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[47] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[47] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[47] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[47] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[45] depth←╠{╣");
	return err;
}

int
ptr5171(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr5172(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴╠⍵╣:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡≢╠⍴╣⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0≡╠≢╣⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[46] 	is_simple ⍵:{0╠≡╣≢⍴⍵:0 ⋄ 1}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[46] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[46] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[46] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
	return err;
}

int
ptr5173(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[52] nqv←{⊃⍴╠⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[52] nqv←{⊃╠⍴╣⍵} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[52] nqv←{⊃╠⍴⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[52] nqv←{╠⊃╣⍴⍵} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[52] nqv←{╠⊃⍴⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] nqv←╠{⊃⍴⍵}╣ ⎕AMBIV ('nqv_ibeam'⌶)");
	return err;
}

int
ptr5174(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[52] nqv←{⊃⍴╠⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[52] nqv←{⊃╠⍴╣⍵} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[52] nqv←{⊃╠⍴⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[52] nqv←{╠⊃╣⍴⍵} ⎕AMBIV ('nqv_ibeam'⌶)");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[52] nqv←{╠⊃⍴⍵╣} ⎕AMBIV ('nqv_ibeam'⌶)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[52] nqv←╠{⊃⍴⍵}╣ ⎕AMBIV ('nqv_ibeam'⌶)");
	return err;
}

int
ptr5175(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] materialize←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] materialize←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[55] materialize←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] materialize←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[55] materialize←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5176(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[55] materialize←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[55] materialize←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[55] materialize←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[55] materialize←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[55] materialize←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5177(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[56] index←{idx←⊃╠⍺╣ ⋄ rnk←≢⍴idx");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[56] index←{idx←╠⊃╣⍺ ⋄ rnk←≢⍴idx");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←╠⊃⍺╣ ⋄ rnk←≢⍴idx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->idx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←≢⍴╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴╣idx");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴idx╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←╠≢╣⍴idx");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←⊃⍺ ⋄ rnk←╠≢⍴idx╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[57] 	0≡is_integer ╠idx╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[57] 	0≡╠is_integer╣ idx:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[57] 	0≡╠is_integer idx╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[57] 	0╠≡╣is_integer idx:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[57] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[57] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[57] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[57] 	0≡is_integer ╠idx╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[57] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[57] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[57] 	0≡is_integer idx:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[57] 	0≡is_integer idx:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠rnk╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5178, ptr5179, 0), cleanup, 
		    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠rnk╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴idx('index_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!index_ibeam)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴idx╠('index_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(index_ibeam);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴╠idx╣('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(⍴idx)⍴╠idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[59] 	(⍴idx)╠⍴╣idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[59] 	(⍴╠idx╣)⍴idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[59] 	(╠⍴╣idx)⍴idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	╠(⍴idx)╣⍴idx('index_ibeam'⌶)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	╠(⍴idx)⍴idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[56] index←╠{idx←⊃⍺ ⋄ rnk←≢⍴idx╣");
	return err;
}

int
ptr5178(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	return err;
}

int
ptr5179(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	return err;
}

int
ptr5180(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[56] index←{idx←⊃╠⍺╣ ⋄ rnk←≢⍴idx");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[56] index←{idx←╠⊃╣⍺ ⋄ rnk←≢⍴idx");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←╠⊃⍺╣ ⋄ rnk←≢⍴idx");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->idx = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←≢⍴╠idx╣");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴╣idx");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴idx╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[56] index←{idx←⊃⍺ ⋄ rnk←╠≢╣⍴idx");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[56] index←{idx←⊃⍺ ⋄ rnk←╠≢⍴idx╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->rnk = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[57] 	0≡is_integer ╠idx╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[57] 	0≡╠is_integer╣ idx:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[57] 	0≡╠is_integer idx╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[57] 	0╠≡╣is_integer idx:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[57] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[57] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[57] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[57] 	0≡is_integer ╠idx╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[57] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[57] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[57] 	0≡is_integer idx:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[57] 	0≡is_integer idx:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->rnk)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠rnk╣:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(loc->rnk);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5181, ptr5182, 0), cleanup, 
		    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╠rnk╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL 16╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴idx('index_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!index_ibeam)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴idx╠('index_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(index_ibeam);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[59] 	(⍴idx)⍴╠idx╣('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	(⍴idx)⍴╠idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[59] 	(⍴idx)╠⍴╣idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->idx)
		CHK(6, cleanup, L"[59] 	(⍴╠idx╣)⍴idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(loc->idx);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[59] 	(╠⍴╣idx)⍴idx('index_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[59] 	╠(⍴idx)╣⍴idx('index_ibeam'⌶)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[59] 	╠(⍴idx)⍴idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[56] index←╠{idx←⊃⍺ ⋄ rnk←≢⍴idx╣");
	return err;
}

int
ptr5181(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	return err;
}

int
ptr5182(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡╠⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0╠≡╣⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡╠⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[58] 	{0≡⍵:0 ⋄ 1╠≡╣⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[58] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[58] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[58] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[58] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	return err;
}

int
ptr5183(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[65] 	chk_valid_shape ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[65] 	╠chk_valid_shape╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[65] 	╠chk_valid_shape ⍵╣: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	chk_valid_shape ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[66] 	0≡≢,╠⍵╣:⊂⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[66] 	0≡≢╠,╣⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[66] 	0≡≢╠,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[66] 	0≡╠≢╣,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[66] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[66] 	0╠≡╣≢,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[66] 	╠0╣≡≢,⍵:⊂⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[66] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[66] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[66] 	0≡≢,╠⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[66] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[66] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.par)
				CHK(6, cleanup, L"[66] 	0≡≢,⍵:╠⊂╣⍬");
			
			*stkhd++ = retain_cell(cdf_prim.par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[66] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[67] 	(,0)≡,╠⍵╣:⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[67] 	(,0)≡╠,╣⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	(,0)≡╠,⍵╣:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[67] 	(,0)╠≡╣,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] 	(,╠0╣)≡,⍵:⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[67] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[67] 	(╠,╣0)≡,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	╠(,0)╣≡,⍵:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	(,0)≡,╠⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[67] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[68] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[68] 	1≡≢╠,╣⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[68] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[68] 	1≡╠≢╣,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[68] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[68] 	1╠≡╣≢,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[68] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[68] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[68] 	1≡≢,⍵:'index_gen_vec'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!index_gen_vec)
				CHK(6, cleanup, L"[68] 	1≡≢,⍵:╠'index_gen_vec'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[68] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[69] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[69] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[69] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[69] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] index_gen←╠{╣");
	return err;
}

int
ptr5184(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[65] 	chk_valid_shape ╠⍵╣: ");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_valid_shape->value)
		CHK(6, cleanup, L"[65] 	╠chk_valid_shape╣ ⍵: ");
	
	*stkhd++ = retain_cell(lex->chk_valid_shape->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[65] 	╠chk_valid_shape ⍵╣: ");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[65] 	chk_valid_shape ╠⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[66] 	0≡≢,╠⍵╣:⊂⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[66] 	0≡≢╠,╣⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[66] 	0≡≢╠,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[66] 	0≡╠≢╣,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[66] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[66] 	0╠≡╣≢,⍵:⊂⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[66] 	╠0╣≡≢,⍵:⊂⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[66] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[66] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[66] 	0≡≢,╠⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[66] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[66] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.par)
				CHK(6, cleanup, L"[66] 	0≡≢,⍵:╠⊂╣⍬");
			
			*stkhd++ = retain_cell(cdf_prim.par);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[66] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[67] 	(,0)≡,╠⍵╣:⍬");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[67] 	(,0)≡╠,╣⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	(,0)≡╠,⍵╣:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[67] 	(,0)╠≡╣,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] 	(,╠0╣)≡,⍵:⍬");
	
		CHK(fill_array(arr, dat), cleanup, L"[67] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[67] 	(╠,╣0)≡,⍵:⍬");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[67] 	╠(,0)╣≡,⍵:⍬");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[67] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[67] 	(,0)≡,╠⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[67] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[68] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[68] 	1≡≢╠,╣⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[68] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[68] 	1≡╠≢╣,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[68] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[68] 	1╠≡╣≢,⍵:'index_gen_vec'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[68] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[68] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[68] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[68] 	1≡≢,╠⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[68] 	1≡≢,⍵:'index_gen_vec'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!index_gen_vec)
				CHK(6, cleanup, L"[68] 	1≡≢,⍵:╠'index_gen_vec'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(index_gen_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[68] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[69] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[69] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[69] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[69] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[64] index_gen←╠{╣");
	return err;
}

int
ptr5185(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[71] index_of←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[71] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[71] index_of←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[71] index_of←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[71] index_of←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5186(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[71] index_of←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[71] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[71] index_of←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[71] index_of←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[71] index_of←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5187(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5188(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[75] dis←('disclose_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5189(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[79] 	0≡≡╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[79] 	0≡╠≡╣⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[79] 	0≡╠≡⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[79] 	0╠≡╣≡⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[79] 	╠0╣≡≡⍵:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[79] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[79] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	0≡≡╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[79] 	0≡≡⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[80] 	'enclose_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!enclose_ibeam)
		CHK(6, cleanup, L"[80] 	╠'enclose_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[80] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] enclose←╠{╣");
	return err;
}

int
ptr5190(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[79] 	0≡≡╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[79] 	0≡╠≡╣⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[79] 	0≡╠≡⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[79] 	0╠≡╣≡⍵:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[79] 	╠0╣≡≡⍵:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[79] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[79] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[79] 	0≡≡╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[79] 	0≡≡⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[80] 	'enclose_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!enclose_ibeam)
		CHK(6, cleanup, L"[80] 	╠'enclose_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(enclose_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[80] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[78] enclose←╠{╣");
	return err;
}

int
ptr5191(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[82] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[82] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[82] par←enclose ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] par←enclose ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[82] par←enclose ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5192(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[82] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[82] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[82] par←enclose ⎕AMBIV {╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[82] par←enclose ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[82] par←enclose ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5193(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR ╠squeeze╣ ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[85] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[85] conjugate←{1289≡╠⎕DR╣ squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[85] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[85] conjugate←{1289╠≡╣⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[85] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ╠⍵╣ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!conjugate_vec)
				CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶╣ ⍵ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(conjugate_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[85] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶ ⍵╣ ⋄ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}╣");
	return err;
}

int
ptr5194(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->squeeze->value)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR ╠squeeze╣ ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(lex->squeeze->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[85] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[85] conjugate←{1289≡╠⎕DR╣ squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[85] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[85] conjugate←{1289╠≡╣⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[85] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[85] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[85] conjugate←{1289≡⎕DR squeeze ╠⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ╠⍵╣ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!conjugate_vec)
				CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶╣ ⍵ ⋄ ⍵}");
			
			*stkhd++ = retain_cell(conjugate_vec);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[85] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶ ⍵╣ ⋄ ⍵}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[85] conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[85] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}╣");
	return err;
}

int
ptr5195(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] negate←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] negate←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[89] negate←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[89] negate←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[89] negate←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5196(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] negate←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[89] negate←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[89] negate←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[89] negate←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[89] negate←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5197(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[93] sign←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[93] sign←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[93] sign←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[93] sign←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[93] sign←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5198(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[93] sign←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[93] sign←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[93] sign←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[93] sign←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[93] sign←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5199(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[97] recip←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[97] recip←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[97] recip←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] recip←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] recip←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5200(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[97] recip←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[97] recip←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[97] recip←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[97] recip←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[97] recip←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5201(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[102] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[102] 	0≡╠is_numeric╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[102] 	0≡╠is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[102] 	0╠≡╣is_numeric ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[102] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[102] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[102] 	╠0≡is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[102] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[102] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[102] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[102] 	0≡is_numeric ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[102] 	0≡is_numeric ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[103] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[103] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[103] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[103] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[103] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[103] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[103] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[103] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[103] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[103] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[103] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[103] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[104] 	'abs_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!abs_ibeam)
		CHK(6, cleanup, L"[104] 	╠'abs_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(abs_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	╠'abs_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[101] absolute←╠{╣");
	return err;
}

int
ptr5202(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[102] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_numeric->value)
		CHK(6, cleanup, L"[102] 	0≡╠is_numeric╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_numeric->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[102] 	0≡╠is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[102] 	0╠≡╣is_numeric ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[102] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[102] 	╠0╣≡is_numeric ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[102] 	╠0≡is_numeric ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[102] 	0≡is_numeric ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[102] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[102] 	0≡is_numeric ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[102] 	0≡is_numeric ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[102] 	0≡is_numeric ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[103] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[103] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[103] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[103] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[103] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[103] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[103] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[103] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[103] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[103] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[103] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[103] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[104] 	'abs_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!abs_ibeam)
		CHK(6, cleanup, L"[104] 	╠'abs_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(abs_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[104] 	╠'abs_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[101] absolute←╠{╣");
	return err;
}

int
ptr5203(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106] residue←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[106] residue←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[106] residue←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106] residue←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[106] residue←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5204(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106] residue←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[106] residue←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[106] residue←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[106] residue←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[106] residue←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5205(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[111] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[111] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[111] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[111] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[112] 	'floor_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!floor_vec_ibeam)
		CHK(6, cleanup, L"[112] 	╠'floor_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[112] 	╠'floor_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[110] floor_array←╠{╣");
	return err;
}

int
ptr5206(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[111] 	is_integer ╠⍵╣:⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[111] 	╠is_integer╣ ⍵:⍵");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[111] 	╠is_integer ⍵╣:⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] 	is_integer ╠⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[111] 	is_integer ⍵:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[112] 	'floor_vec_ibeam'⌶ ╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!floor_vec_ibeam)
		CHK(6, cleanup, L"[112] 	╠'floor_vec_ibeam'⌶╣ ⍵");
	
	*stkhd++ = retain_cell(floor_vec_ibeam);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[112] 	╠'floor_vec_ibeam'⌶ ⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[110] floor_array←╠{╣");
	return err;
}

int
ptr5207(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] pitimes←{3.14159265358979323846×╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[126] pitimes←{3.14159265358979323846╠×╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592654};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] pitimes←{╠3.14159265358979323846×⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] pitimes←╠{3.14159265358979323846×⍵}╣");
	return err;
}

int
ptr5208(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[126] pitimes←{3.14159265358979323846×╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[126] pitimes←{3.14159265358979323846╠×╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_DBL;
		unsigned int rnk = 0;
		double dat[] = {3.141592654};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[126] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[126] pitimes←{╠3.14159265358979323846╣×⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[126] pitimes←{╠3.14159265358979323846×⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[126] pitimes←╠{3.14159265358979323846×⍵}╣");
	return err;
}

int
ptr5209(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[128] 	1≠≢╠⍺╣:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[128] 	1≠╠≢╣⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	1≠╠≢⍺╣:⍺ ∇¨⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[128] 	1╠≠╣≢⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[128] 	╠1╣≠≢⍺:⍺ ∇¨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[128] 	╠1╣≠≢⍺:⍺ ∇¨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[128] 	╠1≠≢⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[128] 	1≠≢╠⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ∇¨╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.map)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ∇╠¨╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.map);
			
			if (!self)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ╠∇╣¨⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[128] 	1≠≢⍺:⍺ ╠∇¨╣⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:╠⍺╣ ∇¨⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[128] 	1≠≢⍺:╠⍺ ∇¨⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	0=╠⍺╣:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[129] 	0╠=╣⍺:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[129] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	╠0=⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	0=╠⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:(1-╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[129] 	0=⍺:(1╠-╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:╠(1-⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:╠(1-⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[130] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[130] 	1╠=╣⍺:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	╠1=⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[130] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[130] 	1=⍺:'sin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sin_vec_ibeam)
				CHK(6, cleanup, L"[130] 	1=⍺:╠'sin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[130] 	1=⍺:╠'sin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[131] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[131] 	¯1╠=╣⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[131] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[131] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] 	╠¯1=⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[131] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[131] 	¯1=⍺:'arcsin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsin_vec_ibeam)
				CHK(6, cleanup, L"[131] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[131] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[132] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[132] 	2╠=╣⍺:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[132] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[132] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[132] 	╠2=⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[132] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[132] 	2=⍺:'cos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cos_vec_ibeam)
				CHK(6, cleanup, L"[132] 	2=⍺:╠'cos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[132] 	2=⍺:╠'cos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[133] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[133] 	¯2╠=╣⍺:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[133] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[133] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[133] 	╠¯2=⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[133] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[133] 	¯2=⍺:'arccos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccos_vec_ibeam)
				CHK(6, cleanup, L"[133] 	¯2=⍺:╠'arccos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[133] 	¯2=⍺:╠'arccos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[134] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[134] 	3╠=╣⍺:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[134] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[134] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[134] 	╠3=⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[134] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[134] 	3=⍺:'tan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tan_vec_ibeam)
				CHK(6, cleanup, L"[134] 	3=⍺:╠'tan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[134] 	3=⍺:╠'tan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[135] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[135] 	¯3╠=╣⍺:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[135] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135] 	╠¯3=⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[135] 	¯3=⍺:'arctan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctan_vec_ibeam)
				CHK(6, cleanup, L"[135] 	¯3=⍺:╠'arctan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[135] 	¯3=⍺:╠'arctan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[136] 	4=╠⍺╣:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[136] 	4╠=╣⍺:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[136] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[136] 	╠4=⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136] 	4=╠⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:(1+╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[136] 	4=⍺:(1╠+╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:╠(1+⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:╠(1+⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[137] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[137] 	¯4╠=╣⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[137] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137] 	╠¯4=⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[137] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵╠+╣1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵╣+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)╠÷╣⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵╠-╣1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((╠⍵╣-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×(╠(⍵-1)╣÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)╠×╣((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵╠+╣1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(╠⍵╣+1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:╠(⍵+1)╣×((⍵-1)÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:╠(⍵+1)×((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[138] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[138] 	5╠=╣⍺:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[138] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138] 	╠5=⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[138] 	5=⍺:'sinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sinh_vec_ibeam)
				CHK(6, cleanup, L"[138] 	5=⍺:╠'sinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[138] 	5=⍺:╠'sinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[139] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[139] 	¯5╠=╣⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[139] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[139] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[139] 	╠¯5=⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[139] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[139] 	¯5=⍺:'arcsinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[139] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[139] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[140] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[140] 	6╠=╣⍺:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[140] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[140] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[140] 	╠6=⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[140] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[140] 	6=⍺:'cosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cosh_vec_ibeam)
				CHK(6, cleanup, L"[140] 	6=⍺:╠'cosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[140] 	6=⍺:╠'cosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[141] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[141] 	¯6╠=╣⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[141] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[141] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[141] 	╠¯6=⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[141] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[141] 	¯6=⍺:'arccosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccosh_vec_ibeam)
				CHK(6, cleanup, L"[141] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[141] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[142] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[142] 	7╠=╣⍺:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[142] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[142] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[142] 	╠7=⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[142] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[142] 	7=⍺:'tanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tanh_vec_ibeam)
				CHK(6, cleanup, L"[142] 	7=⍺:╠'tanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[142] 	7=⍺:╠'tanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[143] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[143] 	¯7╠=╣⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[143] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[143] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[143] 	╠¯7=⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[143] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[143] 	¯7=⍺:'arctanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctanh_vec_ibeam)
				CHK(6, cleanup, L"[143] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[143] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[144] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[144] 	8╠=╣⍺:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[144] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[144] 	╠8=⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[144] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+⍵*2)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+⍵╠*╣2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+╠⍵╣*2)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:(-1+╠⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1╠+╣⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:(-╠1+⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[144] 	8=⍺:(╠-╣1+⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[144] 	8=⍺:╠(-1+⍵*2)╣*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:╠(-1+⍵*2)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[145] 	¯8=╠⍺╣:-8○⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[145] 	¯8╠=╣⍺:-8○⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] 	╠¯8╣=⍺:-8○⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[145] 	╠¯8╣=⍺:-8○⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[145] 	╠¯8=⍺╣:-8○⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[145] 	¯8=╠⍺╣:-8○⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[145] 	¯8=⍺:-8○╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cir)
				CHK(6, cleanup, L"[145] 	¯8=⍺:-8╠○╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] 	¯8=⍺:-╠8╣○⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[145] 	¯8=⍺:-╠8╣○⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[145] 	¯8=⍺:-╠8○⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[145] 	¯8=⍺:╠-╣8○⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[145] 	¯8=⍺:╠-8○⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[146] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[146] 	9╠=╣⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	╠9=⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5210, ptr5211, 0), cleanup, 
				    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[147] 	¯9=╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[147] 	¯9╠=╣⍺:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[147] 	╠¯9╣=⍺:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[147] 	╠¯9╣=⍺:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[147] 	╠¯9=⍺╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[147] 	¯9=╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[147] 	¯9=⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[148] 	10=╠⍺╣:|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[148] 	10╠=╣⍺:|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[148] 	╠10╣=⍺:|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[148] 	╠10╣=⍺:|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[148] 	╠10=⍺╣:|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[148] 	10=╠⍺╣:|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[148] 	10=⍺:|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[148] 	10=⍺:╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[148] 	10=⍺:╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[149] 	¯10=╠⍺╣:+⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[149] 	¯10╠=╣⍺:+⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[149] 	╠¯10╣=⍺:+⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[149] 	╠¯10╣=⍺:+⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[149] 	╠¯10=⍺╣:+⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[149] 	¯10=╠⍺╣:+⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[149] 	¯10=⍺:+╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[149] 	¯10=⍺:╠+╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[149] 	¯10=⍺:╠+⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[150] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[150] 	11╠=╣⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	╠11=⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5212, ptr5213, 0), cleanup, 
				    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[151] 	¯11=╠⍺╣:⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[151] 	¯11╠=╣⍺:⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	╠¯11╣=⍺:⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[151] 	╠¯11╣=⍺:⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[151] 	╠¯11=⍺╣:⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[151] 	¯11=╠⍺╣:⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	¯11=⍺:⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[151] 	¯11=⍺:⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[151] 	¯11=⍺:⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[151] 	¯11=⍺:╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[151] 	¯11=⍺:╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[152] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[152] 	12╠=╣⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[152] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[152] 	╠12=⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[152] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[153] 	¯12=╠⍺╣:*⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[153] 	¯12╠=╣⍺:*⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	╠¯12╣=⍺:*⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] 	╠¯12╣=⍺:*⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[153] 	╠¯12=⍺╣:*⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[153] 	¯12=╠⍺╣:*⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	¯12=⍺:*⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[153] 	¯12=⍺:*⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[153] 	¯12=⍺:*⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[153] 	¯12=⍺:*╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[153] 	¯12=⍺:*╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[153] 	¯12=⍺:╠*╣⍵×0J1");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[153] 	¯12=⍺:╠*⍵×0J1╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[154] 	⎕SIGNAL ╠11╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[154] 	⎕SIGNAL ╠11╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[154] 	╠⎕SIGNAL╣ 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[154] 	╠⎕SIGNAL 11╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] trig←╠{╣");
	return err;
}

int
ptr5210(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr5211(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr5212(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr5213(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr5214(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[128] 	1≠≢╠⍺╣:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[128] 	1≠╠≢╣⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[128] 	1≠╠≢⍺╣:⍺ ∇¨⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.neq)
		CHK(6, cleanup, L"[128] 	1╠≠╣≢⍺:⍺ ∇¨⍵");
	
	*stkhd++ = retain_cell(cdf_prim.neq);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[128] 	╠1╣≠≢⍺:⍺ ∇¨⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[128] 	╠1╣≠≢⍺:⍺ ∇¨⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[128] 	╠1≠≢⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[128] 	1≠≢╠⍺╣:⍺ ∇¨⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ∇¨╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.map)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ∇╠¨╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.map);
			
			if (!self)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:⍺ ╠∇╣¨⍵");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[128] 	1≠≢⍺:⍺ ╠∇¨╣⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			if (!alpha)
				CHK(6, cleanup, L"[128] 	1≠≢⍺:╠⍺╣ ∇¨⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[128] 	1≠≢⍺:╠⍺ ∇¨⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[129] 	0=╠⍺╣:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[129] 	0╠=╣⍺:(1-⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[129] 	╠0╣=⍺:(1-⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[129] 	╠0=⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] 	0=╠⍺╣:(1-⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(1-⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(1-⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[129] 	0=⍺:(1-╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:(1-╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[129] 	0=⍺:(1╠-╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[129] 	0=⍺:(╠1╣-⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:╠(1-⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[129] 	0=⍺:╠(1-⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[130] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[130] 	1╠=╣⍺:'sin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[130] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[130] 	╠1╣=⍺:'sin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[130] 	╠1=⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[130] 	1=╠⍺╣:'sin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[130] 	1=⍺:'sin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sin_vec_ibeam)
				CHK(6, cleanup, L"[130] 	1=⍺:╠'sin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[130] 	1=⍺:╠'sin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[131] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[131] 	¯1╠=╣⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[131] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[131] 	╠¯1╣=⍺:'arcsin_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[131] 	╠¯1=⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[131] 	¯1=╠⍺╣:'arcsin_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[131] 	¯1=⍺:'arcsin_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsin_vec_ibeam)
				CHK(6, cleanup, L"[131] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsin_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[131] 	¯1=⍺:╠'arcsin_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[132] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[132] 	2╠=╣⍺:'cos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[132] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[132] 	╠2╣=⍺:'cos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[132] 	╠2=⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[132] 	2=╠⍺╣:'cos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[132] 	2=⍺:'cos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cos_vec_ibeam)
				CHK(6, cleanup, L"[132] 	2=⍺:╠'cos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[132] 	2=⍺:╠'cos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[133] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[133] 	¯2╠=╣⍺:'arccos_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[133] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[133] 	╠¯2╣=⍺:'arccos_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[133] 	╠¯2=⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[133] 	¯2=╠⍺╣:'arccos_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[133] 	¯2=⍺:'arccos_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccos_vec_ibeam)
				CHK(6, cleanup, L"[133] 	¯2=⍺:╠'arccos_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccos_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[133] 	¯2=⍺:╠'arccos_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[134] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[134] 	3╠=╣⍺:'tan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[134] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[134] 	╠3╣=⍺:'tan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[134] 	╠3=⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[134] 	3=╠⍺╣:'tan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[134] 	3=⍺:'tan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tan_vec_ibeam)
				CHK(6, cleanup, L"[134] 	3=⍺:╠'tan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[134] 	3=⍺:╠'tan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[135] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[135] 	¯3╠=╣⍺:'arctan_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[135] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[135] 	╠¯3╣=⍺:'arctan_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[135] 	╠¯3=⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[135] 	¯3=╠⍺╣:'arctan_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[135] 	¯3=⍺:'arctan_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctan_vec_ibeam)
				CHK(6, cleanup, L"[135] 	¯3=⍺:╠'arctan_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctan_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[135] 	¯3=⍺:╠'arctan_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[136] 	4=╠⍺╣:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[136] 	4╠=╣⍺:(1+⍵*2)*.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[136] 	╠4╣=⍺:(1+⍵*2)*.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[136] 	╠4=⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[136] 	4=╠⍺╣:(1+⍵*2)*.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(1+⍵*2)*╠.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+⍵*2)╠*╣.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(1+⍵*╠2╣)*.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+⍵╠*╣2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[136] 	4=⍺:(1+╠⍵╣*2)*.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:(1+╠⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[136] 	4=⍺:(1╠+╣⍵*2)*.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[136] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[136] 	4=⍺:(╠1╣+⍵*2)*.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:╠(1+⍵*2)╣*.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[136] 	4=⍺:╠(1+⍵*2)*.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[137] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[137] 	¯4╠=╣⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[137] 	╠¯4╣=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[137] 	╠¯4=⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[137] 	¯4=╠⍺╣:(⍵+1)×((⍵-1)÷⍵+1)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+╠1╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷⍵╠+╣1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵╣+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)÷╠⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.div)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-1)╠÷╣⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.div);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵-╠1╣)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((⍵╠-╣1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)×((╠⍵╣-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×(╠(⍵-1)╣÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:(⍵+1)×╠((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵+1)╠×╣((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[137] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[137] 	¯4=⍺:(⍵+╠1╣)×((⍵-1)÷⍵+1)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(⍵╠+╣1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			if (!omega)
				CHK(6, cleanup, L"[137] 	¯4=⍺:(╠⍵╣+1)×((⍵-1)÷⍵+1)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:╠(⍵+1)╣×((⍵-1)÷⍵+1)*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[137] 	¯4=⍺:╠(⍵+1)×((⍵-1)÷⍵+1)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[138] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[138] 	5╠=╣⍺:'sinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[138] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[138] 	╠5╣=⍺:'sinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[138] 	╠5=⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[138] 	5=╠⍺╣:'sinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[138] 	5=⍺:'sinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!sinh_vec_ibeam)
				CHK(6, cleanup, L"[138] 	5=⍺:╠'sinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(sinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[138] 	5=⍺:╠'sinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[139] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[139] 	¯5╠=╣⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-5};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[139] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[139] 	╠¯5╣=⍺:'arcsinh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[139] 	╠¯5=⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[139] 	¯5=╠⍺╣:'arcsinh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[139] 	¯5=⍺:'arcsinh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arcsinh_vec_ibeam)
				CHK(6, cleanup, L"[139] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arcsinh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[139] 	¯5=⍺:╠'arcsinh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[140] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[140] 	6╠=╣⍺:'cosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[140] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[140] 	╠6╣=⍺:'cosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[140] 	╠6=⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[140] 	6=╠⍺╣:'cosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[140] 	6=⍺:'cosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cosh_vec_ibeam)
				CHK(6, cleanup, L"[140] 	6=⍺:╠'cosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(cosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[140] 	6=⍺:╠'cosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[141] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[141] 	¯6╠=╣⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-6};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[141] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[141] 	╠¯6╣=⍺:'arccosh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[141] 	╠¯6=⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[141] 	¯6=╠⍺╣:'arccosh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[141] 	¯6=⍺:'arccosh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arccosh_vec_ibeam)
				CHK(6, cleanup, L"[141] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arccosh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[141] 	¯6=⍺:╠'arccosh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[142] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[142] 	7╠=╣⍺:'tanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[142] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[142] 	╠7╣=⍺:'tanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[142] 	╠7=⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[142] 	7=╠⍺╣:'tanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[142] 	7=⍺:'tanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!tanh_vec_ibeam)
				CHK(6, cleanup, L"[142] 	7=⍺:╠'tanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(tanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[142] 	7=⍺:╠'tanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[143] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[143] 	¯7╠=╣⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-7};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[143] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[143] 	╠¯7╣=⍺:'arctanh_vec_ibeam'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[143] 	╠¯7=⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[143] 	¯7=╠⍺╣:'arctanh_vec_ibeam'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[143] 	¯7=⍺:'arctanh_vec_ibeam'⌶ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!arctanh_vec_ibeam)
				CHK(6, cleanup, L"[143] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶╣ ⍵");
			
			*stkhd++ = retain_cell(arctanh_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[143] 	¯7=⍺:╠'arctanh_vec_ibeam'⌶ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[144] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[144] 	8╠=╣⍺:(-1+⍵*2)*0.5");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		CHK(fill_array(arr, dat), cleanup, L"[144] 	╠8╣=⍺:(-1+⍵*2)*0.5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[144] 	╠8=⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[144] 	8=╠⍺╣:(-1+⍵*2)*0.5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_DBL;
				unsigned int rnk = 0;
				double dat[] = {0.5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-1+⍵*2)*╠0.5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+⍵*2)╠*╣0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {2};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-1+⍵*╠2╣)*0.5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+⍵╠*╣2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			if (!omega)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1+╠⍵╣*2)*0.5");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:(-1+╠⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[144] 	8=⍺:(-1╠+╣⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {1};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[144] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				CHK(fill_array(arr, dat), cleanup, L"[144] 	8=⍺:(-╠1╣+⍵*2)*0.5");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:(-╠1+⍵*2)╣*0.5");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[144] 	8=⍺:(╠-╣1+⍵*2)*0.5");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[144] 	8=⍺:╠(-1+⍵*2)╣*0.5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[144] 	8=⍺:╠(-1+⍵*2)*0.5╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[145] 	¯8=╠⍺╣:-8○⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[145] 	¯8╠=╣⍺:-8○⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-8};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] 	╠¯8╣=⍺:-8○⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[145] 	╠¯8╣=⍺:-8○⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[145] 	╠¯8=⍺╣:-8○⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[145] 	¯8=╠⍺╣:-8○⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[145] 	¯8=⍺:-8○╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cir)
				CHK(6, cleanup, L"[145] 	¯8=⍺:-8╠○╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.cir);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {8};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[145] 	¯8=⍺:-╠8╣○⍵");
			
				CHK(fill_array(arr, dat), cleanup, L"[145] 	¯8=⍺:-╠8╣○⍵");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[145] 	¯8=⍺:-╠8○⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.sub)
				CHK(6, cleanup, L"[145] 	¯8=⍺:╠-╣8○⍵");
			
			*stkhd++ = retain_cell(cdf_prim.sub);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[145] 	¯8=⍺:╠-8○⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[146] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[146] 	9╠=╣⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	╠9╣=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	╠9=⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=╠⍺╣:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5215, ptr5216, 0), cleanup, 
				    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[147] 	¯9=╠⍺╣:⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[147] 	¯9╠=╣⍺:⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-9};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[147] 	╠¯9╣=⍺:⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[147] 	╠¯9╣=⍺:⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[147] 	╠¯9=⍺╣:⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[147] 	¯9=╠⍺╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[147] 	¯9=⍺:╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[148] 	10=╠⍺╣:|⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[148] 	10╠=╣⍺:|⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[148] 	╠10╣=⍺:|⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[148] 	╠10╣=⍺:|⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[148] 	╠10=⍺╣:|⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[148] 	10=╠⍺╣:|⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[148] 	10=⍺:|╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.res)
				CHK(6, cleanup, L"[148] 	10=⍺:╠|╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.res);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[148] 	10=⍺:╠|⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[149] 	¯10=╠⍺╣:+⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[149] 	¯10╠=╣⍺:+⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-10};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[149] 	╠¯10╣=⍺:+⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[149] 	╠¯10╣=⍺:+⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[149] 	╠¯10=⍺╣:+⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[149] 	¯10=╠⍺╣:+⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[149] 	¯10=⍺:+╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.add)
				CHK(6, cleanup, L"[149] 	¯10=⍺:╠+╣⍵");
			
			*stkhd++ = retain_cell(cdf_prim.add);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[149] 	¯10=⍺:╠+⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[150] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[150] 	11╠=╣⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	╠11╣=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	╠11=⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=╠⍺╣:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr5217, ptr5218, 0), cleanup, 
				    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[151] 	¯11=╠⍺╣:⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[151] 	¯11╠=╣⍺:⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	╠¯11╣=⍺:⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[151] 	╠¯11╣=⍺:⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[151] 	╠¯11=⍺╣:⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[151] 	¯11=╠⍺╣:⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[151] 	¯11=⍺:⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[151] 	¯11=⍺:⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[151] 	¯11=⍺:⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[151] 	¯11=⍺:╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[151] 	¯11=⍺:╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[152] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[152] 	12╠=╣⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		CHK(fill_array(arr, dat), cleanup, L"[152] 	╠12╣=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[152] 	╠12=⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[152] 	12=╠⍺╣:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[152] 	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'╠⎕SIGNAL╣ 16");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CHAR16;
				unsigned int rnk = 1;
				uint16_t dat[] = {80, 72, 65, 83, 69, 40, 9077, 41, 32, 78, 79, 84, 32, 73, 77, 80, 76, 69, 77, 69, 78, 84, 69, 68};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				arr->shape[0] = 24;
			
				CHK(fill_array(arr, dat), cleanup, L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'╣⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[152] 	12=⍺:╠'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[153] 	¯12=╠⍺╣:*⍵×0J1");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.eql)
		CHK(6, cleanup, L"[153] 	¯12╠=╣⍺:*⍵×0J1");
	
	*stkhd++ = retain_cell(cdf_prim.eql);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {-12};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	╠¯12╣=⍺:*⍵×0J1");
	
		CHK(fill_array(arr, dat), cleanup, L"[153] 	╠¯12╣=⍺:*⍵×0J1");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[153] 	╠¯12=⍺╣:*⍵×0J1");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[153] 	¯12=╠⍺╣:*⍵×0J1");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_CMPX;
				unsigned int rnk = 0;
				struct apl_cmpx dat[] = {{0, 1}};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[153] 	¯12=⍺:*⍵×╠0J1╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[153] 	¯12=⍺:*⍵×╠0J1╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.mul)
				CHK(6, cleanup, L"[153] 	¯12=⍺:*⍵╠×╣0J1");
			
			*stkhd++ = retain_cell(cdf_prim.mul);
			
			if (!omega)
				CHK(6, cleanup, L"[153] 	¯12=⍺:*╠⍵╣×0J1");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[153] 	¯12=⍺:*╠⍵×0J1╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.exp)
				CHK(6, cleanup, L"[153] 	¯12=⍺:╠*╣⍵×0J1");
			
			*stkhd++ = retain_cell(cdf_prim.exp);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[153] 	¯12=⍺:╠*⍵×0J1╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[154] 	⎕SIGNAL ╠11╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[154] 	⎕SIGNAL ╠11╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[154] 	╠⎕SIGNAL╣ 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[154] 	╠⎕SIGNAL 11╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[127] trig←╠{╣");
	return err;
}

int
ptr5215(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr5216(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ╠⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡╠⎕DR╣ ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[146] 	9=⍺:{1289≡╠⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289╠≡╣⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[146] 	9=⍺:{╠1289╣≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[146] 	9=⍺:{╠1289≡⎕DR ⍵╣:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ╠⍵╣ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!realpart_vec_ibeam)
				CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶╣ ⍵ ⋄ ⍵}⍵");
			
			*stkhd++ = retain_cell(realpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[146] 	9=⍺:{1289≡⎕DR ⍵:╠'realpart_vec_ibeam'⌶ ⍵╣ ⋄ ⍵}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[146] 	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ╠⍵╣}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[146] 	9=⍺:╠{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}╣⍵");
	return err;
}

int
ptr5217(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵╣");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr5218(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ╠⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡╠⎕DR╣ ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡╠⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289╠≡╣⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{╠1289╣≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{╠1289≡⎕DR ⍵╣:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ╠⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!imagpart_vec_ibeam)
				CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶╣ ⍵ ⋄ (⍴⍵)⍴0}⍵");
			
			*stkhd++ = retain_cell(imagpart_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[150] 	11=⍺:{1289≡⎕DR ⍵:╠'imagpart_vec_ibeam'⌶ ⍵╣ ⋄ (⍴⍵)⍴0}⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴╠0╣}⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)╠⍴╣0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!omega)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴╠⍵╣)⍴0}⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (╠⍴╣⍵)⍴0}⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)╣⍴0}⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[150] 	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ ╠(⍴⍵)⍴0╣}⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[150] 	11=⍺:╠{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}╣⍵");
	return err;
}

int
ptr5219(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~╠is_integer╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧(⍵<0)∧~╠is_integer ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧╠~╣is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧(⍵<0)∧╠~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)╠∧╣~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<╠0╣)∧~is_integer ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<╠0╣)∧~is_integer ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵╠<╣0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(╠⍵╣<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧╠(⍵<0)╣∧~is_integer ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧╠(⍵<0)∧~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)╠∧╣(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[160] 	(is_integer ╠⍵╣)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[160] 	(╠is_integer╣ ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	╠(is_integer ⍵)╣∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	╠(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!⍵-╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!⍵╠-╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!╠⍵╣-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	(!⍵)÷(!⍺)×!╠⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×╠!╣⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	(!⍵)÷(!⍺)×╠!⍵-⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)╠×╣!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!╠⍺╣)×!⍵-⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(╠!╣⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	(!⍵)÷╠(!⍺)╣×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	(!⍵)÷╠(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[161] 	(!⍵)╠÷╣(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[161] 	(!╠⍵╣)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(╠!╣⍵)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	╠(!⍵)╣÷(!⍺)×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	╠(!⍵)÷(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[159] binomial←╠{╣");
	return err;
}

int
ptr5220(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!alpha)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~╠is_integer╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧(⍵<0)∧~╠is_integer ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.not)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧╠~╣is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.not);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧(⍵<0)∧╠~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)╠∧╣~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<╠0╣)∧~is_integer ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<╠0╣)∧~is_integer ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵╠<╣0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!omega)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(╠⍵╣<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧╠(⍵<0)╣∧~is_integer ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	(is_integer ⍵)∧╠(⍵<0)∧~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.and)
		CHK(6, cleanup, L"[160] 	(is_integer ⍵)╠∧╣(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.and);
	
	if (!omega)
		CHK(6, cleanup, L"[160] 	(is_integer ╠⍵╣)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[160] 	(╠is_integer╣ ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[160] 	╠(is_integer ⍵)╣∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[160] 	╠(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[160] 	(is_integer ⍵)∧(⍵<0)∧~is_integer ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!⍵-╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!⍵╠-╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×!╠⍵╣-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	(!⍵)÷(!⍺)×!╠⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)×╠!╣⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	(!⍵)÷(!⍺)×╠!⍵-⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.mul)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!⍺)╠×╣!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.mul);
	
	if (!alpha)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(!╠⍺╣)×!⍵-⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(!⍵)÷(╠!╣⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	(!⍵)÷╠(!⍺)╣×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	(!⍵)÷╠(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.div)
		CHK(6, cleanup, L"[161] 	(!⍵)╠÷╣(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.div);
	
	if (!omega)
		CHK(6, cleanup, L"[161] 	(!╠⍵╣)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.fac)
		CHK(6, cleanup, L"[161] 	(╠!╣⍵)÷(!⍺)×!⍵-⍺");
	
	*stkhd++ = retain_cell(cdf_prim.fac);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[161] 	╠(!⍵)╣÷(!⍺)×!⍵-⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[161] 	╠(!⍵)÷(!⍺)×!⍵-⍺╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[159] binomial←╠{╣");
	return err;
}

int
ptr5221(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[166] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[166] notscl←{╠is_bool╣ ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] notscl←{╠is_bool ⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[166] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!not_vec_ibeam)
				CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[166] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[166] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5222(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *is_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[166] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->is_bool->value)
		CHK(6, cleanup, L"[166] notscl←{╠is_bool╣ ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->is_bool->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] notscl←{╠is_bool ⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[166] notscl←{is_bool ╠⍵╣:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!not_vec_ibeam)
				CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶╣ ⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(not_vec_ibeam);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[166] notscl←{is_bool ⍵:╠'not_vec_ibeam'⌶ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[166] notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[166] notscl←╠{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5223(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[167] without←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[167] without←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[167] without←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[167] without←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[167] without←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5224(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[167] without←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[167] without←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[167] without←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[167] without←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[167] without←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5225(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[172] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[172] 	⍺ ╠both_bool╣ ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[172] 	╠⍺╣ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[172] 	╠⍺ both_bool ⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[172] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!and_vec_ibeam)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:⍺╠('and_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(and_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:╠⍺╣('and_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[172] 	⍺ both_bool ⍵:╠⍺('and_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[173] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[173] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[173] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[173] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[171] logand←╠{╣");
	return err;
}

int
ptr5226(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[172] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[172] 	⍺ ╠both_bool╣ ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[172] 	╠⍺╣ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[172] 	╠⍺ both_bool ⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[172] 	⍺ both_bool ╠⍵╣:⍺('and_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!and_vec_ibeam)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:⍺╠('and_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(and_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[172] 	⍺ both_bool ⍵:╠⍺╣('and_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[172] 	⍺ both_bool ⍵:╠⍺('and_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[173] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[173] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[173] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[173] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[171] logand←╠{╣");
	return err;
}

int
ptr5227(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] and←{⎕SIGNAL ╠2╣}⎕AMBIV (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[175] and←{⎕SIGNAL ╠2╣}⎕AMBIV (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[175] and←{╠⎕SIGNAL╣ 2}⎕AMBIV (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[175] and←{╠⎕SIGNAL 2╣}⎕AMBIV (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[175] and←╠{⎕SIGNAL 2}╣⎕AMBIV (logand numeric scalar)");
	return err;
}

int
ptr5228(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[175] and←{⎕SIGNAL ╠2╣}⎕AMBIV (logand numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[175] and←{⎕SIGNAL ╠2╣}⎕AMBIV (logand numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[175] and←{╠⎕SIGNAL╣ 2}⎕AMBIV (logand numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[175] and←{╠⎕SIGNAL 2╣}⎕AMBIV (logand numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[175] and←╠{⎕SIGNAL 2}╣⎕AMBIV (logand numeric scalar)");
	return err;
}

int
ptr5229(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[179] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[179] 	⍺ ╠both_bool╣ ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[179] 	╠⍺╣ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[179] 	╠⍺ both_bool ⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[179] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lor_vec_ibeam)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:⍺╠('lor_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(lor_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:╠⍺╣('lor_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[179] 	⍺ both_bool ⍵:╠⍺('lor_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[180] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[180] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[180] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[180] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[178] logor←╠{╣");
	return err;
}

int
ptr5230(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[179] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[179] 	⍺ ╠both_bool╣ ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[179] 	╠⍺╣ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[179] 	╠⍺ both_bool ⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[179] 	⍺ both_bool ╠⍵╣:⍺('lor_vec_ibeam'⌶)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lor_vec_ibeam)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:⍺╠('lor_vec_ibeam'⌶)╣⍵");
			
			*stkhd++ = retain_cell(lor_vec_ibeam);
			
			if (!alpha)
				CHK(6, cleanup, L"[179] 	⍺ both_bool ⍵:╠⍺╣('lor_vec_ibeam'⌶)⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[179] 	⍺ both_bool ⍵:╠⍺('lor_vec_ibeam'⌶)⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[180] 	⎕SIGNAL ╠16╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[180] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[180] 	╠⎕SIGNAL╣ 16");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[180] 	╠⎕SIGNAL 16╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[178] logor←╠{╣");
	return err;
}

int
ptr5231(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[182] lor←{⎕SIGNAL ╠2╣}⎕AMBIV (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[182] lor←{⎕SIGNAL ╠2╣}⎕AMBIV (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[182] lor←{╠⎕SIGNAL╣ 2}⎕AMBIV (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[182] lor←{╠⎕SIGNAL 2╣}⎕AMBIV (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[182] lor←╠{⎕SIGNAL 2}╣⎕AMBIV (logor numeric scalar)");
	return err;
}

int
ptr5232(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[182] lor←{⎕SIGNAL ╠2╣}⎕AMBIV (logor numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[182] lor←{⎕SIGNAL ╠2╣}⎕AMBIV (logor numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[182] lor←{╠⎕SIGNAL╣ 2}⎕AMBIV (logor numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[182] lor←{╠⎕SIGNAL 2╣}⎕AMBIV (logor numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[182] lor←╠{⎕SIGNAL 2}╣⎕AMBIV (logor numeric scalar)");
	return err;
}

int
ptr5233(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[185] nan←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[185] nan←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[185] nan←{╠⎕SIGNAL╣ 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] nan←{╠⎕SIGNAL 2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[185] nan←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr5234(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[185] nan←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[185] nan←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[185] nan←{╠⎕SIGNAL╣ 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] nan←{╠⎕SIGNAL 2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[185] nan←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr5235(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ ╠both_bool╣ ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{╠⍺╣ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{╠⍺ both_bool ⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.and)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺╠∧╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.and);
			
			if (!alpha)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺╣∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~╣⍺∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5236(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ ╠both_bool╣ ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{╠⍺╣ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{╠⍺ both_bool ⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∧⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.and)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺╠∧╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.and);
			
			if (!alpha)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺╣∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~╣⍺∧⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~⍺∧⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[185] nan←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5237(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] nor←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] nor←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[188] nor←{╠⎕SIGNAL╣ 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] nor←{╠⎕SIGNAL 2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[188] nor←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr5238(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] nor←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] nor←{⎕SIGNAL ╠2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[188] nor←{╠⎕SIGNAL╣ 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] nor←{╠⎕SIGNAL 2╣}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[188] nor←╠{⎕SIGNAL 2}╣⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	return err;
}

int
ptr5239(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ ╠both_bool╣ ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{╠⍺╣ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{╠⍺ both_bool ⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.lor)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺╠∨╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.lor);
			
			if (!alpha)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺╣∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~╣⍺∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5240(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *both_bool;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_bool->value)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ ╠both_bool╣ ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(lex->both_bool->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{╠⍺╣ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{╠⍺ both_bool ⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ╠⍵╣:~⍺∨⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨╠⍵╣ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.lor)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺╠∨╣⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.lor);
			
			if (!alpha)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺╣∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~╠⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			if (!cdf_prim.not)
				CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~╣⍺∨⍵ ⋄ ⎕SIGNAL 11}");
			
			*stkhd++ = retain_cell(cdf_prim.not);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:╠~⍺∨⍵╣ ⋄ ⎕SIGNAL 11}");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL╣ 11}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[188] nor←{⎕SIGNAL 2}⎕AMBIV╠{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}╣");
	return err;
}

int
ptr5241(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[192] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[193] 	⍺('lth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lth_vec_ibeam)
		CHK(6, cleanup, L"[193] 	⍺╠('lth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[193] 	╠⍺╣('lth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[193] 	╠⍺('lth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[191] lessthan←╠{╣");
	return err;
}

int
ptr5242(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[192] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[192] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[193] 	⍺('lth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lth_vec_ibeam)
		CHK(6, cleanup, L"[193] 	⍺╠('lth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[193] 	╠⍺╣('lth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[193] 	╠⍺('lth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[191] lessthan←╠{╣");
	return err;
}

int
ptr5243(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[195] lth←{⎕SIGNAL ╠2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[195] lth←{⎕SIGNAL ╠2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[195] lth←{╠⎕SIGNAL╣ 2} ⎕AMBIV (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[195] lth←{╠⎕SIGNAL 2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[195] lth←╠{⎕SIGNAL 2}╣ ⎕AMBIV (lessthan numeric scalar)");
	return err;
}

int
ptr5244(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[195] lth←{⎕SIGNAL ╠2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[195] lth←{⎕SIGNAL ╠2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[195] lth←{╠⎕SIGNAL╣ 2} ⎕AMBIV (lessthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[195] lth←{╠⎕SIGNAL 2╣} ⎕AMBIV (lessthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[195] lth←╠{⎕SIGNAL 2}╣ ⎕AMBIV (lessthan numeric scalar)");
	return err;
}

int
ptr5245(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[199] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[199] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[199] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[199] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[199] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[199] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[199] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[200] 	⍺('lte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lte_vec_ibeam)
		CHK(6, cleanup, L"[200] 	⍺╠('lte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[200] 	╠⍺╣('lte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[200] 	╠⍺('lte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[198] lesseql←╠{╣");
	return err;
}

int
ptr5246(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[199] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[199] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[199] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[199] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[199] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[199] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[199] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[199] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[200] 	⍺('lte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lte_vec_ibeam)
		CHK(6, cleanup, L"[200] 	⍺╠('lte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(lte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[200] 	╠⍺╣('lte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[200] 	╠⍺('lte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[198] lesseql←╠{╣");
	return err;
}

int
ptr5247(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[202] lte←{⎕SIGNAL ╠2╣}⎕AMBIV (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[202] lte←{⎕SIGNAL ╠2╣}⎕AMBIV (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[202] lte←{╠⎕SIGNAL╣ 2}⎕AMBIV (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[202] lte←{╠⎕SIGNAL 2╣}⎕AMBIV (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[202] lte←╠{⎕SIGNAL 2}╣⎕AMBIV (lesseql numeric scalar)");
	return err;
}

int
ptr5248(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[202] lte←{⎕SIGNAL ╠2╣}⎕AMBIV (lesseql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[202] lte←{⎕SIGNAL ╠2╣}⎕AMBIV (lesseql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[202] lte←{╠⎕SIGNAL╣ 2}⎕AMBIV (lesseql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[202] lte←{╠⎕SIGNAL 2╣}⎕AMBIV (lesseql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[202] lte←╠{⎕SIGNAL 2}╣⎕AMBIV (lesseql numeric scalar)");
	return err;
}

int
ptr5249(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *eql_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[207] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[207] 	⍺ ╠both_numeric╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[207] 	╠⍺╣ both_numeric ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[207] 	╠⍺ both_numeric ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[207] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	⍺ both_numeric ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[208] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[208] 	⍺ ╠both_char╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[208] 	╠⍺╣ both_char ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[208] 	╠⍺ both_char ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[208] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[208] 	⍺ both_char ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[209] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[209] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[206] equal←╠{╣");
	return err;
}

int
ptr5250(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *eql_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[207] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[207] 	⍺ ╠both_numeric╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[207] 	╠⍺╣ both_numeric ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[207] 	╠⍺ both_numeric ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[207] 	⍺ both_numeric ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[207] 	⍺ both_numeric ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[207] 	⍺ both_numeric ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[208] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[208] 	⍺ ╠both_char╣ ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[208] 	╠⍺╣ both_char ⍵:⍺ eql_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[208] 	╠⍺ both_char ⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[208] 	⍺ both_char ╠⍵╣:⍺ eql_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:⍺ eql_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->eql_vec->value)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:⍺ ╠eql_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->eql_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[208] 	⍺ both_char ⍵:╠⍺╣ eql_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[208] 	⍺ both_char ⍵:╠⍺ eql_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[209] 	╠0╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[209] 	╠0╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[206] equal←╠{╣");
	return err;
}

int
ptr5251(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[211] eql←{⎕SIGNAL ╠2╣}⎕AMBIV (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[211] eql←{⎕SIGNAL ╠2╣}⎕AMBIV (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[211] eql←{╠⎕SIGNAL╣ 2}⎕AMBIV (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[211] eql←{╠⎕SIGNAL 2╣}⎕AMBIV (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[211] eql←╠{⎕SIGNAL 2}╣⎕AMBIV (equal scalar)");
	return err;
}

int
ptr5252(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[211] eql←{⎕SIGNAL ╠2╣}⎕AMBIV (equal scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[211] eql←{⎕SIGNAL ╠2╣}⎕AMBIV (equal scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[211] eql←{╠⎕SIGNAL╣ 2}⎕AMBIV (equal scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[211] eql←{╠⎕SIGNAL 2╣}⎕AMBIV (equal scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[211] eql←╠{⎕SIGNAL 2}╣⎕AMBIV (equal scalar)");
	return err;
}

int
ptr5253(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[215] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[215] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[215] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[215] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[216] 	⍺('gte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gte_vec_ibeam)
		CHK(6, cleanup, L"[216] 	⍺╠('gte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[216] 	╠⍺╣('gte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[216] 	╠⍺('gte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[214] greatereql←╠{╣");
	return err;
}

int
ptr5254(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[215] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[215] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[215] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[215] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[215] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[216] 	⍺('gte_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gte_vec_ibeam)
		CHK(6, cleanup, L"[216] 	⍺╠('gte_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gte_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[216] 	╠⍺╣('gte_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[216] 	╠⍺('gte_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[214] greatereql←╠{╣");
	return err;
}

int
ptr5255(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[218] gte←{⎕SIGNAL ╠2╣}⎕AMBIV (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[218] gte←{⎕SIGNAL ╠2╣}⎕AMBIV (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[218] gte←{╠⎕SIGNAL╣ 2}⎕AMBIV (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[218] gte←{╠⎕SIGNAL 2╣}⎕AMBIV (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[218] gte←╠{⎕SIGNAL 2}╣⎕AMBIV (greatereql numeric scalar)");
	return err;
}

int
ptr5256(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[218] gte←{⎕SIGNAL ╠2╣}⎕AMBIV (greatereql numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[218] gte←{⎕SIGNAL ╠2╣}⎕AMBIV (greatereql numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[218] gte←{╠⎕SIGNAL╣ 2}⎕AMBIV (greatereql numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[218] gte←{╠⎕SIGNAL 2╣}⎕AMBIV (greatereql numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[218] gte←╠{⎕SIGNAL 2}╣⎕AMBIV (greatereql numeric scalar)");
	return err;
}

int
ptr5257(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[222] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[222] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[222] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[223] 	⍺('gth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gth_vec_ibeam)
		CHK(6, cleanup, L"[223] 	⍺╠('gth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[223] 	╠⍺╣('gth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	╠⍺('gth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[221] greaterthan←╠{╣");
	return err;
}

int
ptr5258(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[222] 	1289≡╠⎕DR╣ ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[222] 	1289≡╠⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[222] 	1289╠≡╣⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	╠1289╣≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	╠1289≡⎕DR ⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1289≡⎕DR ╠⍵╣:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL ╠11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:╠⎕SIGNAL╣ 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1289≡⎕DR ⍵:╠⎕SIGNAL 11╣ ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.q_dr)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR╣ ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.q_dr);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡╠⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289╠≡╣⎕DR ⍺:⎕SIGNAL 11");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289╣≡⎕DR ⍺:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ ╠1289≡⎕DR ⍺╣:⎕SIGNAL 11");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ╠⍺╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL╣ 11");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[222] 	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:╠⎕SIGNAL 11╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[223] 	⍺('gth_vec_ibeam'⌶)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!gth_vec_ibeam)
		CHK(6, cleanup, L"[223] 	⍺╠('gth_vec_ibeam'⌶)╣⍵");
	
	*stkhd++ = retain_cell(gth_vec_ibeam);
	
	if (!alpha)
		CHK(6, cleanup, L"[223] 	╠⍺╣('gth_vec_ibeam'⌶)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[223] 	╠⍺('gth_vec_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[221] greaterthan←╠{╣");
	return err;
}

int
ptr5259(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] gth←{⎕SIGNAL ╠2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] gth←{⎕SIGNAL ╠2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[225] gth←{╠⎕SIGNAL╣ 2}⎕AMBIV (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[225] gth←{╠⎕SIGNAL 2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[225] gth←╠{⎕SIGNAL 2}╣⎕AMBIV (greaterthan numeric scalar)");
	return err;
}

int
ptr5260(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[225] gth←{⎕SIGNAL ╠2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		CHK(fill_array(arr, dat), cleanup, L"[225] gth←{⎕SIGNAL ╠2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[225] gth←{╠⎕SIGNAL╣ 2}⎕AMBIV (greaterthan numeric scalar)");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[225] gth←{╠⎕SIGNAL 2╣}⎕AMBIV (greaterthan numeric scalar)");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[225] gth←╠{⎕SIGNAL 2}╣⎕AMBIV (greaterthan numeric scalar)");
	return err;
}

int
ptr5261(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] firstocc←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] firstocc←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[228] firstocc←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] firstocc←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] firstocc←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5262(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[228] firstocc←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[228] firstocc←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[228] firstocc←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[228] firstocc←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[228] firstocc←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5263(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func_box *neq_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[231] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[231] 	⍺ ╠both_numeric╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[231] 	╠⍺╣ both_numeric ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	╠⍺ both_numeric ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[231] 	⍺ both_numeric ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[232] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[232] 	⍺ ╠both_char╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[232] 	╠⍺╣ both_char ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[232] 	╠⍺ both_char ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[232] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[232] 	⍺ both_char ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[233] 	╠1╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[233] 	╠1╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[230] noteq←╠{╣");
	return err;
}

int
ptr5264(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func_box *neq_vec;
		struct cell_func_box *both_char;
		struct cell_func_box *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[231] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_numeric->value)
		CHK(6, cleanup, L"[231] 	⍺ ╠both_numeric╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_numeric->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[231] 	╠⍺╣ both_numeric ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[231] 	╠⍺ both_numeric ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[231] 	⍺ both_numeric ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[231] 	⍺ both_numeric ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[231] 	⍺ both_numeric ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[232] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->both_char->value)
		CHK(6, cleanup, L"[232] 	⍺ ╠both_char╣ ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(lex->both_char->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[232] 	╠⍺╣ both_char ⍵:⍺ neq_vec ⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[232] 	╠⍺ both_char ⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[232] 	⍺ both_char ╠⍵╣:⍺ neq_vec ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:⍺ neq_vec ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->neq_vec->value)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:⍺ ╠neq_vec╣ ⍵");
			
			*stkhd++ = retain_cell(lex->neq_vec->value);
			
			if (!alpha)
				CHK(6, cleanup, L"[232] 	⍺ both_char ⍵:╠⍺╣ neq_vec ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[232] 	⍺ both_char ⍵:╠⍺ neq_vec ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[233] 	╠1╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[233] 	╠1╣");
	
		*stkhd++ = arr;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[230] noteq←╠{╣");
	return err;
}

int
ptr5265(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] split←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[238] split←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] split←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[238] split←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5266(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[238] split←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[238] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[238] split←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[238] split←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[238] split←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5267(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)╠-╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢╠⍵╣)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(╠≢╣⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+╠⍳╣(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺╠+╣⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] drop←{(⊂╠⍺╣+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[239] drop←{(╠⊂╣⍺+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[239] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	return err;
}

int
ptr5268(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-⍺)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-⍺)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)-╠⍺╣)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢⍵)╠-╣⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(≢╠⍵╣)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+⍳(╠≢╣⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺+╠⍳╣(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[239] drop←{(⊂⍺╠+╣⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[239] drop←{(⊂╠⍺╣+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[239] drop←{(╠⊂╣⍺+⍳(≢⍵)-⍺)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[239] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[239] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[239] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	return err;
}

int
ptr5269(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢╠⍵╣)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳╠≢╣⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+╠⍳╣≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1╠+╣⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[243] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)╠-╣1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢╠⍵╣)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(╠≢╣⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[243] reverse_last←{(╠⊂╣(≢⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[243] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	return err;
}

int
ptr5270(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)⌷╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)╠⌷╣⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳≢╠⍵╣)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+⍳╠≢╣⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1+╠⍳╣≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)-1╠+╣⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[243] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[243] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢⍵)╠-╣1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omega)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(≢╠⍵╣)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[243] reverse_last←{(⊂(╠≢╣⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[243] reverse_last←{(╠⊂╣(≢⍵)-1+⍳≢⍵)⌷⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[243] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[243] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[243] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	return err;
}

int
ptr5271(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] rotate_last←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[244] rotate_last←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[244] rotate_last←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5272(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[244] rotate_last←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[244] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[244] rotate_last←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[244] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[244] rotate_last←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5273(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[248] map_monadic←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[248] map_monadic←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[248] map_monadic←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[248] map_monadic←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[248] map_monadic←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5274(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[248] map_monadic←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[248] map_monadic←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[248] map_monadic←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[248] map_monadic←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[248] map_monadic←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5275(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺╣ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺╣ ⎕VEACH ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5276(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺╣ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺╣ ⎕VEACH ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5277(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺╣ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5278(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *chk_scl;
		struct cell_func_box *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->chk_scl->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ ╠chk_scl╣ ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->chk_scl->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{╠⍺╣ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[249] map_dyadic←{⍺ chk_scl ╠⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ╠⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->max_shp->value)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ ╠max_shp╣ ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(lex->max_shp->value);
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺╣ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.q_veach)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ╠⎕VEACH╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.q_veach);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺╣ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺╣ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s╠⍴╣⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	if (!loc->s)
		CHK(6, cleanup, L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s╣⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
	*stkhd++ = retain_cell(loc->s);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[249] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[249] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	return err;
}

int
ptr5279(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ map_dyadic ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->map_dyadic->value)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ ╠map_dyadic╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->map_dyadic->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[250] map←{⍺ ╠⍺⍺╣ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[250] map←{╠⍺╣ ⍺⍺ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[250] map←{╠⍺ ⍺⍺╣ map_dyadic ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	return err;
}

int
ptr5280(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ map_dyadic ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->map_dyadic->value)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ ╠map_dyadic╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->map_dyadic->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[250] map←{⍺ ╠⍺⍺╣ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[250] map←{╠⍺╣ ⍺⍺ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[250] map←{╠⍺ ⍺⍺╣ map_dyadic ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	return err;
}

int
ptr5281(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ map_dyadic ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->map_dyadic->value)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ ╠map_dyadic╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->map_dyadic->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[250] map←{⍺ ╠⍺⍺╣ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[250] map←{⍺ ╠⍺⍺ map_dyadic╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[250] map←{╠⍺╣ ⍺⍺ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	return err;
}

int
ptr5282(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ map_dyadic ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->map_dyadic->value)
		CHK(6, cleanup, L"[250] map←{⍺ ⍺⍺ ╠map_dyadic╣ ⍵}");
	
	*stkhd++ = retain_cell(lex->map_dyadic->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[250] map←{⍺ ╠⍺⍺╣ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[250] map←{⍺ ╠⍺⍺ map_dyadic╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[250] map←{╠⍺╣ ⍺⍺ map_dyadic ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[250] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[250] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	return err;
}

int
ptr5283(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[254] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[254] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0╠≡╣c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[255] 	0≡c:╠⎕SIGNAL╣ 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[255] 	0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5284, ptr5285, 2), cleanup, 
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[256] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[256] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[256] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] reduce←╠{╣");
	return err;
}

int
ptr5284(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5285(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5286(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[254] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[254] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0╠≡╣c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[255] 	0≡c:╠⎕SIGNAL╣ 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[255] 	0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5287, ptr5288, 2), cleanup, 
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[256] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[256] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[256] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] reduce←╠{╣");
	return err;
}

int
ptr5287(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5288(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5289(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[254] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[254] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0╠≡╣c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[255] 	0≡c:╠⎕SIGNAL╣ 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[255] 	0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5290, ptr5291, 2), cleanup, 
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[256] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[256] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[256] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] reduce←╠{╣");
	return err;
}

int
ptr5290(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5291(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5292(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_func_box *op;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢╠⍴╣⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[254] 	0≡╠≢╣⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[254] 	0╠≡╣≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[254] 	0≡≢⍴╠⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,╠⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.cat)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇╠,╣⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(cdf_prim.cat);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!self)
				CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:╠∇╣,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
			*stkhd++ = retain_cell(self);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[254] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴╠⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴╣⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->s = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃╠s╣ ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.dis)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃╣s ⋄ zs←1↓s");
	
	*stkhd++ = retain_cell(cdf_prim.dis);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	loc->c = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->s)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓╠s╣");
	
	*stkhd++ = retain_cell(loc->s);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1╠↓╣s");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		CHK(fill_array(arr, dat), cleanup, L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[254] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->zs = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0╠≡╣c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡╠c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[255] 	0≡c:╠⎕SIGNAL╣ 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[255] 	0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!loc->c)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(loc->c);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1╠≡╣c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		CHK(fill_array(arr, dat), cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡╠c╣:zs⍴⍵ ⋄ op←⍺⍺¨");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴╠⍵╣ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(omega);
			
			if (!cdf_prim.rho)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs╠⍴╣⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(cdf_prim.rho);
			
			if (!loc->zs)
				CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs╣⍴⍵ ⋄ op←⍺⍺¨");
			
			*stkhd++ = retain_cell(loc->zs);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣ ⋄ op←⍺⍺¨");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[255] 	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)╠⌷╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-╠1╣)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c╠-╣1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(╠c╣-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)╣⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←╠(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵╠⊣╣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵╣⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂╠⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂╣⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨╠⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}╠¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5293, ptr5294, 2), cleanup, 
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}¨╣⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-╠1╣){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c╠-╣1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!loc->c)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳╠c╣-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->c);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳╠c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[256] 	z⊣(⌽╠⍳╣c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣(⌽╠⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[256] 	z⊣(╠⌽╣⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1)╣{⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣╠(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z╠⊣╣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[256] 	╠z╣⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	╠z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[253] reduce←╠{╣");
	return err;
}

int
ptr5293(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5294(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op ╠z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)╠op╣ z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷╠⍵╣)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺╠⌷╣⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!alpha)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←(╠⍺╣⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬⊣z╠⊢╣←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){⍬⊣╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[256] 	z⊣(⌽⍳c-1){⍬╠⊣╣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[256] 	z⊣(⌽⍳c-1){╠⍬╣⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[256] 	z⊣(⌽⍳c-1){╠⍬⊣z⊢←(⍺⌷⍵)op z╣}¨⊂⍵⊣z←(c-1)⌷⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[256] 	z⊣(⌽⍳c-1)╠{⍬⊣z⊢←(⍺⌷⍵)op z}╣¨⊂⍵⊣z←(c-1)⌷⍵");
	return err;
}

int
ptr5295(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[258] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[258] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[258] nwreduce←{op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[259] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5296, ptr5297, 3), cleanup, 
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->z);
		k->fv[2] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[260] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[260] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr5296(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5297(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5298(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[258] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[258] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[258] nwreduce←{op←╠⍺⍺¨╣");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[259] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5299, ptr5300, 3), cleanup, 
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->z);
		k->fv[2] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[260] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[260] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr5299(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5300(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5301(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[258] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[258] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[258] nwreduce←{op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[259] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5302, ptr5303, 3), cleanup, 
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->z);
		k->fv[2] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[260] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[260] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr5302(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5303(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5304(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func_box *op;
		struct cell_array_box *rc;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func_box *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	CHK(mk_func_box(&loc->op, NULL), cleanup, L"Init mutable variable: loc->op");
	CHK(mk_array_box(&loc->rc, NULL), cleanup, L"Init mutable variable: loc->rc");
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.map)
		CHK(6, cleanup, L"[258] nwreduce←{op←⍺⍺╠¨╣");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[258] nwreduce←{op←╠⍺⍺╣¨");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[258] nwreduce←{op←╠⍺⍺¨╣");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	loc->op->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!lex->is_integer->value)
		CHK(6, cleanup, L"[259] 	0≡╠is_integer╣ ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(lex->is_integer->value);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡╠is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[259] 	0╠≡╣is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	╠0╣≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	╠0≡is_integer ⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ╠⍺╣:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL ╠11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL╣ 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:╠⎕SIGNAL 11╣ ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢╠⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢╣⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+╠≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1╠+╣≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1╣+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←╠1+≢⍵╣ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->rc->value = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc╠<╣⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	if (!loc->rc->value)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc╣<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
	*stkhd++ = retain_cell(loc->rc->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ ╠rc<⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<╠⍺╣:⎕SIGNAL 5 ⋄ rc-←|⍺");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				CHK(fill_array(arr, dat), cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL ╠5╣ ⋄ rc-←|⍺");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL╣ 5 ⋄ rc-←|⍺");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:╠⎕SIGNAL 5╣ ⋄ rc-←|⍺");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|╠⍺╣");
	
	*stkhd++ = retain_cell(alpha);
	
	if (!cdf_prim.res)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|╣⍺");
	
	*stkhd++ = retain_cell(cdf_prim.res);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←╠|⍺╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc╠-╣←|⍺");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_array_box *bx = loc->rc;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[259] 	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ ╠rc-←|⍺╣");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.drp)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)╠↓╣⍵");
	
	*stkhd++ = retain_cell(cdf_prim.drp);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-╠1╣)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺╠-╣1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(╠⍺╣-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)╣↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←╠(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	loc->z->value = retain_cell(stkhd[-1]);
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵╠⊣╣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵╣⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂╠⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂╣⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╠⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╠¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr5305, ptr5306, 3), cleanup, 
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		k->fv[0] = retain_cell(loc->rc);
		k->fv[1] = retain_cell(loc->z);
		k->fv[2] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨╣⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		CHK(fill_array(arr, dat), cleanup, L"[260] 	z⊣(⌽⍳⍺-╠1╣){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺╠-╣1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳╠⍺╣-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳╠⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽╠⍳╣⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽╠⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rot)
		CHK(6, cleanup, L"[260] 	z⊣(╠⌽╣⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1)╣{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣╠(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[260] 	z╠⊣╣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!loc->z->value)
		CHK(6, cleanup, L"[260] 	╠z╣⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(loc->z->value);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	╠z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[258] nwreduce←╠{op←⍺⍺¨╣");
	return err;
}

int
ptr5305(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5306(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *rc;
		struct cell_array_box *z;
		struct cell_func_box *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!lex->z->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op ╠z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->z->value);
	
	if (!lex->op->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)╠op╣ z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->op->value);
	
	if (!omega)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷╠⍵╣)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.sqd)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)╠⌷╣⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.sqd);
	
	if (!lex->rc->value)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳╠rc╣)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(lex->rc->value);
	
	if (!cdf_prim.iot)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳╣rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.iot);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+╠⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.add)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺╠+╣⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.add);
	
	if (!alpha)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺╣+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((⊂╠⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.par)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z⊢←((╠⊂╣⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.par);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←(╠(⊂⍺+⍳rc)╣⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)╣op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){z⊢←╠((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[260] 	z⊣(⌽⍳⍺-1){z╠⊢╣←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *x = bx->value;
	
		CHK((fn->fptr_dya)(&bx->value, x, y, fn), cleanup,
		    L"[260] 	z⊣(⌽⍳⍺-1){╠z⊢←((⊂⍺+⍳rc)⌷⍵)op z╣}¨⊂⍵⊣z←(⍺-1)↓⍵");
	
		release_array(*--stkhd);
		release_array(x);
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[260] 	z⊣(⌽⍳⍺-1)╠{z⊢←((⊂⍺+⍳rc)⌷⍵)op z}╣¨⊂⍵⊣z←(⍺-1)↓⍵");
	return err;
}

int
ptr5307(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[262] rdf←{⍺←╠⊢╣ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[263] 	⍬≡⍺╠⊣╣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺╠⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡╠⍺╣⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡╠⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[263] 	⍬╠≡╣⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	╠⍬≡⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr5308(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[263] 	⍬≡⍺╠⊣╣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡╠⍺╣⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	⍬≡╠⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[263] 	⍬╠≡╣⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	╠⍬≡⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_array(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr5309(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[262] rdf←{⍺←╠⊢╣ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[263] 	⍬≡⍺╠⊣╣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺╠⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡╠⍺╣⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡╠⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[263] 	⍬╠≡╣⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	╠⍬≡⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr5310(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper_box *nwreduce;
		struct cell_moper_box *reduce;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺╠⊣╣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺╣⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴╠⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rho)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴╣⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.rho);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢╠⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢╣⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<╠≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.lth)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1╠<╣≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lth);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ ╠1╣<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ ╠1<≢⍴⍺⊣0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣╠0╣:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL ╠4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL╣ 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:╠⎕SIGNAL 4╣ ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺╠⊣╣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺╣⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,╠⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.cat)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,╣⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.cat);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢╠,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢╣,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢╠≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.nqv)
		CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1╠≢╣≢,⍺⊣0:⎕SIGNAL 5");
	
	*stkhd++ = retain_cell(cdf_prim.nqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1╣≢≢,⍺⊣0:⎕SIGNAL 5");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ ╠1≢≢,⍺⊣0╣:⎕SIGNAL 5");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣╠0╣:⎕SIGNAL 5");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				CHK(fill_array(arr, dat), cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL ╠5╣");
			
				*stkhd++ = arr;
			}
			
			if (!cdf_prim.q_signal)
				CHK(6, cleanup, L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL╣ 5");
			
			*stkhd++ = retain_cell(cdf_prim.q_signal);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[262] rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:╠⎕SIGNAL 5╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.lft)
		CHK(6, cleanup, L"[263] 	⍬≡⍺╠⊣╣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.lft);
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡╠⍺╣⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	⍬≡╠⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[263] 	⍬╠≡╣⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		arr->shape[0] = 0;
	
		CHK(fill_array(arr, dat), cleanup, L"[263] 	╠⍬╣≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	╠⍬≡⍺⊣⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[263] 	⍬≡⍺⊣╠⍬╣:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ╠⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(omega);
			
			if (!lex->reduce->value)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ ╠reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(lex->reduce->value);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺╣ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *x = stkhd[-1];
				struct cell_moper *op = stkhd[-2];
				struct cell_func *dst;
			
				CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce╣ ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(x);
				release_moper(op);
				stkhd -= 2;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[263] 	⍬≡⍺⊣⍬:╠⍺⍺ reduce ⍵╣ ⋄ ⍺(⍺⍺ nwreduce)⍵");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)╠⍵╣");
	
	*stkhd++ = retain_cell(omega);
	
	if (!lex->nwreduce->value)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ ╠nwreduce╣)⍵");
	
	*stkhd++ = retain_cell(lex->nwreduce->value);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(╠⍺⍺╣ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺╠(⍺⍺ nwreduce)╣⍵");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺╣(⍺⍺ nwreduce)⍵");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[263] 	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ╠⍺(⍺⍺ nwreduce)⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[262] rdf←╠{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5╣");
	return err;
}

int
ptr5311(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[267] rpf←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[267] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[267] rpf←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[267] rpf←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[267] rpf←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5312(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[267] rpf←{⎕SIGNAL ╠16╣}");
	
		CHK(fill_array(arr, dat), cleanup, L"[267] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[267] rpf←{╠⎕SIGNAL╣ 16}");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[267] rpf←{╠⎕SIGNAL 16╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[267] rpf←╠{⎕SIGNAL 16}╣");
	return err;
}

int
ptr5313(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5314(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5315(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5316(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5317(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5318(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rpf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rpf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5319(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5320(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵¨ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!cdf_prim.map)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ⍵⍵╠¨╣ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.map);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵╣¨ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[270] dot←{⍺⍺⌿╠⍺╣ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[270] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rdf)
		CHK(6, cleanup, L"[270] dot←{⍺⍺╠⌿╣⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rdf);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[270] dot←{╠⍺⍺╣⌿⍺ ⍵⍵¨ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_moper *op = stkhd[-2];
		struct cell_func *dst;
	
		CHK(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), cleanup,
		    L"[270] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
		release_func(x);
		release_moper(op);
		stkhd -= 2;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[270] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[270] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	return err;
}

int
ptr5321(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5322(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5323(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5324(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[273] pow←{0╠≡╣⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{0≡╠⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5325(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5326(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *arr, **dat;
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = *--stkhd;
		dat[1] = *--stkhd;
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_aam, op->fptr_aad, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5327(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←╠⊢╣ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	alpha = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5328(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[273] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:╠⍵╣ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
			
			*stkhd++ = retain_cell(omega);
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	if (!omega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ╠⍵╣}");
	
	*stkhd++ = retain_cell(omega);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺╣ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺╣ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!cdf_prim.rgt)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢╣⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.rgt);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)╠⊢⍺ ⍺⍺ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		CHK(fill_array(arr, dat), cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.sub)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-╣1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(cdf_prim.sub);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!omegaomega)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(╠⍵⍵╣-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(omegaomega);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	if (!deldel)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇╣(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(deldel);
	
	if (!alphaalpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alphaalpha);
	
	{
		struct cell_func *x = stkhd[-1];
		struct cell_doper *op = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_func *dst;
	
		CHK(apply_dop(&dst, op, op->fptr_afm, op->fptr_afd, x, y), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_func(x);
		release_doper(op);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	if (!alpha)
		CHK(6, cleanup, L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺╣ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	*stkhd++ = retain_cell(alpha);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[273] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[273] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	return err;
}

int
ptr5329(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5330(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
				dat[2] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5331(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5332(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omegaomega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ⍺⍺ ╠⍵⍵╣");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:⍵ ╠⍺⍺╣ ⍵⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!omega)
				CHK(6, cleanup, L"[281] 	type≡0 3 2:╠⍵╣ ⍺⍺ ⍵⍵");
			
			*stkhd++ = retain_cell(omega);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5333(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5334(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *arr, **dat;
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, 
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺╣ ⍵⍵ ⍵");
				arr->shape[0] = 2;
				dat = arr->values;
			
				dat[0] = *--stkhd;
				dat[1] = *--stkhd;
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5335(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

int
ptr5336(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	struct {
		struct cell_array *type;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->type = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[277] 	type←╠⎕NC'⍺' '⍺⍺' '⍵⍵'╣");
	
		*stkhd++ = arr;
	}
	
	loc->type = retain_cell(stkhd[-1]);
	
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {2, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[278] 	type╠≡╣2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[278] 	╠type╣≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[278] 	╠type≡2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[278] 	type≡╠2 3 3╣:⍺ ⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:⍺ ⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:⍺ ╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			if (!alpha)
				CHK(6, cleanup, L"[278] 	type≡2 3 3:╠⍺╣ ⍺⍺ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alpha);
			
			{
				struct cell_array *x = stkhd[-1];
				struct cell_func *fn = stkhd[-2];
				struct cell_array *y = stkhd[-3];
				struct cell_array *dst;
			
				CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
				    L"[278] 	type≡2 3 3:╠⍺ ⍺⍺ ⍵⍵ ⍵╣");
			
				release_array(x);
				release_func(fn);
				release_array(y);
			
				stkhd -= 3;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[279] 	type╠≡╣0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[279] 	╠type╣≡0 3 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[279] 	╠type≡0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[279] 	type≡╠0 3 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[279] 	type≡0 3 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[279] 	type≡0 3 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 2, 3};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[280] 	type╠≡╣0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[280] 	╠type╣≡0 2 3:⍺⍺ ⍵⍵ ⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[280] 	╠type≡0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[280] 	type≡╠0 2 3╣:⍺⍺ ⍵⍵ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			if (!omega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ⍵⍵ ╠⍵╣");
			
			*stkhd++ = retain_cell(omega);
			
			if (!omegaomega)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵╣ ⍵");
			
			*stkhd++ = retain_cell(omegaomega);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:⍺⍺ ╠⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			if (!alphaalpha)
				CHK(6, cleanup, L"[280] 	type≡0 2 3:╠⍺⍺╣ ⍵⍵ ⍵");
			
			*stkhd++ = retain_cell(alphaalpha);
			
			{
				struct cell_func *fn = stkhd[-1];
				struct cell_array *y = stkhd[-2];
				struct cell_array *dst;
			
				CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
				    L"[280] 	type≡0 2 3:╠⍺⍺ ⍵⍵ ⍵╣");
			
				release_func(fn);
				release_array(y);
			
				stkhd -= 2;
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 1;
		int16_t dat[] = {0, 3, 2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		arr->shape[0] = 3;
	
		CHK(fill_array(arr, dat), cleanup, L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.eqv)
		CHK(6, cleanup, L"[281] 	type╠≡╣0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(cdf_prim.eqv);
	
	if (!loc->type)
		CHK(6, cleanup, L"[281] 	╠type╣≡0 3 2:⍵ ⍺⍺ ⍵⍵");
	
	*stkhd++ = retain_cell(loc->type);
	
	{
		struct cell_array *x = stkhd[-1];
		struct cell_func *fn = stkhd[-2];
		struct cell_array *y = stkhd[-3];
		struct cell_array *dst;
	
		CHK((fn->fptr_dya)(&dst, x, y, fn), cleanup,
		    L"[281] 	╠type≡0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		stkhd -= 3;
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[281] 	type≡╠0 3 2╣:⍵ ⍺⍺ ⍵⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			CHK(2, cleanup, L"[281] 	type≡0 3 2:╠⍵ ⍺⍺ ⍵⍵╣");
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {2};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		CHK(fill_array(arr, dat), cleanup, L"[282] 	⎕SIGNAL ╠2╣");
	
		*stkhd++ = arr;
	}
	
	if (!cdf_prim.q_signal)
		CHK(6, cleanup, L"[282] 	╠⎕SIGNAL╣ 2");
	
	*stkhd++ = retain_cell(cdf_prim.q_signal);
	
	{
		struct cell_func *fn = stkhd[-1];
		struct cell_array *y = stkhd[-2];
		struct cell_array *dst;
	
		CHK((fn->fptr_mon)(&dst, y, fn), cleanup,
		    L"[282] 	╠⎕SIGNAL 2╣");
	
		release_func(fn);
		release_array(y);
	
		stkhd -= 2;
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));

	if (err)
		return err;

	TRC(chk_array_valid(*z), 
	    L"[276] jot←╠{╣");
	return err;
}

EXPORT int
q_signal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->q_signal;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_signal_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_signal, z, l, r, L"q_signal");
}

EXPORT int
q_dr(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->q_dr;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_dr_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_dr, z, l, r, L"q_dr");
}

EXPORT int
squeeze(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->squeeze->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
squeeze_dwa(void *z, void *l, void *r)
{
	return call_dwa(squeeze, z, l, r, L"squeeze");
}

EXPORT int
is_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->is_simple->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_simple, z, l, r, L"is_simple");
}

EXPORT int
is_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->is_numeric->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_numeric, z, l, r, L"is_numeric");
}

EXPORT int
is_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->is_char->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_char, z, l, r, L"is_char");
}

EXPORT int
is_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->is_integer->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_integer, z, l, r, L"is_integer");
}

EXPORT int
is_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->is_bool->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_bool, z, l, r, L"is_bool");
}

EXPORT int
max_shp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->max_shp->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
max_shp_dwa(void *z, void *l, void *r)
{
	return call_dwa(max_shp, z, l, r, L"max_shp");
}

EXPORT int
has_nat_vals(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->has_nat_vals->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
has_nat_vals_dwa(void *z, void *l, void *r)
{
	return call_dwa(has_nat_vals, z, l, r, L"has_nat_vals");
}

EXPORT int
chk_scl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->chk_scl->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_scl_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_scl, z, l, r, L"chk_scl");
}

EXPORT int
chk_valid_shape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->chk_valid_shape->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_valid_shape_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_valid_shape, z, l, r, L"chk_valid_shape");
}

EXPORT int
both_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->both_simple->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_simple, z, l, r, L"both_simple");
}

EXPORT int
both_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->both_numeric->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_numeric, z, l, r, L"both_numeric");
}

EXPORT int
both_char(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->both_char->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_char_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_char, z, l, r, L"both_char");
}

EXPORT int
both_bool(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->both_bool->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_bool_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_bool, z, l, r, L"both_bool");
}

EXPORT int
rgt(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->rgt;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rgt_dwa(void *z, void *l, void *r)
{
	return call_dwa(rgt, z, l, r, L"rgt");
}

EXPORT int
lft(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lft;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lft_dwa(void *z, void *l, void *r)
{
	return call_dwa(lft, z, l, r, L"lft");
}

EXPORT int
reshape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->reshape;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reshape_dwa(void *z, void *l, void *r)
{
	return call_dwa(reshape, z, l, r, L"reshape");
}

EXPORT int
rho(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->rho;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rho_dwa(void *z, void *l, void *r)
{
	return call_dwa(rho, z, l, r, L"rho");
}

EXPORT int
cat(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->cat;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
cat_dwa(void *z, void *l, void *r)
{
	return call_dwa(cat, z, l, r, L"cat");
}

EXPORT int
depth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->depth;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
depth_dwa(void *z, void *l, void *r)
{
	return call_dwa(depth, z, l, r, L"depth");
}

EXPORT int
eqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->eqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
eqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(eqv, z, l, r, L"eqv");
}

EXPORT int
nqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->nqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
nqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(nqv, z, l, r, L"nqv");
}

EXPORT int
materialize(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->materialize;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
materialize_dwa(void *z, void *l, void *r)
{
	return call_dwa(materialize, z, l, r, L"materialize");
}

EXPORT int
index(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->index;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_dwa(void *z, void *l, void *r)
{
	return call_dwa(index, z, l, r, L"index");
}

EXPORT int
sqd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->sqd;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sqd_dwa(void *z, void *l, void *r)
{
	return call_dwa(sqd, z, l, r, L"sqd");
}

EXPORT int
index_gen(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->index_gen;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_gen_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_gen, z, l, r, L"index_gen");
}

EXPORT int
index_of(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->index_of;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_of_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_of, z, l, r, L"index_of");
}

EXPORT int
iot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->iot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
iot_dwa(void *z, void *l, void *r)
{
	return call_dwa(iot, z, l, r, L"iot");
}

EXPORT int
dis(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->dis;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
dis_dwa(void *z, void *l, void *r)
{
	return call_dwa(dis, z, l, r, L"dis");
}

EXPORT int
enclose(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->enclose;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
enclose_dwa(void *z, void *l, void *r)
{
	return call_dwa(enclose, z, l, r, L"enclose");
}

EXPORT int
par(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->par;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
par_dwa(void *z, void *l, void *r)
{
	return call_dwa(par, z, l, r, L"par");
}

EXPORT int
conjugate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->conjugate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
conjugate_dwa(void *z, void *l, void *r)
{
	return call_dwa(conjugate, z, l, r, L"conjugate");
}

EXPORT int
add(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->add;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
add_dwa(void *z, void *l, void *r)
{
	return call_dwa(add, z, l, r, L"add");
}

EXPORT int
negate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->negate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
negate_dwa(void *z, void *l, void *r)
{
	return call_dwa(negate, z, l, r, L"negate");
}

EXPORT int
sub(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->sub;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sub_dwa(void *z, void *l, void *r)
{
	return call_dwa(sub, z, l, r, L"sub");
}

EXPORT int
sign(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->sign;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sign_dwa(void *z, void *l, void *r)
{
	return call_dwa(sign, z, l, r, L"sign");
}

EXPORT int
mul(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->mul;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
mul_dwa(void *z, void *l, void *r)
{
	return call_dwa(mul, z, l, r, L"mul");
}

EXPORT int
recip(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->recip;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
recip_dwa(void *z, void *l, void *r)
{
	return call_dwa(recip, z, l, r, L"recip");
}

EXPORT int
div(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->div;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
div_dwa(void *z, void *l, void *r)
{
	return call_dwa(div, z, l, r, L"div");
}

EXPORT int
absolute(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->absolute;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
absolute_dwa(void *z, void *l, void *r)
{
	return call_dwa(absolute, z, l, r, L"absolute");
}

EXPORT int
residue(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->residue;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
residue_dwa(void *z, void *l, void *r)
{
	return call_dwa(residue, z, l, r, L"residue");
}

EXPORT int
res(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->res;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
res_dwa(void *z, void *l, void *r)
{
	return call_dwa(res, z, l, r, L"res");
}

EXPORT int
floor_array(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->floor_array;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
floor_array_dwa(void *z, void *l, void *r)
{
	return call_dwa(floor_array, z, l, r, L"floor_array");
}

EXPORT int
min(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->min;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
min_dwa(void *z, void *l, void *r)
{
	return call_dwa(min, z, l, r, L"min");
}

EXPORT int
max(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->max;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
max_dwa(void *z, void *l, void *r)
{
	return call_dwa(max, z, l, r, L"max");
}

EXPORT int
exp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->exp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
exp_dwa(void *z, void *l, void *r)
{
	return call_dwa(exp, z, l, r, L"exp");
}

EXPORT int
log(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->log;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
log_dwa(void *z, void *l, void *r)
{
	return call_dwa(log, z, l, r, L"log");
}

EXPORT int
pitimes(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->pitimes;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
pitimes_dwa(void *z, void *l, void *r)
{
	return call_dwa(pitimes, z, l, r, L"pitimes");
}

EXPORT int
trig(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->trig;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
trig_dwa(void *z, void *l, void *r)
{
	return call_dwa(trig, z, l, r, L"trig");
}

EXPORT int
cir(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->cir;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
cir_dwa(void *z, void *l, void *r)
{
	return call_dwa(cir, z, l, r, L"cir");
}

EXPORT int
binomial(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->binomial;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
binomial_dwa(void *z, void *l, void *r)
{
	return call_dwa(binomial, z, l, r, L"binomial");
}

EXPORT int
fac(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->fac;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
fac_dwa(void *z, void *l, void *r)
{
	return call_dwa(fac, z, l, r, L"fac");
}

EXPORT int
notscl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->notscl;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
notscl_dwa(void *z, void *l, void *r)
{
	return call_dwa(notscl, z, l, r, L"notscl");
}

EXPORT int
without(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->without;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
without_dwa(void *z, void *l, void *r)
{
	return call_dwa(without, z, l, r, L"without");
}

EXPORT int
not(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->not;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
not_dwa(void *z, void *l, void *r)
{
	return call_dwa(not, z, l, r, L"not");
}

EXPORT int
logand(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->logand;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
logand_dwa(void *z, void *l, void *r)
{
	return call_dwa(logand, z, l, r, L"logand");
}

EXPORT int
and(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->and;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
and_dwa(void *z, void *l, void *r)
{
	return call_dwa(and, z, l, r, L"and");
}

EXPORT int
logor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->logor;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
logor_dwa(void *z, void *l, void *r)
{
	return call_dwa(logor, z, l, r, L"logor");
}

EXPORT int
lor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lor;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lor_dwa(void *z, void *l, void *r)
{
	return call_dwa(lor, z, l, r, L"lor");
}

EXPORT int
nan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->nan;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
nan_dwa(void *z, void *l, void *r)
{
	return call_dwa(nan, z, l, r, L"nan");
}

EXPORT int
nor(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->nor;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
nor_dwa(void *z, void *l, void *r)
{
	return call_dwa(nor, z, l, r, L"nor");
}

EXPORT int
lessthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lessthan;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lessthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(lessthan, z, l, r, L"lessthan");
}

EXPORT int
lth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lth;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lth_dwa(void *z, void *l, void *r)
{
	return call_dwa(lth, z, l, r, L"lth");
}

EXPORT int
lesseql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lesseql;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lesseql_dwa(void *z, void *l, void *r)
{
	return call_dwa(lesseql, z, l, r, L"lesseql");
}

EXPORT int
lte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->lte;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lte_dwa(void *z, void *l, void *r)
{
	return call_dwa(lte, z, l, r, L"lte");
}

EXPORT int
eql_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->eql_vec->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
eql_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(eql_vec, z, l, r, L"eql_vec");
}

EXPORT int
equal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->equal;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
equal_dwa(void *z, void *l, void *r)
{
	return call_dwa(equal, z, l, r, L"equal");
}

EXPORT int
eql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->eql;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
eql_dwa(void *z, void *l, void *r)
{
	return call_dwa(eql, z, l, r, L"eql");
}

EXPORT int
greatereql(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->greatereql;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
greatereql_dwa(void *z, void *l, void *r)
{
	return call_dwa(greatereql, z, l, r, L"greatereql");
}

EXPORT int
gte(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->gte;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
gte_dwa(void *z, void *l, void *r)
{
	return call_dwa(gte, z, l, r, L"gte");
}

EXPORT int
greaterthan(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->greaterthan;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
greaterthan_dwa(void *z, void *l, void *r)
{
	return call_dwa(greaterthan, z, l, r, L"greaterthan");
}

EXPORT int
gth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->gth;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
gth_dwa(void *z, void *l, void *r)
{
	return call_dwa(gth, z, l, r, L"gth");
}

EXPORT int
firstocc(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->firstocc;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
firstocc_dwa(void *z, void *l, void *r)
{
	return call_dwa(firstocc, z, l, r, L"firstocc");
}

EXPORT int
neq_vec(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->neq_vec->value;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
neq_vec_dwa(void *z, void *l, void *r)
{
	return call_dwa(neq_vec, z, l, r, L"neq_vec");
}

EXPORT int
noteq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->noteq;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
noteq_dwa(void *z, void *l, void *r)
{
	return call_dwa(noteq, z, l, r, L"noteq");
}

EXPORT int
neq(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->neq;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
neq_dwa(void *z, void *l, void *r)
{
	return call_dwa(neq, z, l, r, L"neq");
}

EXPORT int
split(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->split;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
split_dwa(void *z, void *l, void *r)
{
	return call_dwa(split, z, l, r, L"split");
}

EXPORT int
drop(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->drop;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drop_dwa(void *z, void *l, void *r)
{
	return call_dwa(drop, z, l, r, L"drop");
}

EXPORT int
drp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->drp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drp_dwa(void *z, void *l, void *r)
{
	return call_dwa(drp, z, l, r, L"drp");
}

EXPORT int
reverse_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->reverse_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reverse_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(reverse_last, z, l, r, L"reverse_last");
}

EXPORT int
rotate_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->rotate_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rotate_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(rotate_last, z, l, r, L"rotate_last");
}

EXPORT int
rot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->rot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rot_dwa(void *z, void *l, void *r)
{
	return call_dwa(rot, z, l, r, L"rot");
}

EXPORT int
map_monadic(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->map_monadic;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
map_monadic_dwa(void *z, void *l, void *r)
{
	return call_dwa(map_monadic, z, l, r, L"map_monadic");
}

EXPORT int
rpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;
	struct cdf_prim_loc *loc;

	cdf_prim_init();

	loc = &cdf_prim;
	self = loc->rpf;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(rpf, z, l, r, L"rpf");
}

