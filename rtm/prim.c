#include "codfns.h"

EXPORT int
DyalogGetInterpreterFunctions(void *p)
{
    return set_dwafns(p);
}

extern struct cell_func *q_signal_ibeam;
extern struct cell_func *q_dr_ibeam;
extern struct cell_moper *q_veach_ibeam;
extern struct cell_doper *q_ambiv_ibeam;
extern struct cell_func *squeeze_ibeam;
extern struct cell_func *is_simple_ibeam;
extern struct cell_func *is_numeric_ibeam;
extern struct cell_func *is_integer_ibeam;
extern struct cell_func *max_shp_ibeam;
extern struct cell_func *has_nat_vals_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *reshape_ibeam;
extern struct cell_func *shape_ibeam;
extern struct cell_func *ravel_ibeam;
extern struct cell_func *same_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_ibeam;
extern struct cell_func *index_gen_vec;
extern struct cell_func *index_gen_vec;
extern struct cell_func *disclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *enclose_ibeam;
extern struct cell_func *conjugate_vec;
extern struct cell_func *conjugate_vec;
extern struct cell_func *add_vec_ibeam;
extern struct cell_func *sub_vec_ibeam;
extern struct cell_func *mul_vec_ibeam;
extern struct cell_func *div_vec_ibeam;
extern struct cell_func *exp_vec_ibeam;
extern struct cell_func *pow_vec_ibeam;

int ptr2555(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2556(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2557(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2558(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2559(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2560(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2561(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2562(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2563(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2564(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2565(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2566(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2567(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2568(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2569(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2570(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2571(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2572(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2573(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2574(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2575(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2576(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2577(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2578(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2579(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2580(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2581(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2582(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2583(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2584(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2585(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2586(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2587(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2588(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2589(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2590(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2591(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2592(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2593(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2594(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2595(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2596(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2597(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2598(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2599(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2600(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2601(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2602(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2603(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2604(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2605(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2606(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2607(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2608(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2609(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2610(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2611(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2612(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2613(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2614(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2615(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2616(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2617(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2618(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2619(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2620(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2621(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2622(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2623(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2624(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2625(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2626(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2627(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2628(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2629(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2630(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2631(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2632(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2633(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2634(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2635(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2636(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2637(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2638(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2639(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2640(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2641(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2642(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2643(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2644(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2645(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2646(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2647(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2648(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2649(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2650(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2651(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2652(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2653(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2654(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2655(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2656(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2657(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2658(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2659(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2660(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2661(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2662(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2663(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2664(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2665(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2666(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2667(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2668(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);
int ptr2669(struct cell_array **,
    struct cell_array *,
    struct cell_func *);
int ptr2670(struct cell_array **,
    struct cell_array *,
    struct cell_array *,
    struct cell_func *);

int cdf_prim_flag = 0;

EXPORT struct cdf_prim_loc {
	unsigned int __count;
	wchar_t **__names;
	struct cell_func *q_signal;
	struct cell_func *q_dr;
	struct cell_moper *q_veach;
	struct cell_doper *q_ambiv;
	struct cell_func *squeeze;
	struct cell_func *is_simple;
	struct cell_func *is_numeric;
	struct cell_func *is_integer;
	struct cell_func *max_shp;
	struct cell_func *has_nat_vals;
	struct cell_func *chk_scl;
	struct cell_func *chk_valid_shape;
	struct cell_func *both_simple;
	struct cell_func *both_numeric;
	struct cell_moper *numeric;
	struct cell_moper *scalar;
	struct cell_func *rgt;
	struct cell_func *lft;
	struct cell_func *reshape;
	struct cell_func *rho;
	struct cell_func *cat;
	struct cell_func *depth;
	struct cell_func *eqv;
	struct cell_func *nqv;
	struct cell_func *materialize;
	struct cell_func *index;
	struct cell_func *sqd;
	struct cell_func *index_gen;
	struct cell_func *index_of;
	struct cell_func *iot;
	struct cell_func *dis;
	struct cell_func *enclose;
	struct cell_func *par;
	struct cell_func *conjugate;
	struct cell_func *add;
	struct cell_func *negate;
	struct cell_func *sub;
	struct cell_func *sign;
	struct cell_func *mul;
	struct cell_func *recip;
	struct cell_func *div;
	struct cell_func *exp;
	struct cell_func *split;
	struct cell_func *drop;
	struct cell_func *drp;
	struct cell_func *reverse_last;
	struct cell_func *rotate_last;
	struct cell_func *rot;
	struct cell_func *map_monadic;
	struct cell_moper *map_dyadic;
	struct cell_moper *map;
	struct cell_moper *rdf;
	struct cell_func *rpf;
	struct cell_doper *dot;
	struct cell_doper *pow;
} cdf_prim;

wchar_t *cdf_prim_names[] = {L"q_signal", L"q_dr", L"q_veach", L"q_ambiv", L"squeeze", L"is_simple", L"is_numeric", L"is_integer", L"max_shp", L"has_nat_vals", L"chk_scl", L"chk_valid_shape", L"both_simple", L"both_numeric", L"numeric", L"scalar", L"rgt", L"lft", L"reshape", L"rho", L"cat", L"depth", L"eqv", L"nqv", L"materialize", L"index", L"sqd", L"index_gen", L"index_of", L"iot", L"dis", L"enclose", L"par", L"conjugate", L"add", L"negate", L"sub", L"sign", L"mul", L"recip", L"div", L"exp", L"split", L"drop", L"drp", L"reverse_last", L"rotate_last", L"rot", L"map_monadic", L"map_dyadic", L"map", L"rdf", L"rpf", L"dot", L"pow"};

EXPORT int
cdf_prim_init(void)
{
	struct cdf_prim_loc *loc;
	void *stk[128];
	void **stkhd;
	int err;

	if (cdf_prim_flag)
		return 0;

	stkhd = &stk[0];
	cdf_prim_flag = 1;
	cdf_prim_init();

	loc = &cdf_prim;
	loc->__count = 55;
	loc->__names = cdf_prim_names;
	loc->q_signal = NULL;
	loc->q_dr = NULL;
	loc->q_veach = NULL;
	loc->q_ambiv = NULL;
	loc->squeeze = NULL;
	loc->is_simple = NULL;
	loc->is_numeric = NULL;
	loc->is_integer = NULL;
	loc->max_shp = NULL;
	loc->has_nat_vals = NULL;
	loc->chk_scl = NULL;
	loc->chk_valid_shape = NULL;
	loc->both_simple = NULL;
	loc->both_numeric = NULL;
	loc->numeric = NULL;
	loc->scalar = NULL;
	loc->rgt = NULL;
	loc->lft = NULL;
	loc->reshape = NULL;
	loc->rho = NULL;
	loc->cat = NULL;
	loc->depth = NULL;
	loc->eqv = NULL;
	loc->nqv = NULL;
	loc->materialize = NULL;
	loc->index = NULL;
	loc->sqd = NULL;
	loc->index_gen = NULL;
	loc->index_of = NULL;
	loc->iot = NULL;
	loc->dis = NULL;
	loc->enclose = NULL;
	loc->par = NULL;
	loc->conjugate = NULL;
	loc->add = NULL;
	loc->negate = NULL;
	loc->sub = NULL;
	loc->sign = NULL;
	loc->mul = NULL;
	loc->recip = NULL;
	loc->div = NULL;
	loc->exp = NULL;
	loc->split = NULL;
	loc->drop = NULL;
	loc->drp = NULL;
	loc->reverse_last = NULL;
	loc->rotate_last = NULL;
	loc->rot = NULL;
	loc->map_monadic = NULL;
	loc->map_dyadic = NULL;
	loc->map = NULL;
	loc->rdf = NULL;
	loc->rpf = NULL;
	loc->dot = NULL;
	loc->pow = NULL;

	err = 0;

	if (debug_info)
		release_array(debug_info);

	debug_info = NULL;

	loc->q_signal = *stkhd++ = retain_cell(q_signal_ibeam);
	release_cell(*--stkhd);
	
	loc->q_dr = *stkhd++ = retain_cell(q_dr_ibeam);
	release_cell(*--stkhd);
	
	loc->q_veach = *stkhd++ = retain_cell(q_veach_ibeam);
	release_cell(*--stkhd);
	
	loc->q_ambiv = *stkhd++ = retain_cell(q_ambiv_ibeam);
	release_cell(*--stkhd);
	
	loc->squeeze = *stkhd++ = retain_cell(squeeze_ibeam);
	release_cell(*--stkhd);
	
	loc->is_simple = *stkhd++ = retain_cell(is_simple_ibeam);
	release_cell(*--stkhd);
	
	loc->is_numeric = *stkhd++ = retain_cell(is_numeric_ibeam);
	release_cell(*--stkhd);
	
	loc->is_integer = *stkhd++ = retain_cell(is_integer_ibeam);
	release_cell(*--stkhd);
	
	loc->max_shp = *stkhd++ = retain_cell(max_shp_ibeam);
	release_cell(*--stkhd);
	
	loc->has_nat_vals = *stkhd++ = retain_cell(has_nat_vals_ibeam);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2555, ptr2556, 0), cleanup, L"[16] chk_scl←╠{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}╣");
	
		*stkhd++ = k;
	}
	
	loc->chk_scl = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2557, ptr2562, 1), cleanup, L"[17] chk_valid_shape←╠{╣");
	
		k->fv[0] = retain_cell(loc->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	loc->chk_valid_shape = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2567, ptr2568, 1), cleanup, L"[22] both_simple←╠{is_simple ⍺:is_simple ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	loc->both_simple = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2569, ptr2570, 1), cleanup, L"[23] both_numeric←╠{is_numeric ⍺:is_numeric ⍵ ⋄ 0}╣");
	
		k->fv[0] = retain_cell(loc->is_numeric);
	
		*stkhd++ = k;
	}
	
	loc->both_numeric = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr2571, ptr2572, ptr2573, ptr2574, 1), cleanup, L"[24] numeric←╠{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}╣");
	
		k->fv[0] = retain_cell(loc->both_numeric);
	
		*stkhd++ = k;
	}
	
	loc->numeric = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr2575, ptr2576, ptr2577, ptr2578, 3), cleanup, L"[25] scalar←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}╣");
	
		k->fv[0] = retain_cell(loc->both_simple);
		k->fv[1] = retain_cell(loc->chk_scl);
		k->fv[2] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->scalar = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2579, ptr2580, 0), cleanup, L"[28] rgt←╠{⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->rgt = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2581, ptr2582, 0), cleanup, L"[31] lft←╠{⍺}╣");
	
		*stkhd++ = k;
	}
	
	loc->lft = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2583, ptr2584, 1), cleanup, L"[34] reshape←╠{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->reshape = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = shape_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->reshape;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[35] rho←╠('shape_ibeam'⌶) ⎕AMBIV reshape╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rho = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2585, ptr2586, 0), cleanup, L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = ravel_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[38] cat←╠('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->cat = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2587, ptr2590, 1), cleanup, L"[41] depth←╠{╣");
	
		k->fv[0] = retain_cell(loc->is_simple);
	
		*stkhd++ = k;
	}
	
	loc->depth = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->depth;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = same_ibeam;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[45] eqv←╠depth ⎕AMBIV ('same_ibeam'⌶)╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->eqv = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2595, ptr2596, 0), cleanup, L"[48] nqv←{⊃⍴⍵} ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2593, ptr2594, 0), cleanup, L"[48] nqv←╠{⊃⍴⍵}╣ ⎕AMBIV {⎕SIGNAL 16}");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[48] nqv←╠{⊃⍴⍵} ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(x);
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->nqv = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2597, ptr2598, 0), cleanup, L"[51] materialize←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->materialize = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2599, ptr2602, 1), cleanup, L"[52] index←╠{idx←⊃⍺ ⋄ rnk←≢⍴idx╣");
	
		k->fv[0] = retain_cell(loc->is_integer);
	
		*stkhd++ = k;
	}
	
	loc->index = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->materialize;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->index;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[57] sqd←╠materialize ⎕AMBIV index╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->sqd = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2605, ptr2606, 1), cleanup, L"[60] index_gen←╠{╣");
	
		k->fv[0] = retain_cell(loc->chk_valid_shape);
	
		*stkhd++ = k;
	}
	
	loc->index_gen = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2607, ptr2608, 0), cleanup, L"[67] index_of←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->index_of = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->index_gen;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->index_of;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[68] iot←╠index_gen ⎕AMBIV index_of╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->iot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2609, ptr2610, 0), cleanup, L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = disclose_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[71] dis←╠('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->dis = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2611, ptr2612, 0), cleanup, L"[74] enclose←╠{╣");
	
		*stkhd++ = k;
	}
	
	loc->enclose = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2613, ptr2614, 0), cleanup, L"[78] par←enclose ⎕AMBIV ╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = loc->enclose;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[78] par←╠enclose ⎕AMBIV {⎕SIGNAL 16}╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->par = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2615, ptr2616, 1), cleanup, L"[81] conjugate←╠{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}╣");
	
		k->fv[0] = retain_cell(loc->squeeze);
	
		*stkhd++ = k;
	}
	
	loc->conjugate = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = add_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[82] add←conjugate ⎕AMBIV (╠'add_vec_ibeam'⌶ numeric╣ scalar)");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[82] add←conjugate ⎕AMBIV ╠('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->conjugate;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[82] add←╠conjugate ⎕AMBIV ('add_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->add = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2617, ptr2618, 0), cleanup, L"[85] negate←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->negate = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = sub_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[86] sub←negate ⎕AMBIV (╠'sub_vec_ibeam'⌶ numeric╣ scalar)");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[86] sub←negate ⎕AMBIV ╠('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->negate;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[86] sub←╠negate ⎕AMBIV ('sub_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->sub = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2619, ptr2620, 0), cleanup, L"[89] sign←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->sign = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = mul_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[90] mul←sign ⎕AMBIV (╠'mul_vec_ibeam'⌶ numeric╣ scalar)");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[90] mul←sign ⎕AMBIV ╠('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->sign;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[90] mul←╠sign ⎕AMBIV ('mul_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->mul = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2621, ptr2622, 0), cleanup, L"[93] recip←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->recip = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = div_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[94] div←recip ⎕AMBIV (╠'div_vec_ibeam'⌶ numeric╣ scalar)");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[94] div←recip ⎕AMBIV ╠('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = loc->recip;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[94] div←╠recip ⎕AMBIV ('div_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->div = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = pow_vec_ibeam;
		struct cell_moper *op = loc->numeric;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[97] exp←'exp_vec_ibeam'⌶ ⎕AMBIV (╠'pow_vec_ibeam'⌶ numeric╣ scalar)");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = loc->scalar;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[97] exp←'exp_vec_ibeam'⌶ ⎕AMBIV ╠('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = exp_vec_ibeam;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = *--stkhd;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[97] exp←╠'exp_vec_ibeam'⌶ ⎕AMBIV ('pow_vec_ibeam'⌶ numeric scalar)╣");
	
		release_func(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->exp = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2623, ptr2624, 0), cleanup, L"[100] split←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->split = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2625, ptr2626, 0), cleanup, L"[101] drop←╠{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->drop = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->split;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->drop;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[102] drp←╠split ⎕AMBIV drop╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->drp = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2627, ptr2628, 0), cleanup, L"[105] reverse_last←╠{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->reverse_last = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2629, ptr2630, 0), cleanup, L"[106] rotate_last←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->rotate_last = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = loc->reverse_last;
		struct cell_doper *op = cdf_prim.q_ambiv;
		struct cell_func *y = loc->rotate_last;
		struct cell_func *dst;
	
		TRC(apply_dop(&dst, op, op->fptr_ffm, op->fptr_ffd, x, y), L"[107] rot←╠reverse_last ⎕AMBIV rotate_last╣");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2631, ptr2632, 0), cleanup, L"[110] map_monadic←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->map_monadic = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr2633, ptr2634, ptr2635, ptr2636, 2), cleanup, L"[111] map_dyadic←╠{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}╣");
	
		k->fv[0] = retain_cell(loc->chk_scl);
		k->fv[1] = retain_cell(loc->max_shp);
	
		*stkhd++ = k;
	}
	
	loc->map_dyadic = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr2637, ptr2638, ptr2639, ptr2640, 1), cleanup, L"[112] map←╠{⍺ ⍺⍺ map_dyadic ⍵}╣");
	
		k->fv[0] = retain_cell(loc->map_dyadic);
	
		*stkhd++ = k;
	}
	
	loc->map = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_moper *k;
	
		CHK(mk_moper(&k, ptr2641, ptr2644, ptr2647, ptr2650, 0), cleanup, L"[115] rdf←╠{op←⍺⍺¨ ╣");
	
		*stkhd++ = k;
	}
	
	loc->rdf = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2653, ptr2654, 0), cleanup, L"[123] rpf←╠{⎕SIGNAL 16}╣");
	
		*stkhd++ = k;
	}
	
	loc->rpf = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr2655, ptr2656, ptr2657, ptr2658, ptr2659, ptr2660, ptr2661, ptr2662, 0), cleanup, L"[126] dot←╠{⍺⍺⌿⍺ ⍵⍵¨ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->dot = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_doper *k;
	
		CHK(mk_doper(&k, ptr2663, ptr2664, ptr2665, ptr2666, ptr2667, ptr2668, ptr2669, ptr2670, 0), cleanup, L"[129] pow←╠{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}╣");
	
		*stkhd++ = k;
	}
	
	loc->pow = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2555(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2556(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡╠⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{╠(⍴⍺)╣≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{╠(⍴⍺)≡⍴⍵╣:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:╠0╣ ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢╠,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡╠≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1╣≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ ╠1≡≢,⍺╣:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:╠0╣ ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢╠,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡╠≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1╣≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ ╠1≡≢,⍵╣:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:╠0╣ ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢╠⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡╠≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢╠⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)╣≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ ╠(≢⍴⍺)≡≢⍴⍵╣:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {5};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL ╠5╣ ⋄ ⎕SIGNAL 4}");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:╠⎕SIGNAL 5╣ ⋄ ⎕SIGNAL 4}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {4};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL ╠4╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[16] chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ╠⎕SIGNAL 4╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2557(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2558, ptr2559, 0), cleanup, L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2560, ptr2561, 1), cleanup, L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	╠0╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	╠0╣");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2558(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2559(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2560(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2561(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2562(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2563, ptr2564, 0), cleanup, L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}╣⍵:⎕SIGNAL 4");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	╠{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵╣:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {4};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL ╠4╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:╠⎕SIGNAL 4╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2565, ptr2566, 1), cleanup, L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}╣⍵:⎕SIGNAL 11");
	
		k->fv[0] = retain_cell(lex->has_nat_vals);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	╠{has_nat_vals ⍵:0 ⋄ 1}⍵╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{has_nat_vals ⍵:0 ⋄ 1}⍵:╠⎕SIGNAL 11╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[20] 	╠0╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[20] 	╠0╣");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2563(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2564(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←≢╠⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[18] 	{rnk←╠≢⍴⍵╣ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0╣≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ ╠0≡rnk╣:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:╠0╣ ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1╣≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ ╠1≡rnk╣:0 ⋄ 1}⍵:⎕SIGNAL 4");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:╠0╣ ⋄ 1}⍵:⎕SIGNAL 4");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[18] 	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ ╠1╣}⍵:⎕SIGNAL 4");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2565(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2566(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *has_nat_vals;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->has_nat_vals;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[19] 	{╠has_nat_vals ⍵╣:0 ⋄ 1}⍵:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:╠0╣ ⋄ 1}⍵:⎕SIGNAL 11");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[19] 	{has_nat_vals ⍵:0 ⋄ ╠1╣}⍵:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2567(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[22] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_simple;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[22] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[22] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2568(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[22] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[22] both_simple←{╠is_simple ⍺╣:is_simple ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_simple;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[22] both_simple←{is_simple ⍺:╠is_simple ⍵╣ ⋄ 0}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[22] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[22] both_simple←{is_simple ⍺:is_simple ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2569(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_numeric;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[23] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_numeric;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[23] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[23] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2570(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *is_numeric;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_numeric;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[23] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[23] both_numeric←{╠is_numeric ⍺╣:is_numeric ⍵ ⋄ 0}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = lex->is_numeric;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[23] both_numeric←{is_numeric ⍺:╠is_numeric ⍵╣ ⋄ 0}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[23] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[23] both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ ╠0╣}");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2571(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2572(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2573(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2574(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_func *both_numeric;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_numeric;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[24] numeric←{╠⍺ both_numeric ⍵╣:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:╠⍺ ⍺⍺ ⍵╣ ⋄ ⎕SIGNAL 11}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {11};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL ╠11╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[24] numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ╠⎕SIGNAL 11╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2575(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2576(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr, **dat;
			
				unsigned int rnk = 1;
				size_t shp[] = {3};
			
				CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
				arr->shape[0] = 3;
				dat = arr->values;
			
				dat[0] = alpha;
				dat[1] = alphaalpha;
				dat[2] = omega;
			
				retain_cell(alpha);
				retain_cell(alphaalpha);
				retain_cell(omega);
			
				*stkhd++ = arr;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2577(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2578(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *both_simple;
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->both_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠⍺ both_simple ⍵╣:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = alpha;
				struct cell_func *fn = alphaalpha;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴╠⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->s;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:╠s⍴⍺ ⍺⍺ ⍵╣ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *x = self;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ╠∇ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴╠⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[25] scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ ╠s⍴⍺ ∇ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2579(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2580(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2581(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	*z = alpha;
	retain_cell(alpha);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2582(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	*z = alpha;
	retain_cell(alpha);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2583(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[34] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = reshape_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[34] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2584(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[34] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[34] reshape←{╠chk_valid_shape ⍺╣: ⋄ ⍺('reshape_ibeam'⌶)⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = reshape_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[34] reshape←{chk_valid_shape ⍺: ⋄ ╠⍺('reshape_ibeam'⌶)⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2585(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2586(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[38] cat←('ravel_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2587(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr2588, ptr2589, 0), cleanup, L"[42] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = *--stkhd;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	⎕SIGNAL ╠16╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[43] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[43] 	╠⎕SIGNAL 16╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2588(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2589(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2590(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *is_simple;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->is_simple;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	╠is_simple ⍵╣:{0≡≢⍴⍵:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *k;
			
				CHK(mk_func(&k, ptr2591, ptr2592, 0), cleanup, L"[42] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}╣⍵");
			
				*stkhd++ = k;
			}
			
			{
				struct cell_func *fn = *--stkhd;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:╠{0≡≢⍴⍵:0 ⋄ 1}⍵╣");
			
				release_func(fn);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[43] 	⎕SIGNAL ╠16╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[43] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[43] 	╠⎕SIGNAL 16╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2591(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2592(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡≢╠⍴⍵╣:0 ⋄ 1}⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[42] 	is_simple ⍵:{0≡╠≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{╠0╣≡≢⍴⍵:0 ⋄ 1}⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[42] 	is_simple ⍵:{╠0≡≢⍴⍵╣:0 ⋄ 1}⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:╠0╣ ⋄ 1}⍵");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[42] 	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ ╠1╣}⍵");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2593(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{⊃╠⍴⍵╣} ⎕AMBIV {⎕SIGNAL 16}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{╠⊃⍴⍵╣} ⎕AMBIV {⎕SIGNAL 16}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2594(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{⊃╠⍴⍵╣} ⎕AMBIV {⎕SIGNAL 16}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{╠⊃⍴⍵╣} ⎕AMBIV {⎕SIGNAL 16}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2595(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2596(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[48] nqv←{⊃⍴⍵} ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2597(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] materialize←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[51] materialize←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[51] materialize←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2598(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[51] materialize←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[51] materialize←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[51] materialize←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2599(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←╠⊃⍺╣ ⋄ rnk←≢⍴idx");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->idx = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴idx╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←⊃⍺ ⋄ rnk←╠≢⍴idx╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = lex->is_integer;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[53] 	0≡╠is_integer idx╣:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[53] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[53] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[53] 	0≡is_integer idx:╠⎕SIGNAL 11╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2600, ptr2601, 0), cleanup, L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL 16╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = loc->idx;
		struct cell_func *fn = index_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[55] 	(⍴idx)⍴╠idx('index_ibeam'⌶)⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[55] 	╠(⍴idx)╣⍴idx('index_ibeam'⌶)⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[55] 	╠(⍴idx)⍴idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2600(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2601(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2602(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct {
		struct cell_array *idx;
		struct cell_array *rnk;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *is_integer;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	loc->idx = NULL;
	loc->rnk = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←╠⊃⍺╣ ⋄ rnk←≢⍴idx");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->idx = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←⊃⍺ ⋄ rnk←≢╠⍴idx╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[52] index←{idx←⊃⍺ ⋄ rnk←╠≢⍴idx╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->rnk = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = lex->is_integer;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[53] 	0≡╠is_integer idx╣:⎕SIGNAL 11");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[53] 	╠0╣≡is_integer idx:⎕SIGNAL 11");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[53] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[53] 	╠0≡is_integer idx╣:⎕SIGNAL 11");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {11};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[53] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[53] 	0≡is_integer idx:⎕SIGNAL ╠11╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[53] 	0≡is_integer idx:╠⎕SIGNAL 11╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2603, ptr2604, 0), cleanup, L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}╣rnk:⎕SIGNAL 16");
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = loc->rnk;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	╠{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk╣:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL ╠16╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:╠⎕SIGNAL 16╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = loc->idx;
		struct cell_func *fn = index_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[55] 	(⍴idx)⍴╠idx('index_ibeam'⌶)⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = loc->idx;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[55] 	╠(⍴idx)╣⍴idx('index_ibeam'⌶)⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[55] 	╠(⍴idx)⍴idx('index_ibeam'⌶)⍵╣");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2603(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2604(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{╠0╣≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{╠0≡⍵╣:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:╠0╣ ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ ╠1╣≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[54] 	{0≡⍵:0 ⋄ ╠1≡⍵╣:0 ⋄ 1}rnk:⎕SIGNAL 16");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:╠0╣ ⋄ 1}rnk:⎕SIGNAL 16");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[54] 	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ ╠1╣}rnk:⎕SIGNAL 16");
	
		*stkhd++ = arr;
	}
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2605(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[61] 	╠chk_valid_shape ⍵╣: ");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[61] 	╠chk_valid_shape ⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡≢╠,⍵╣:⊂⍬");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	╠0╣≡≢,⍵:⊂⍬");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[62] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[62] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[62] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[62] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.par;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[63] 	(,0)≡╠,⍵╣:⍬");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] 	(,╠0╣)≡,⍵:⍬");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[63] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[63] 	╠(,0)╣≡,⍵:⍬");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[63] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[63] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[64] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[64] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[64] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[64] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = index_gen_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[65] 	⎕SIGNAL ╠16╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[65] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[65] 	╠⎕SIGNAL 16╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2606(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *chk_valid_shape;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->chk_valid_shape;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[61] 	╠chk_valid_shape ⍵╣: ");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[61] 	╠chk_valid_shape ⍵╣: ");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡≢╠,⍵╣:⊂⍬");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡╠≢,⍵╣:⊂⍬");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	╠0╣≡≢,⍵:⊂⍬");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[62] 	╠0╣≡≢,⍵:⊂⍬");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[62] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[62] 	╠0≡≢,⍵╣:⊂⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[62] 	0≡≢,⍵:⊂╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[62] 	0≡≢,⍵:⊂╠⍬╣");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.par;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[62] 	0≡≢,⍵:╠⊂⍬╣");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[63] 	(,0)≡╠,⍵╣:⍬");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] 	(,╠0╣)≡,⍵:⍬");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[63] 	(,╠0╣)≡,⍵:⍬");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[63] 	╠(,0)╣≡,⍵:⍬");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[63] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[63] 	╠(,0)≡,⍵╣:⍬");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 1;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[63] 	(,0)≡,⍵:╠⍬╣");
			
				arr->shape[0] = 0;
			
				CHK(fill_array(arr, dat), cleanup, L"[63] 	(,0)≡,⍵:╠⍬╣");
			
				*stkhd++ = arr;
			}
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡≢╠,⍵╣:'index_gen_vec'⌶ ⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡╠≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[64] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[64] 	╠1╣≡≢,⍵:'index_gen_vec'⌶ ⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[64] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[64] 	╠1≡≢,⍵╣:'index_gen_vec'⌶ ⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = index_gen_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[64] 	1≡≢,⍵:╠'index_gen_vec'⌶ ⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[65] 	⎕SIGNAL ╠16╣");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[65] 	⎕SIGNAL ╠16╣");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[65] 	╠⎕SIGNAL 16╣");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2607(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] index_of←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[67] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[67] index_of←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2608(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[67] index_of←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[67] index_of←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[67] index_of←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2609(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2610(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[71] dis←('disclose_ibeam'⌶) ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2611(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[75] 	0≡╠≡⍵╣:⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[75] 	╠0╣≡≡⍵:⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[75] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[75] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = enclose_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[76] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2612(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[75] 	0≡╠≡⍵╣:⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[75] 	╠0╣≡≡⍵:⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[75] 	╠0╣≡≡⍵:⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[75] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[75] 	╠0≡≡⍵╣:⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = enclose_ibeam;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[76] 	╠'enclose_ibeam'⌶ ⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2613(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[78] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[78] par←enclose ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2614(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[78] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[78] par←enclose ⎕AMBIV {⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[78] par←enclose ⎕AMBIV {╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2615(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_func *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->squeeze;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.q_dr;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[81] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[81] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = conjugate_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶ ⍵╣ ⋄ ⍵}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2616(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_func *squeeze;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = lex->squeeze;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡⎕DR ╠squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.q_dr;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡╠⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1289};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[81] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[81] conjugate←{╠1289╣≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[81] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[81] conjugate←{╠1289≡⎕DR squeeze ⍵╣:'conjugate_vec'⌶ ⍵ ⋄ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = conjugate_vec;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[81] conjugate←{1289≡⎕DR squeeze ⍵:╠'conjugate_vec'⌶ ⍵╣ ⋄ ⍵}");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	*z = omega;
	retain_cell(omega);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2617(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] negate←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[85] negate←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[85] negate←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2618(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[85] negate←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[85] negate←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[85] negate←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2619(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] sign←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[89] sign←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[89] sign←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2620(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[89] sign←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[89] sign←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[89] sign←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2621(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[93] recip←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[93] recip←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[93] recip←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2622(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[93] recip←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[93] recip←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[93] recip←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2623(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[100] split←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[100] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[100] split←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2624(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[100] split←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[100] split←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[100] split←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2625(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2626(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{(⊂⍺+⍳╠(≢⍵)╣-⍺)⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = alpha;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{(⊂⍺+⍳╠(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{(⊂⍺+╠⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{(⊂╠⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[101] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[101] drop←{╠(⊂⍺+⍳(≢⍵)-⍺)⌷⍵╣}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2627(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[105] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[105] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2628(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-1+⍳╠≢⍵)╣⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-1+╠⍳≢⍵)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[105] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[105] reverse_last←{(⊂(≢⍵)-╠1╣+⍳≢⍵)⌷⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.add;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{(⊂(≢⍵)-╠1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{(⊂╠(≢⍵)╣-1+⍳≢⍵)⌷⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{(⊂╠(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[105] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)╣⌷⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[105] reverse_last←{╠(⊂(≢⍵)-1+⍳≢⍵)⌷⍵╣}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2629(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106] rotate_last←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[106] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[106] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2630(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[106] rotate_last←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[106] rotate_last←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[106] rotate_last←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2631(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[110] map_monadic←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[110] map_monadic←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[110] map_monadic←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2632(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[110] map_monadic←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[110] map_monadic←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[110] map_monadic←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2633(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺╣ ⎕VEACH ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2634(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺╣ ⎕VEACH ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2635(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2636(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_array *s;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	struct lex_vars {
		struct cell_func *chk_scl;
		struct cell_func *max_shp;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	loc->s = NULL;
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->chk_scl;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[111] map_dyadic←{╠⍺ chk_scl ⍵╣: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = lex->max_shp;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←╠⍺ max_shp ⍵╣ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.q_veach;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ╠⍺⍺ ⎕VEACH╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴╠⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = loc->s;
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[111] map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ╠s⍴⍺ ⍺⍺ ⎕VEACH ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2637(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[112] map←{╠⍺ ⍺⍺╣ map_dyadic ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[112] map←{╠⍺ ⍺⍺ map_dyadic╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[112] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2638(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[112] map←{╠⍺ ⍺⍺╣ map_dyadic ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[112] map←{╠⍺ ⍺⍺ map_dyadic╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[112] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2639(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[112] map←{⍺ ╠⍺⍺ map_dyadic╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[112] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2640(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct lex_vars {
		struct cell_moper *map_dyadic;
	} *lex;
	
	lex = (struct lex_vars *)deldel->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = lex->map_dyadic;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[112] map←{⍺ ╠⍺⍺ map_dyadic╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[112] map←{╠⍺ ⍺⍺ map_dyadic ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2641(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[115] rdf←{op←╠⍺⍺¨╣ ");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢╠,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡╠≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃╠0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴╠⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:╠zs⍴⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)╣⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)⌷⍵╣ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨╠⊂⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2642, ptr2643, 2), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}╣¨⊂⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}¨╣⊂⍵");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳╠c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽╠⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2642(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2643(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2644(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_array *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[115] rdf←{op←╠⍺⍺¨╣ ");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢╠,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡╠≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃╠0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴╠⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:╠zs⍴⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)╣⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)⌷⍵╣ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨╠⊂⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2645, ptr2646, 2), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}╣¨⊂⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}¨╣⊂⍵");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳╠c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽╠⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2645(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2646(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2647(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[115] rdf←{op←╠⍺⍺¨╣ ");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢╠,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡╠≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃╠0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴╠⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:╠zs⍴⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)╣⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)⌷⍵╣ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨╠⊂⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2648, ptr2649, 2), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}╣¨⊂⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}¨╣⊂⍵");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳╠c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽╠⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	release_array(alpha);
	return err;
}

int
ptr2648(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2649(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2650(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_moper *deldel;
	struct cell_func *alphaalpha;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];

	struct {
		struct cell_func *op;
		struct cell_array *s;
		struct cell_array *c;
		struct cell_array *zs;
		struct cell_array_box *z;
	} loc_frm, *loc;
	
	loc = &loc_frm;
	
	loc->op = NULL;
	loc->s = NULL;
	loc->c = NULL;
	loc->zs = NULL;
	CHK(mk_array_box(&loc->z, NULL), cleanup, L"Init mutable variable: loc->z");
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[115] rdf←{op←╠⍺⍺¨╣ ");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->op = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢╠⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡╠≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	╠0╣≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[116] 	╠0≡≢⍴⍵╣:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_func *fn = cdf_prim.cat;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇╠,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = self;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:╠∇,⍵╣ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_func *fn = cdf_prim.rho;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←╠⍴⍵╣ ⋄ c←⊃s ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->s = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.dis;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←╠⊃s╣ ⋄ zs←1↓s");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->c = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1╣↓s");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.drp;
		struct cell_array *y = loc->s;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[116] 	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←╠1↓s╣");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->zs = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.cat;
		struct cell_array *y = loc->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢╠,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.nqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡╠≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	╠0╣≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	╠0≡≢,z╣:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {0};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃╠0╣⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_array *x = *--stkhd;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃╠0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(x);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_func *fn = cdf_prim.dis;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴╠⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:╠zs⍴⊃0⍴⍵╣ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0╣≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ ╠0≡c╣:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *arr;
			
				enum array_type typ = ARR_SINT;
				unsigned int rnk = 0;
				int16_t dat[] = {16};
			
				CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
			
				CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL ╠16╣ ⋄ 1≡c:zs⍴⍵");
			
				*stkhd++ = arr;
			}
			{
				struct cell_func *fn = cdf_prim.q_signal;
				struct cell_array *y = *--stkhd;
				struct cell_array *dst;
			
				TRC((fn->fptr_mon)(&dst, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:╠⎕SIGNAL 16╣ ⋄ 1≡c:zs⍴⍵");
			
				release_array(y);
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1╣≡c:zs⍴⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = loc->c;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ ╠1≡c╣:zs⍴⍵");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			{
				struct cell_array *x = loc->zs;
				struct cell_func *fn = cdf_prim.rho;
				struct cell_array *y = omega;
				struct cell_array *dst;
			
				TRC((fn->fptr_dya)(&dst, x, y, fn), L"[117] 	0≡≢,z:zs⍴⊃0⍴⍵ ⋄ 0≡c:⎕SIGNAL 16 ⋄ 1≡c:╠zs⍴⍵╣");
			
				if (err)
					goto cleanup;
			
				*stkhd++ = dst;
			}
			
			*z = *--stkhd;
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-╠1╣)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)╣⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←╠(c-1)⌷⍵╣ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	loc->z->value = *stkhd++ = retain_cell(*--stkhd);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = cdf_prim.par;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨╠⊂⍵╣");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *k;
	
		CHK(mk_func(&k, ptr2651, ptr2652, 2), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}╣¨⊂⍵");
	
		k->fv[0] = retain_cell(loc->z);
		k->fv[1] = retain_cell(loc->op);
	
		*stkhd++ = k;
	}
	
	{
		struct cell_func *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1)╠{z⊢←(⍺⌷⍵)op z}¨╣⊂⍵");
	
		release_func(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-╠1╣){z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = loc->c;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳╠c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.iot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽╠⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = cdf_prim.rot;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1)╣{z⊢←(⍺⌷⍵)op z}¨⊂⍵");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ ╠(⌽⍳c-1){z⊢←(⍺⌷⍵)op z}¨⊂⍵╣");
	
		release_array(x);
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	*z = loc->z->value;
	retain_cell(loc->z->value);
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_env((void **)loc, (void **)(loc + 1));
	return err;
}

int
ptr2651(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2652(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	struct lex_vars {
		struct cell_array_box *z;
		struct cell_func *op;
	} *lex;
	
	lex = (struct lex_vars *)self->fv;
	
	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *x = alpha;
		struct cell_func *fn = cdf_prim.sqd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)╣op z}¨⊂⍵");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = lex->op;
		struct cell_array *y = lex->z->value;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){z⊢←╠(⍺⌷⍵)op z╣}¨⊂⍵");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array_box *bx = lex->z;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *x = bx->value;
	
		TRC((fn->fptr_dya)(&bx->value, x, y, fn), L"[118] 	z←(c-1)⌷⍵ ⋄ (⌽⍳c-1){╠z⊢←(⍺⌷⍵)op z╣}¨⊂⍵");
	
		if (err) {
			goto cleanup;
		}
	
		release_array(x);
	
		*stkhd++ = y;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2653(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;

	alpha = NULL;

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[123] rpf←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[123] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[123] rpf←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2654(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;


	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {16};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[123] rpf←{⎕SIGNAL ╠16╣}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[123] rpf←{⎕SIGNAL ╠16╣}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.q_signal;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[123] rpf←{╠⎕SIGNAL 16╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2655(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2656(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2657(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2658(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵╣¨ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = omegaomega;
	
		retain_cell(alpha);
		retain_cell(omegaomega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_am, op->fptr_ad, x), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨╣ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2659(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2660(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = cdf_prim.rpf;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2661(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_array *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_array(alpha);
	return err;
}

int
ptr2662(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_func *x = omegaomega;
		struct cell_moper *op = cdf_prim.map;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{⍺⍺⌿⍺ ╠⍵⍵¨╣ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[126] dot←{⍺⍺⌿╠⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *x = alphaalpha;
		struct cell_moper *op = cdf_prim.rdf;
		struct cell_func *dst;
	
		TRC(apply_mop(&dst, op, op->fptr_fm, op->fptr_fd, x), L"[126] dot←{╠⍺⍺⌿╣⍺ ⍵⍵¨ ⍵}");
	
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = *--stkhd;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[126] dot←{╠⍺⍺⌿⍺ ⍵⍵¨ ⍵╣}");
	
		release_func(fn);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2663(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alphaalpha;
		dat[1] = omega;
	
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2664(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {3};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 3;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
		dat[2] = omega;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2665(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2666(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_array *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {0};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{╠0╣≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.eqv;
		struct cell_array *y = omegaomega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_array *x = omegaomega;
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2667(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alphaalpha;
		dat[1] = omega;
	
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alphaalpha;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2668(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_array *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {3};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
		arr->shape[0] = 3;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
		dat[2] = omega;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
		retain_cell(omega);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr, **dat;
	
		unsigned int rnk = 1;
		size_t shp[] = {2};
	
		CHK(mk_array(&arr, ARR_NESTED, STG_HOST, 1), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺╣∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
		arr->shape[0] = 2;
		dat = arr->values;
	
		dat[0] = alpha;
		dat[1] = alphaalpha;
	
		retain_cell(alpha);
		retain_cell(alphaalpha);
	
		*stkhd++ = arr;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

int
ptr2669(struct cell_array **z,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_func *alpha;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	alpha = NULL;
	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	alpha = *stkhd++ = retain_cell(cdf_prim.rgt);
	release_cell(*--stkhd);
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ╠⍺⍺ ⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ╠⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = alpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	release_func(alpha);
	return err;
}

int
ptr2670(struct cell_array **z,
    struct cell_array *alpha,
    struct cell_array *omega,
    struct cell_func *self)
{
	void *stk[128];
	void **stkhd;
	int err;
	struct cell_doper *deldel;
	struct cell_func *alphaalpha;
	struct cell_func *omegaomega;

	deldel = self->fv[0];
	alphaalpha = self->fv[1];
	omegaomega = self->fv[2];

	err = 0;
	stkhd = &stk[0];

	CHK(2, cleanup, L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
	{
		struct cell_array *x = *--stkhd;
	
		TRC(guard_check(x), L"[129] pow←{╠0≡⍵⍵╣:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}");
	
		release_array(x);
	
		if (err > 0)
			goto cleanup;
	
		if (!err) {
			*z = omega;
			retain_cell(omega);
			goto cleanup;
			
			err = -1;
			goto cleanup;
		}
	
		err = 0;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = omega;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢╠⍺ ⍺⍺ ⍵╣}");
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *arr;
	
		enum array_type typ = ARR_SINT;
		unsigned int rnk = 0;
		int16_t dat[] = {1};
	
		CHK(mk_array(&arr, typ, STG_HOST, rnk), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
	
		CHK(fill_array(arr, dat), cleanup, L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-╠1╣)⊢⍺ ⍺⍺ ⍵}");
	
		*stkhd++ = arr;
	}
	{
		struct cell_func *fn = cdf_prim.sub;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵╠-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = omegaomega;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)╣⊢⍺ ⍺⍺ ⍵}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = *--stkhd;
		struct cell_func *fn = cdf_prim.rgt;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇╠(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(x);
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇╠∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_func *fn = self;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_mon)(&dst, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺╠∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	{
		struct cell_array *x = alpha;
		struct cell_func *fn = alphaalpha;
		struct cell_array *y = *--stkhd;
		struct cell_array *dst;
	
		TRC((fn->fptr_dya)(&dst, x, y, fn), L"[129] pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ╠⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵╣}");
	
		release_array(y);
	
		if (err)
			goto cleanup;
	
		*stkhd++ = dst;
	}
	
	*z = *--stkhd;
	goto cleanup;
	
	err = -1;

cleanup:
	release_env(stk, stkhd);
	return err;
}

EXPORT int
q_signal(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.q_signal;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_signal_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_signal, z, l, r, L"q_signal");
}

EXPORT int
q_dr(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.q_dr;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
q_dr_dwa(void *z, void *l, void *r)
{
	return call_dwa(q_dr, z, l, r, L"q_dr");
}

EXPORT int
squeeze(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.squeeze;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
squeeze_dwa(void *z, void *l, void *r)
{
	return call_dwa(squeeze, z, l, r, L"squeeze");
}

EXPORT int
is_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_simple;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_simple, z, l, r, L"is_simple");
}

EXPORT int
is_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_numeric;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_numeric, z, l, r, L"is_numeric");
}

EXPORT int
is_integer(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.is_integer;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
is_integer_dwa(void *z, void *l, void *r)
{
	return call_dwa(is_integer, z, l, r, L"is_integer");
}

EXPORT int
max_shp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.max_shp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
max_shp_dwa(void *z, void *l, void *r)
{
	return call_dwa(max_shp, z, l, r, L"max_shp");
}

EXPORT int
has_nat_vals(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.has_nat_vals;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
has_nat_vals_dwa(void *z, void *l, void *r)
{
	return call_dwa(has_nat_vals, z, l, r, L"has_nat_vals");
}

EXPORT int
chk_scl(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.chk_scl;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_scl_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_scl, z, l, r, L"chk_scl");
}

EXPORT int
chk_valid_shape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.chk_valid_shape;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
chk_valid_shape_dwa(void *z, void *l, void *r)
{
	return call_dwa(chk_valid_shape, z, l, r, L"chk_valid_shape");
}

EXPORT int
both_simple(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.both_simple;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_simple_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_simple, z, l, r, L"both_simple");
}

EXPORT int
both_numeric(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.both_numeric;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
both_numeric_dwa(void *z, void *l, void *r)
{
	return call_dwa(both_numeric, z, l, r, L"both_numeric");
}

EXPORT int
rgt(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rgt;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rgt_dwa(void *z, void *l, void *r)
{
	return call_dwa(rgt, z, l, r, L"rgt");
}

EXPORT int
lft(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.lft;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
lft_dwa(void *z, void *l, void *r)
{
	return call_dwa(lft, z, l, r, L"lft");
}

EXPORT int
reshape(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.reshape;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reshape_dwa(void *z, void *l, void *r)
{
	return call_dwa(reshape, z, l, r, L"reshape");
}

EXPORT int
rho(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rho;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rho_dwa(void *z, void *l, void *r)
{
	return call_dwa(rho, z, l, r, L"rho");
}

EXPORT int
cat(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.cat;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
cat_dwa(void *z, void *l, void *r)
{
	return call_dwa(cat, z, l, r, L"cat");
}

EXPORT int
depth(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.depth;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
depth_dwa(void *z, void *l, void *r)
{
	return call_dwa(depth, z, l, r, L"depth");
}

EXPORT int
eqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.eqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
eqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(eqv, z, l, r, L"eqv");
}

EXPORT int
nqv(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.nqv;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
nqv_dwa(void *z, void *l, void *r)
{
	return call_dwa(nqv, z, l, r, L"nqv");
}

EXPORT int
materialize(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.materialize;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
materialize_dwa(void *z, void *l, void *r)
{
	return call_dwa(materialize, z, l, r, L"materialize");
}

EXPORT int
index(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_dwa(void *z, void *l, void *r)
{
	return call_dwa(index, z, l, r, L"index");
}

EXPORT int
sqd(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sqd;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sqd_dwa(void *z, void *l, void *r)
{
	return call_dwa(sqd, z, l, r, L"sqd");
}

EXPORT int
index_gen(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index_gen;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_gen_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_gen, z, l, r, L"index_gen");
}

EXPORT int
index_of(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.index_of;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
index_of_dwa(void *z, void *l, void *r)
{
	return call_dwa(index_of, z, l, r, L"index_of");
}

EXPORT int
iot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.iot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
iot_dwa(void *z, void *l, void *r)
{
	return call_dwa(iot, z, l, r, L"iot");
}

EXPORT int
dis(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.dis;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
dis_dwa(void *z, void *l, void *r)
{
	return call_dwa(dis, z, l, r, L"dis");
}

EXPORT int
enclose(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.enclose;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
enclose_dwa(void *z, void *l, void *r)
{
	return call_dwa(enclose, z, l, r, L"enclose");
}

EXPORT int
par(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.par;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
par_dwa(void *z, void *l, void *r)
{
	return call_dwa(par, z, l, r, L"par");
}

EXPORT int
conjugate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.conjugate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
conjugate_dwa(void *z, void *l, void *r)
{
	return call_dwa(conjugate, z, l, r, L"conjugate");
}

EXPORT int
add(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.add;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
add_dwa(void *z, void *l, void *r)
{
	return call_dwa(add, z, l, r, L"add");
}

EXPORT int
negate(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.negate;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
negate_dwa(void *z, void *l, void *r)
{
	return call_dwa(negate, z, l, r, L"negate");
}

EXPORT int
sub(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sub;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sub_dwa(void *z, void *l, void *r)
{
	return call_dwa(sub, z, l, r, L"sub");
}

EXPORT int
sign(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.sign;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
sign_dwa(void *z, void *l, void *r)
{
	return call_dwa(sign, z, l, r, L"sign");
}

EXPORT int
mul(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.mul;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
mul_dwa(void *z, void *l, void *r)
{
	return call_dwa(mul, z, l, r, L"mul");
}

EXPORT int
recip(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.recip;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
recip_dwa(void *z, void *l, void *r)
{
	return call_dwa(recip, z, l, r, L"recip");
}

EXPORT int
div(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.div;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
div_dwa(void *z, void *l, void *r)
{
	return call_dwa(div, z, l, r, L"div");
}

EXPORT int
exp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.exp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
exp_dwa(void *z, void *l, void *r)
{
	return call_dwa(exp, z, l, r, L"exp");
}

EXPORT int
split(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.split;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
split_dwa(void *z, void *l, void *r)
{
	return call_dwa(split, z, l, r, L"split");
}

EXPORT int
drop(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.drop;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drop_dwa(void *z, void *l, void *r)
{
	return call_dwa(drop, z, l, r, L"drop");
}

EXPORT int
drp(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.drp;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
drp_dwa(void *z, void *l, void *r)
{
	return call_dwa(drp, z, l, r, L"drp");
}

EXPORT int
reverse_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.reverse_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
reverse_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(reverse_last, z, l, r, L"reverse_last");
}

EXPORT int
rotate_last(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rotate_last;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rotate_last_dwa(void *z, void *l, void *r)
{
	return call_dwa(rotate_last, z, l, r, L"rotate_last");
}

EXPORT int
rot(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rot;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rot_dwa(void *z, void *l, void *r)
{
	return call_dwa(rot, z, l, r, L"rot");
}

EXPORT int
map_monadic(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.map_monadic;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
map_monadic_dwa(void *z, void *l, void *r)
{
	return call_dwa(map_monadic, z, l, r, L"map_monadic");
}

EXPORT int
rpf(struct cell_array **z, struct cell_array *l, struct cell_array *r)
{
	struct cell_func *self;

	cdf_prim_init();

	self = cdf_prim.rpf;

	if (l == NULL)
		return self->fptr_mon(z, r, self);
	else
		return self->fptr_dya(z, l, r, self);
}

EXPORT int
rpf_dwa(void *z, void *l, void *r)
{
	return call_dwa(rpf, z, l, r, L"rpf");
}

