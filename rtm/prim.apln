:Namespace prim

⍝ Basic system functions
q_signal←'q_signal_ibeam'⌶
q_dr←'q_dr_ibeam'⌶

⍝ System constants
spn←'span_array'⌶⌶⌶⌶

⍝ Utilities
eq←'eq_ibeam'⌶⌶⌶
squeeze←'squeeze_ibeam'⌶
is_simple←'is_simple_ibeam'⌶
is_numeric←'is_numeric_ibeam'⌶
is_char←'is_char_ibeam'⌶
is_integer←'is_integer_ibeam'⌶
is_bool←{11≡⎕DR squeeze ⍵}
is_span←'is_span_ibeam'⌶
max_shp←{⍺←0 ⋄ ⍺('max_shp_ibeam'⌶)⍵}
has_nat_vals←'has_nat_vals_ibeam'⌶
chk_scl←{⍺←0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}
both_simple←{is_simple ⍺:is_simple ⍵ ⋄ 0}
both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ 0}
both_integer←{is_integer ⍺:is_integer ⍵ ⋄ 0}
both_char←{is_char ⍺:is_char ⍵ ⋄ 0}
both_bool←{is_bool ⍺:is_bool ⍵ ⋄ 0}
any←'any_ibeam'⌶
numeric←{⍺←⊢ ⋄ (⍺⊣0)both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}
ambiv←{
	⍺←⊢ ⋄ hax←1 ⋄ axis⍠←hax←0 ⋄ mon←1 same ⍺ 1 ⋄ lop←⍺⍺ ⋄ rop←⍵⍵
	hax:⍺{mon:lop[axis] ⍵ ⋄ ⍺ rop[axis] ⍵}⍵
	mon:⍺⍺ ⍵ ⋄ ⍺ ⍵⍵ ⍵
}
veach←'veach_ibeam'⌶⌶
scalar←{op←⍺⍺
	hax←1 ⋄ axis⍠←hax←0 ⋄ hax:⍺{
		hl←(≢⍴⍺)>≢⍴⍵ ⋄ l←⍺{hl:⍵ ⋄ ⍺}⍵ ⋄ h←⍺{hl:⍺ ⋄ ⍵}⍵ ⋄ s←⍴h
		1<≢⍴axis:⎕SIGNAL 4 ⋄ (≢⍴l)≢≢axis:⎕SIGNAL 4 ⋄ axis←,axis
		(⍴l)≢s[axis]:⎕SIGNAL 5
		zs←(≢s)⍴1 ⋄ zs[axis]←⍴l
		l←⊃{s[⍺]≡zs[⍺]:⍵ ⋄ s[⍺]⌿[⍺]⍵}⌿(⍳≢s),⊂zs⍴l
		hl:h op scalar l ⋄ l op scalar h
	}⍵
	⍺ chk_scl ⍵:
	s←⍺ max_shp ⍵
	0≡≢,⍺:s⍴0
	0≡≢,⍵:s⍴0
	⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵
	s⍴squeeze ⍺ ∇ veach ⍵
}

⍝ ⍴: Shape / Reshape
chk_valid_shape←{
	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4
	0≡≢,⍵:0
	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11
	0
}
reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}
rho←('shape_ibeam'⌶) ambiv reshape

⍝ X[]←Y: Bracket Assignment
idx_rnk_check←{(≢⍴⍺)≢≢,⍵:⎕SIGNAL 4 ⋄ 0}
idx_rng_check←{
	0≡≢,⍵:0
	0≡is_integer⊢idx←squeeze ⍵:⎕SIGNAL 11
	any(idx<0)∨⍺≤idx:⎕SIGNAL 3
	0
}
flatten_idx←{
	(1≡≢⍵)∧1≡≢s←⍴⍺:(⊃s){is_span ⍵:⍵ ⋄ ⍺ idx_rng_check ⍵: ⋄ ⍵}⊃⍵
	i←⍵{is_span ⍺:⍳⍵ ⋄ ⍵ idx_rng_check ⍺: ⋄ ⍺}¨(c←≢⍵)↑s
	⊃∘.+⌿(i×c↑1↓o),⊂(c↓s)⍴⍳c⌷o←⌽×⍀1,⌽s
}
idx_shp_check←{1≡≢,⍵:0 ⋄ (⍴⍺)≡⍴⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}
set_get_idx←{
	⍺ idx_rnk_check ⍺⍺:
	idx←⍺ flatten_idx ⍺⍺
	proto←⍺{is_span idx:⍺ ⋄ idx}⍵
	proto idx_shp_check ⍵:
	idx
}
set←'set_ibeam'⌶

⍝ X[]f←Y: Modified Bracket Assignment
mst_vals←{op←⍵⍵
	is_span⊢idx←⍺(⍺⍺ set_get_idx)⍵:idx(,⍺ op¨⍵)
	(,idx)((,⍺)[,idx] op¨,⍵)
	(≢idx)≡≢uidx←∪idx:uidx((,⍺)[uidx] op¨,⍵)
	uidx((⌽uidx,idx){op⍨⌿⍵}⌸⌽(,⍺)[uidx],⍵)
}
mst←'mst_ibeam'⌶⌶

⍝ ⌷: Materialize | Squad indexing
materialize←{⍵}
sqd_idx←{
	1<≢⍴i←⍺⊣0:⎕SIGNAL 4 ⋄ (≢⍴⍵)<≢i:⎕SIGNAL 5
	axis⍠←0
	axis≡0:⍺{
		0≡≢i:⍵
		is_span⊢idx←⍵ flatten_idx i:⍵
		0≡≢,idx:(⍴idx)⍴⍵
		(⍴idx)⍴idx('index_ibeam'⌶)⍵
	}⍵
	i←⍳¨⍴⍵ ⋄ i[axis]←⍺ ⋄ i⌷⍵
}
sqd←materialize ambiv sqd_idx

⍝ X[]: Bracket Indexing
brk←{⍺ idx_rnk_check ⍵: ⋄ ⍵⌷⍺}

⍝ ⊢: Right
rgt←{⍵}

⍝ ⊣: Left
lft←{⍵} ambiv {⍺}

⍝ ,: Ravel / Catenate
ravel←{
	noax←0 ⋄ rr←≢⍴⍵ ⋄ axis⍠←noax←1
	noax:'ravel_ibeam'⌶ ⍵
	1≡≢,axis:{
		is_integer squeeze axis:⍵
		((pr↑s),1,(pr←⌈axis)↓s←⍴⍵)⍴⍵
	}⍵
	0≡≢,axis:((⍴⍵),1)⍴⍵
	~is_integer squeeze axis:⎕SIGNAL 11
	1≢≢⍴axis:⎕SIGNAL 4
	axis≢(⍳c←≢axis)+b←⊃axis:⎕SIGNAL 11
	((b↑s),(×⌿c↑b↓s),(b+c)↓s←⍴⍵)⍴⍵
}
catenate←{
	lr←≢⍴⍺ ⋄ rr←≢⍴⍵ ⋄ rk←lr⌈rr ⋄ axis⍠←¯1+rk
	(0≡lr)∧(0≡rr):(,⍺),,⍵
	ar←≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 
	~is_numeric axis:⎕SIGNAL 11 ⋄ axis≤¯1:⎕SIGNAL 11
	axis≥rk:⎕SIGNAL 4 ⋄ (1<|lr-rr)∧noscl←(lr≢0)∧rr≢0:⎕SIGNAL 4
	axis≠fx←⌈axis:⍺{
		(lr≢0)∧(rr≢0)∧lr≠rr:⎕SIGNAL 4
		(,[axis]⍣(lr≢0)⊢⍺),[fx],[axis]⍣(rr≢0)⊢⍵
	}⍵
	(lr≤1)∧rr≤1:⍺{z←((lc←≢⍺)+rc←≢⍵)⍴⍺ ⋄ z[lc+⍳rc]←⍵ ⋄ z}⍵
	x←⍺{lr≡0:s⍴⍺⊣s[fx]←1⊣s←⍴⍵ ⋄ lr<rr:,[fx-.5]⍺ ⋄ ⍺}⍵
	y←⍺{rr≡0:s⍴⍵⊣s[fx]←1⊣s←⍴⍺ ⋄ rr<lr:,[fx-.5]⍵ ⋄ ⍵}⍵
	(m×⍴x)∨.≠m×⍴y⊣m←fx≠⍳rk:⎕SIGNAL 5
	s[fx]←(⍴x)[fx]+(⍴y)[fx]⊣s←⍴x
	ca←×⌿fx↑s ⋄ cb←fx⌷s ⋄ cc←×⌿(fx+1)↓s ⋄ lx←fx⌷⍴x ⋄ rx←fx⌷⍴y
	z←ca cb cc⍴0 ⋄ z[;⍳lx;]←ca lx cc⍴x ⋄ z[;lx+⍳rx;]←ca rx cc⍴y
	s⍴z
}
cat←ravel ambiv catenate

⍝ Table / Catenate First
ctf←{⍺,[0]⍵}

⍝ ≡: Depth / Same
depth←{
	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵
	0≡≢,⍵:(×d)+d←∇⊃⍵
	nd←1+mx←⌈⌿pd←|d←∇¨,⍵
	∨⌿(d<0)∨pd≠mx:-nd
	nd
}
same←'same_ibeam'⌶
eqv←depth ambiv same

⍝ ≢: Tally / Not Same
nqv←{⍬≡⍴⍵:1 ⋄ ⊃⍴⍵} ambiv ('nqv_ibeam'⌶)

⍝ ⍳: Index Generate | Index Of
index_gen←{
	chk_valid_shape ⍵: 
	0≡≢,⍵:⊂⍬
	(,0)≡,⍵:⍬
	1≡≢,⍵:'index_gen_vec'⌶ ⍵
	⎕SIGNAL 16
}
index_of←{⎕SIGNAL 16}
iot←index_gen ambiv index_of

⍝ ⊃: First / Pick
dis←('disclose_ibeam'⌶) ambiv {⎕SIGNAL 16}

⍝ ⊂: Enclose / Partition
enclose←{
	0≡≡⍵:⍵
	'enclose_ibeam'⌶ ⍵
}
par←enclose ambiv {⎕SIGNAL 16}

⍝ +: Conjugate | Addition
conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec_ibeam'⌶ ⍵ ⋄ ⍵}
add←conjugate ambiv ('add_vec_ibeam'⌶ numeric scalar)

⍝ -: Negate | Subtract
sub←{0-⍵} ambiv ('sub_vec_ibeam'⌶ numeric scalar)

⍝ ×: Sign | Multiply
sign←{
	1289=⎕DR ⍵:⍵÷|⍵
	(-⍵<0)+0<⍵
}
mul←sign ambiv ('mul_vec_ibeam'⌶ numeric scalar)

⍝ ÷: Reciprocal | Divide
div←{1÷⍵} ambiv ('div_vec_ibeam'⌶ numeric scalar)

⍝ |: Absolute Value | Residue
absolute←{
	0≡is_numeric ⍵:⎕SIGNAL 11
	1289≡⎕DR ⍵:⎕SIGNAL 11
	'abs_vec_ibeam'⌶ ⍵
}
residue←{⍵-⍺×⌊⍵÷⍺+0=⍺}
res←absolute numeric ambiv residue

⍝ ⌊: Floor | Minimum
floor_array←{
	is_integer ⍵:⍵
	1289=⎕DR ⍵:⎕SIGNAL 16
	'floor_vec_ibeam'⌶ ⍵
}
min←floor_array numeric ambiv ('min_vec_ibeam'⌶ numeric scalar)

⍝ ⌈: Ceiling | Maximum
ceil_array←{
	is_integer ⍵:⍵
	1289=⎕DR ⍵:-⌊-⍵
	'ceil_vec_ibeam'⌶ ⍵
}
max←ceil_array numeric ambiv ('max_vec_ibeam'⌶ numeric scalar)

⍝ *: Exponent | Power
exp←'exp_vec_ibeam'⌶ numeric ambiv ('pow_vec_ibeam'⌶ numeric scalar)

⍝ ⍟: Natural Logarithm | Logarithm
log←'nlg_vec_ibeam'⌶ numeric ambiv ('log_vec_ibeam'⌶ numeric scalar)

⍝ ○: Pi Times | Trigonometric Functions
pitimes←{3.14159265358979323846×⍵}
trig←{
	0≠≡⍺:⍺ ∇¨⍵
	0=⍺:(1-⍵*2)*.5
	1=⍺:'sin_vec_ibeam'⌶ ⍵
	¯1=⍺:'arcsin_vec_ibeam'⌶ ⍵
	2=⍺:'cos_vec_ibeam'⌶ ⍵
	¯2=⍺:'arccos_vec_ibeam'⌶ ⍵
	3=⍺:'tan_vec_ibeam'⌶ ⍵
	¯3=⍺:'arctan_vec_ibeam'⌶ ⍵
	4=⍺:(1+⍵*2)*.5
	¯4=⍺:(⍵+1)×((⍵-1)÷⍵+1)*0.5
	5=⍺:'sinh_vec_ibeam'⌶ ⍵
	¯5=⍺:'arcsinh_vec_ibeam'⌶ ⍵
	6=⍺:'cosh_vec_ibeam'⌶ ⍵
	¯6=⍺:'arccosh_vec_ibeam'⌶ ⍵
	7=⍺:'tanh_vec_ibeam'⌶ ⍵
	¯7=⍺:'arctanh_vec_ibeam'⌶ ⍵
	8=⍺:(-1+⍵*2)*0.5
	¯8=⍺:-8○⍵
	9=⍺:{1289≡⎕DR ⍵:'realpart_vec_ibeam'⌶ ⍵ ⋄ ⍵}⍵
	¯9=⍺:⍵
	10=⍺:|⍵
	¯10=⍺:+⍵
	11=⍺:{1289≡⎕DR ⍵:'imagpart_vec_ibeam'⌶ ⍵ ⋄ (⍴⍵)⍴0}⍵
	¯11=⍺:⍵×0J1
	12=⍺:'PHASE(⍵) NOT IMPLEMENTED'⎕SIGNAL 16
	¯12=⍺:*⍵×0J1
	⎕SIGNAL 11
}
cir←pitimes numeric ambiv (trig numeric scalar)

⍝ !: Factorial | Binomial
binomial←{
	∨⌿,(⍵=⌊⍵)∧(⍵<0)∧⍺≠⌊⍺:⎕SIGNAL 11
	(!⍵)÷(!⍺)×!⍵-⍺
}
fac←'factorial_vec_ibeam'⌶ numeric ambiv (binomial numeric scalar)

⍝ ~: Not | Without
notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}
without←{⎕SIGNAL 16}
not←notscl ambiv without

⍝ ∧: And
logand←{
	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵
	⍺×⍵÷z+0=z←⍺∨⍵
}
and←{⎕SIGNAL 2}ambiv (logand numeric scalar)

⍝ ∨: Or
logor←{
	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵
	(is_bool ⍺)∧is_integer ⍵:⍺+(~⍺)×|⍵
	(is_bool ⍵)∧is_integer ⍺:⍵+(~⍵)×|⍺
	⍺ both_integer ⍵:(|⍺){~∨⌿m←⍵≠0:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵
	(|⍺){~∨⌿m←⍵>1e¯12:⍺ ⋄ ((⍺×~m)+m×⍵)∇(⍵×~m)+m×⍵|⍺}|⍵
}
lor←{⎕SIGNAL 2}ambiv (logor numeric scalar)

⍝ ⍲: Not and
nan←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}

⍝ ⍱: Not Or
nor←{⎕SIGNAL 2}ambiv{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}

⍝ <: Less than
lessthan←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('lth_vec_ibeam'⌶)⍵
}
lth←{⎕SIGNAL 2} ambiv (lessthan numeric scalar)

⍝ ≤: Less than or equal
lesseql←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('lte_vec_ibeam'⌶)⍵
}
lte←{⎕SIGNAL 2}ambiv (lesseql numeric scalar)

⍝ =: Equal
eql_vec←'eql_vec_ibeam'⌶
equal←{
	⍺ both_numeric ⍵:⍺ eql_vec ⍵
	⍺ both_char ⍵:⍺ eql_vec ⍵
	0
}
eql←{⎕SIGNAL 2}ambiv (equal scalar)

⍝ ≥: Greater than or equal
greatereql←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('gte_vec_ibeam'⌶)⍵
}
gte←{⎕SIGNAL 2}ambiv (greatereql numeric scalar)

⍝ >: Greater than
greaterthan←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('gth_vec_ibeam'⌶)⍵
}
gth←{⎕SIGNAL 2}ambiv (greaterthan numeric scalar)

⍝ ≠: Not Equal | First Occurrence
firstocc←{⎕SIGNAL 16}
neq_vec←'neq_vec_ibeam'⌶
noteq←{
	⍺ both_numeric ⍵:⍺ neq_vec ⍵
	⍺ both_char ⍵:⍺ neq_vec ⍵
	1
}
neq←firstocc ambiv (noteq scalar)

⍝ ↑: Mix | Take
mix←{
	1≥≡squeeze ⍵:⍵
	k←≢s←⊃{(k↑(⍴⍺),k⍴1)⌈k↑⍵,k⍴1⊣k←(≢⍴⍺)⌈≢⍵}⌿(,⍵),⊂⍬
	((⍴⍵),s)⍴z⊣(⍳≢,⍵){z[⍺;]←,s↑(k↑(⍴⍵),k⍴1)⍴⍵}¨,⍵⊣z←((≢,⍵),×⌿s)⍴0
}
take←{
	1<≢⍴⍺:⎕SIGNAL 4
	hax←1 ⋄ axis⍠←⍳≢⍺⊣hax←0
	1<≢⍴axis:⎕SIGNAL 11
	(≢,⍺)≢≢,axis:⎕SIGNAL 5
	~is_integer axis:⎕SIGNAL 11
	x←⍺ ⋄ y←⍺{(~hax)∧0≡≢⍴⍵:((≢⍺)⍴1)⍴⍵ ⋄ ⍵}⍵ 
	any(axis<0)∨axis≥≢⍴y:⎕SIGNAL 4
	~any(|x)≥(⍴y)[axis]:((⍳¨|x)+(x<0)×(⍴y)[axis]-|x)⌷[axis]y
	s←⍴y ⋄ s[axis]←x ⋄ m←s<0 ⋄ s←|s ⋄ z←s⍴0⍴y
	i←,z flatten_idx (wi←⍳¨w)+m×s-w←s⌊⍴y
	s⍴z⊣z[i]←,(wi+m×(⍴y)-w)⌷y⊣z←,z
}
tke←mix ambiv take

⍝ ↓: Split | Drop
split←{⎕SIGNAL 16}
drop←{
	1<≢⍴⍺:⎕SIGNAL 4
	hax←1 ⋄ axis⍠←⍳≢⍺⊣hax←0
	1<≢⍴axis:⎕SIGNAL 11
	(≢,⍺)≢≢,axis:⎕SIGNAL 5
	~is_integer axis:⎕SIGNAL 11
	x←⍺ ⋄ y←⍺{(~hax)∧0≡≢⍴⍵:((≢⍺)⍴1)⍴⍵ ⋄ ⍵}⍵ 
	any(axis<0)∨axis≥≢⍴y:⎕SIGNAL 4
	((0⌈x)+⍳¨0⌈(⍴y)[axis]-|x)⌷[axis]y
}
drp←split ambiv drop

⍝ ⊖: Rerverse First | Rotate First
rtf←{⎕SIGNAL 16}

⍝ ⌽: Reverse Last | Rotate Last
reverse_last←{0≡≢⍴⍵:⍵ ⋄ (⊂(≢⍵)-1+⍳≢⍵)⌷⍵}
rotate_last←{0≡≢⍴⍵:⍵ ⋄ (⊂(≢⍵)|⍺+⍳≢⍵)⌷⍵}
rot←reverse_last ambiv rotate_last

⍝ ⍉: Transpose
trn←{⎕SIGNAL 16}

⍝ ⍋: Grade Up
gdu←{⎕SIGNAL 16}

⍝ ⍒: Grade Down
gdd←{⎕SIGNAL 16}

⍝ ⊤: Encode
enc←{
	~is_numeric ⍺:⎕SIGNAL 11 ⋄ ~is_numeric ⍵:⎕SIGNAL 11
	d←⌽×\⌽⍺+⍺=0 ⋄ z←d∘.{⍵-⍺×⌊⍵÷⍺+⍺=0}⍵
	d←(⍴d)⍴1↓[0⌈¯1+≢⍴d]d,1
	(d≠0)×[⍳≢⍴d]⌊z÷[⍳≢⍴d]d+d=0
}

⍝ ⊥: Decode
dec←{
	(0≢≢⍴⍺)∧(0≢≢⍴⍵)∧(1≢lc)∧(1≢rc)∧(rc←≢⍵)≢lc←1⌈⊃⌽⍴⍺:⎕SIGNAL 5
	s←(¯1↓⍴⍺),1↓⍴⍵
	(0≡≢,⍺)∨0≡≢,⍵:s⍴0
	~(squeeze ⍺)both_numeric squeeze ⍵:⎕SIGNAL 11
	lv←⍺{1≡lc:rc/⍺ ⋄ ⍺}⍵
	rv←⍺{1≡rc:lc⌿⍵ ⋄ ⍵}⍵
	rv+.×⍨⌽×\1,⌽1↓[¯1+≢⍴lv]lv
}

⍝ ∊: Membership
mem←{⎕SIGNAL 16}

⍝ ⍷: Find
fnd←{⎕SIGNAL 16}

⍝ ∪: Unique | Union
unq←{⎕SIGNAL 16}

⍝ ∩: Intersection
int←{⎕SIGNAL 16}

⍝ ?: Roll | Deal
deal←{
	(0≢≢⍴squeeze ⍺)∨(0≢≢⍴squeeze ⍵):⎕SIGNAL 5
	~⍺ both_integer ⍵:⎕SIGNAL 11
	(⍺>⍵)∨(⍺<0)∨⍵<0:⎕SIGNAL 11 ⋄ 0≡⍺:⍬
	d←⍳⍵ ⋄ s{⊃d[⍺ ⍵]←d[⍵ ⍺]}¨s+?⍵-s←⍳⍺
}
roll←{
	~is_integer squeeze ⍵:⎕SIGNAL 11
	0≡≢,⍵:(⍴⍵)⍴⍬
	any ⍵<0:⎕SIGNAL 11
	(rnd×⍵=0)+⌊⍵×rnd←(⍴⍵)⍴'roll_ibeam'⌶ ⍵
}
rol←roll ambiv deal

⍝ ⌹: Matrix Division
mdv←{⎕SIGNAL 16}

⍝ ⍨: Commute
com←{2=⎕NC'⍺⍺':⍺⍺ ⋄ ⍺←⍵ ⋄ ⍵ ⍺⍺ ⍺}

⍝ ¨: Each
map←{⍺←⊢ ⋄ ⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴squeeze ⍺ ⍺⍺ veach ⍵}

⍝ ⌿: Reduce First | N-wise Reduce First
identity←{
	⍺⍺ eq + ⍬:0
	⍺⍺ eq - ⍬:0
	⍺⍺ eq × ⍬:1
	⍺⍺ eq ÷ ⍬:1
	⍺⍺ eq | ⍬:0
	⍺⍺ eq ⌊ ⍬:1.7976931348623157E308
	⍺⍺ eq ⌈ ⍬:¯1.7976931348623157E308
	⍺⍺ eq * ⍬:1
	⍺⍺ eq ! ⍬:1
	⍺⍺ eq ∧ ⍬:1
	⍺⍺ eq ∨ ⍬:0
	⍺⍺ eq < ⍬:0
	⍺⍺ eq ≤ ⍬:1
	⍺⍺ eq = ⍬:1
	⍺⍺ eq ≥ ⍬:1
	⍺⍺ eq > ⍬:0
	⍺⍺ eq ≠ ⍬:0
	⍺⍺ eq ⊤ ⍬:0
	⍺⍺ eq ∪ ⍬:⊂⍬
	⍺⍺ eq ⌿ ⍬:1
	⍺⍺ eq / ⍬:1
	⍺⍺ eq \ ⍬:1
	⍺⍺ eq ⍀ ⍬:1
	⍺⍺ eq ⌽ ⍬:0
	⍺⍺ eq ⊖ ⍬:0
	⎕SIGNAL 16
}
reduce←{axis←⍵⍵ ⋄ op←⍺⍺¨
	⍺∧0≡≢⍴⍵:⎕SIGNAL 4 ⋄ 0≡≢⍴⍵:0∇,⍵
	c←(s←⍴⍵)[axis] ⋄ zs←(axis↑s),(axis+1)↓s
	0≡c:zs⍴⍺⍺ identity ⍬ ⋄ 1≡c:zs⍴⍵
	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷[axis]⍵)op z}¨⊂⍵⊣z←(c-1)⌷[axis]⍵
}
nwreduce←{op←⍺⍺¨ ⋄ 1≢≢,axis←⍵⍵:⎕SIGNAL 5 ⋄ rc←1+(⍴⍵)[axis]
	1≢≢,⍺:⎕SIGNAL 5 ⋄ 0≡is_integer ⍺:⎕SIGNAL 11 ⋄ (|⍺)>rc:⎕SIGNAL 5
	0=⍺:(s⊣s[axis]+←1⊣s←⍴⍵)⍴⍺⍺ identity ⍬ ⋄ 1=|⍺:⍵
	rc-←|⍺ ⋄ stp←{z⊢←((⊂⍺+⍳rc)⌷[axis]⍵)op z}
	⍺<0:z⊣(1+⍳¯1+|⍺)stp¨⊂⍵⊣z←rc↑[axis]⍵
	z⊣(⌽⍳⍺-1)stp¨⊂⍵⊣z←(⍺-1)↓[axis]⍵
}
red_check←{⍺←0 ⋄ 1<≢⍴⍺:⎕SIGNAL 4 ⋄ 1≢≢,⍺:⎕SIGNAL 5 ⋄ 0}
rdf←{⍺←⊢ ⋄ ⍺ red_check ⍵: ⋄ hax←1 ⋄ axis⍠←0⊣hax←0
	1≡⍺ 1:hax(⍺⍺ reduce axis)⍵ ⋄ ⍺(⍺⍺ nwreduce axis)⍵
}

⍝ /: Reduce | N-wise Reduce
red←{⍺←⊢ ⋄ ⍺ red_check ⍵: ⋄ hax←1 ⋄ axis⍠←0⌈¯1+≢⍴⍵⊣hax←0
	1≡⍺ 1:hax(⍺⍺ reduce axis)⍵ ⋄ ⍺(⍺⍺ nwreduce axis)⍵
}

⍝ ⍸: Where/Interval Index
where_nz←'where_nz_ibeam'⌶
where←{
	1<≢⍴⍵:⎕SIGNAL 16
	0≡≢,⍵:⍬
	~is_numeric ⍵:⎕SIGNAL 11 ⋄ any ⍵<0:⎕SIGNAL 11
	0≡≢i←where_nz ⍵:⍬
	sx←+⍀x←(,⍵)[i] ⋄ (≢i)≡c←sx[0⌈¯1+≢i]:i
	+⍀z⊣z[0,¯1↓sx]←i-0,¯1↓i⊣z←c⍴0
}
interval_idx←{⎕SIGNAL 16}
iou←where ambiv interval_idx

⍝ ⌿⌿: Replicate First
rpf←{
	hax←1 ⋄ axis⍠←hax←0 ⋄ hax∧0≡≢⍴⍵:⎕SIGNAL 4
	noscl←{0≡≢⍴⍵:,⍵ ⋄ ⍵} ⋄ x←noscl ⍺ ⋄ y←noscl ⍵
	1<≢⍴axis:⎕SIGNAL 5 ⋄ 1≢≢,axis:⎕SIGNAL 5
	axis<0:⎕SIGNAL 11 ⋄ axis≥≢⍴y:⎕SIGNAL 4 ⋄ 1<≢⍴⍺:⎕SIGNAL 4
	(0≢≢x)∧~is_integer x:⎕SIGNAL 11
	(ya≢≢x)∧(1≢≢x)⍱1≢ya←(⍴y)[axis]:⎕SIGNAL 5
	ac←ya{(⍺⌈⍵)×⍺ ⍵∧.≠0}≢x ⋄ x←ac⍴x
	s←⍴z←(⊂(ya≠1)×i←⍸|x)⌷[axis]y ⋄ ls←×⌿axis↑s ⋄ rs←×⌿(axis+1)↓s
	z←ls(s[axis])rs⍴z ⋄ z[;⍸x[i]<0;]←⊃0⍴,y ⋄ s⍴z
}

⍝ //: Replicate
rep←{
	hax←1 ⋄ axis⍠←0⌈¯1+≢⍴⍵⊣hax←0 ⋄ hax∧0≡≢⍴⍵:⎕SIGNAL 4
	noscl←{0≡≢⍴⍵:,⍵ ⋄ ⍵} ⋄ x←noscl ⍺ ⋄ y←x{1≡≢,⍵:(⍴⍺)⍴⍵ ⋄ ⍵}noscl ⍵
	x⌿[axis]y	
}

⍝ ⍀: Scan First
scan←{axis←⍵⍵ ⋄ fn←⍺⍺ ⋄ hax←⍺
	hax∧0≡≢⍴⍵:⎕SIGNAL 4 ⋄ 0≡≢⍴⍵:⍵
	1<≢⍴axis:⎕SIGNAL 4 ⋄ 1≢≢,axis:⎕SIGNAL 5 ⋄ (axis<0)∨axis≥≢⍴⍵:⎕SIGNAL 4
	1≡≢,⍵:⍵ ⋄ (0≡≢,⍵)∨1≡(⍴⍵)[axis]:⍵
	1≥≢⍴⍵:squeeze (⍴⍵)⍴{fn⌿x[⍳⍵]}¨1+⍳≢x←⍵
	c←(⍴⍵)[axis] ⋄ ls←×⌿axis↑⍴⍵ ⋄ rs←×⌿(axis+1)↓⍴⍵
	z←ls c rs⍴⊃⍵ ⋄ x←ls c rs⍴⍵
	squeeze(⍴⍵)⍴z⊣{z[;⍵;]←fn⌿[1]x[;⍳1+⍵;]}¨⍳c
}
scf←{hax←1 ⋄ axis⍠←hax←0 ⋄ hax ⍺⍺ scan axis⊢⍵}
	
⍝ \: Scan
scn←{hax←1 ⋄ axis⍠←0⌈¯1+≢⍴⍵⊣hax←0 ⋄ axis ⍺⍺ scan axis⊢⍵}

⍝ ⍀⍀: Expand First
xpf←{⎕SIGNAL 16}

⍝ \\: Expand Last
xpd←{⎕SIGNAL 16}

⍝ ∘.: Outer Product
oup←{i←⍳(≢,⍺)×y←≢,⍵ ⋄ ((⍴⍺),⍴⍵)⍴(,⍺)[⌊i÷y]⍺⍺¨(,⍵)[y|i]}

⍝ .: Inner Product
dot←{
	x←⍺{0≡≢⍴⍺:1 1⍴⍺ ⋄ 1≡≢⍴⍺:(1,⍴⍺)⍴⍺ ⋄ ,[⍳¯1+≢⍴⍺]⍺}⍵
	y←⍺{0≡≢⍴⍵:1 1⍴⍵ ⋄ 1≡≢⍴⍵:((⍴⍵),1)⍴⍵ ⋄ ,[1+⍳¯1+≢⍴⍵]⍵}⍵
	f←⍺⍺ ⋄ g←⍵⍵
	((¯1↓⍴⍺),1↓⍴⍵)⍴(⍳≢x)∘.{f⌿x[⍺;] g¨ y[;⍵]}⍳1⌷⍴y
}

⍝ ⍣: Power Operator
pow←{
	⍺←⊢ ⋄ l←⍺ ⋄ f←⍺⍺ ⋄ g←⍵⍵
	3=⎕NC'⍵⍵':{(z←l f ⍵)g ⍵:z ⋄ ∇z}⍵
	g{0≡⍺:⍵ ⋄ (⍺-1)∇l f ⍵}⍵
}

⍝ ∘: Compose Operator
jot←{
	type←⎕NC'⍺' '⍺⍺' '⍵⍵'
	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵
	type≡0 3 3:⍺⍺ ⍵⍵ ⍵
	type≡0 2 3:⍺⍺ ⍵⍵ ⍵
	type≡0 3 2:⍵ ⍺⍺ ⍵⍵
	⎕SIGNAL 2
}

⍝ ⍤: Rank operator
rnk←{fn←⍺⍺ ⋄ spec←⍵⍵ ⋄ ⍺←⊢
	1<≡spec:⎕SIGNAL 11 ⋄ 1<≢⍴spec:⎕SIGNAL 4 ⋄ 3<≢spec:⎕SIGNAL 5
	spec←3⍴(¯1×2≡≢spec)⌽spec ⋄ p←spec[0] ⋄ q←spec[1] ⋄ r←spec[2]
	1≡⍺ 1:{p≥k←≢⍴⍵:fn ⍵ ⋄ k≤|p:↑fn¨⍵ ⋄ ↑(d↑⍴⍵)⍴{fn ⍵⌷z}¨⍳≢z←,[⍳d←k-k|p]⍵}⍵
	dx←⍺{q≥k←≢⍴⍺:0 ⋄ k≤|q:k ⋄ k-k|q}⍵ ⋄ dy←⍺{r≥k←≢⍴⍵:0 ⋄ k≤|r:k ⋄ k-k|r}⍵
	s←⍺{
		dx∧dy∧dx≢dy:⎕SIGNAL 4 ⋄ dx∧dy∧(dx↑⍴⍺)≢dy↑⍴⍵:⎕SIGNAL 5
		dx≢0:dx↑⍴⍺ ⋄ dy≢0:dy↑⍴⍵ ⋄ ⍬
	}⍵
	x←⍺{dx≡0:(1,⍴⍺)⍴⍺ ⋄ ,[⍳dx]⍺}⍵ ⋄ y←⍺{dy≡0:(1,⍴⍵)⍴⍵ ⋄ ,[⍳dy]⍵}⍵
	↑s⍴((≢x)|⍳c){(⍺⌷x) fn ⍵⌷y}¨(≢y)|⍳c←(≢x)⌈≢y
}

⍝ ⌸: Key operator
key←{fn←⍺⍺ ⋄ ⎕SIGNAL 16}

:EndNamespace
