:Namespace cdf_prim

⍝ Basic system functions
q_signal←'q_signal_ibeam'⌶
q_dr←'q_dr_ibeam'⌶
q_veach←'q_veach_ibeam'⌶⌶
q_ambiv←'q_ambiv_ibeam'⌶⌶⌶

⍝ Utilities
squeeze←'squeeze_ibeam'⌶
is_simple←'is_simple_ibeam'⌶
is_numeric←'is_numeric_ibeam'⌶
is_char←'is_char_ibeam'⌶
is_integer←'is_integer_ibeam'⌶
is_bool←{11≡⎕DR squeeze ⍵}
max_shp←'max_shp_ibeam'⌶
has_nat_vals←'has_nat_vals_ibeam'⌶
chk_scl←{(⍴⍺)≡⍴⍵:0 ⋄ 1≡≢,⍺:0 ⋄ 1≡≢,⍵:0 ⋄ (≢⍴⍺)≡≢⍴⍵:⎕SIGNAL 5 ⋄ ⎕SIGNAL 4}
chk_valid_shape←{
	{rnk←≢⍴⍵ ⋄ 0≡rnk:0 ⋄ 1≡rnk:0 ⋄ 1}⍵:⎕SIGNAL 4
	{has_nat_vals ⍵:0 ⋄ 1}⍵:⎕SIGNAL 11
	0
}
both_simple←{is_simple ⍺:is_simple ⍵ ⋄ 0}
both_numeric←{is_numeric ⍺:is_numeric ⍵ ⋄ 0}
both_char←{is_char ⍺:is_char ⍵ ⋄ 0}
both_bool←{is_bool ⍺:is_bool ⍵ ⋄ 0}
numeric←{⍺ both_numeric ⍵:⍺ ⍺⍺ ⍵ ⋄ ⎕SIGNAL 11}
scalar←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ ⍺ both_simple ⍵:s⍴⍺ ⍺⍺ ⍵ ⋄ s⍴⍺ ∇ ⎕VEACH ⍵}

⍝ ⊢: Right
rgt←{⍵}

⍝ ⊣: Left
lft←{⍵} ⎕AMBIV {⍺}

⍝ ⍴: Shape / Reshape
reshape←{chk_valid_shape ⍺: ⋄ ⍺('reshape_ibeam'⌶)⍵}
rho←('shape_ibeam'⌶) ⎕AMBIV reshape

⍝ ,: Ravel / Catenate
cat←('ravel_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}

⍝ ≡: Depth / Same
depth←{
	is_simple ⍵:{0≡≢⍴⍵:0 ⋄ 1}⍵
	⎕SIGNAL 16
}
eqv←depth ⎕AMBIV ('same_ibeam'⌶)

⍝ ≢: Tally / Not Same
nqv←{⊃⍴⍵} ⎕AMBIV ('nqv_ibeam'⌶)

⍝ ⌷: Materialize | Squad indexing
materialize←{⎕SIGNAL 16}
index←{idx←⊃⍺ ⋄ rnk←≢⍴idx
	0≡is_integer idx:⎕SIGNAL 11
	{0≡⍵:0 ⋄ 1≡⍵:0 ⋄ 1}rnk:⎕SIGNAL 16
	(⍴idx)⍴idx('index_ibeam'⌶)⍵
}
sqd←materialize ⎕AMBIV index

⍝ ⍳: Index Generate | Index Of
index_gen←{
	chk_valid_shape ⍵: 
	0≡≢,⍵:⊂⍬
	(,0)≡,⍵:⍬
	1≡≢,⍵:'index_gen_vec'⌶ ⍵
	⎕SIGNAL 16
}
index_of←{⎕SIGNAL 16}
iot←index_gen ⎕AMBIV index_of

⍝ ⊃: First / Pick
dis←('disclose_ibeam'⌶) ⎕AMBIV {⎕SIGNAL 16}

⍝ ⊂: Enclose / Partition
enclose←{
	0≡≡⍵:⍵
	'enclose_ibeam'⌶ ⍵
}
par←enclose ⎕AMBIV {⎕SIGNAL 16}

⍝ +: Conjugate | Addition
conjugate←{1289≡⎕DR squeeze ⍵:'conjugate_vec'⌶ ⍵ ⋄ ⍵}
add←conjugate ⎕AMBIV ('add_vec_ibeam'⌶ numeric scalar)

⍝ -: Negate | Subtract
negate←{⎕SIGNAL 16}
sub←negate ⎕AMBIV ('sub_vec_ibeam'⌶ numeric scalar)

⍝ ×: Sign | Multiply
sign←{⎕SIGNAL 16}
mul←sign ⎕AMBIV ('mul_vec_ibeam'⌶ numeric scalar)

⍝ ÷: Reciprocal | Divide
recip←{⎕SIGNAL 16}
div←recip ⎕AMBIV ('div_vec_ibeam'⌶ numeric scalar)

⍝ |: Absolute Value | Residue
absolute←{
	0≡is_numeric ⍵:⎕SIGNAL 11
	1289≡⎕DR ⍵:⎕SIGNAL 11
	'abs_ibeam'⌶ ⍵
}
residue←{⎕SIGNAL 16}
res←absolute ⎕AMBIV residue

⍝ ⌊: Floor | Minimum
min←'floor_vec_ibeam'⌶ numeric ⎕AMBIV ('min_vec_ibeam'⌶ numeric scalar)

⍝ ⌈: Ceiling | Maximum
max←'ceil_vec_ibeam'⌶ ⎕AMBIV ('max_vec_ibeam'⌶ numeric scalar)

⍝ *: Exponent | Power
exp←'exp_vec_ibeam'⌶ ⎕AMBIV ('pow_vec_ibeam'⌶ numeric scalar)

⍝ ⍟: Natural Logarithm | Logarithm
log←'nlg_vec_ibeam'⌶ ⎕AMBIV ('log_vec_ibeam'⌶ numeric scalar)

⍝ ○: Pi Times | Trigonometric Functions
cir←'pitimes_vec_ibeam'⌶ ⎕AMBIV ('trig_vec_ibeam'⌶ numeric scalar)

⍝ !: Factorial | Binomial
fac←'factorial_vec_ibeam'⌶ ⎕AMBIV ('binomial_vec_ibeam'⌶ numeric scalar)

⍝ ~: Not | Without
notscl←{is_bool ⍵:'not_vec_ibeam'⌶ ⍵ ⋄ ⎕SIGNAL 11}
without←{⎕SIGNAL 16}
not←notscl ⎕AMBIV without

⍝ ∧: And
logand←{
	⍺ both_bool ⍵:⍺('and_vec_ibeam'⌶)⍵
	⎕SIGNAL 16
}
and←{⎕SIGNAL 2}⎕AMBIV (logand numeric scalar)

⍝ ∨: Or
logor←{
	⍺ both_bool ⍵:⍺('lor_vec_ibeam'⌶)⍵
	⎕SIGNAL 16
}
lor←{⎕SIGNAL 2}⎕AMBIV (logor numeric scalar)

⍝ ⍲: Not and
nan←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∧⍵ ⋄ ⎕SIGNAL 11}

⍝ ⍱: Not Or
nor←{⎕SIGNAL 2}⎕AMBIV{⍺ both_bool ⍵:~⍺∨⍵ ⋄ ⎕SIGNAL 11}

⍝ <: Less than
lessthan←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('lth_vec_ibeam'⌶)⍵
}
lth←{⎕SIGNAL 2} ⎕AMBIV (lessthan numeric scalar)

⍝ ≤: Less than or equal
lesseql←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('lte_vec_ibeam'⌶)⍵
}
lte←{⎕SIGNAL 2}⎕AMBIV (lesseql numeric scalar)

⍝ =: Equal
eql_vec←'eql_vec_ibeam'⌶
equal←{
	⍺ both_numeric ⍵:⍺ eql_vec ⍵
	⍺ both_char ⍵:⍺ eql_vec ⍵
	0
}
eql←{⎕SIGNAL 2}⎕AMBIV (equal scalar)

⍝ ≥: Greater than or equal
greatereql←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('gte_vec_ibeam'⌶)⍵
}
gte←{⎕SIGNAL 2}⎕AMBIV (greatereql numeric scalar)

⍝ >: Greater than
greaterthan←{
	1289≡⎕DR ⍵:⎕SIGNAL 11 ⋄ 1289≡⎕DR ⍺:⎕SIGNAL 11
	⍺('gth_vec_ibeam'⌶)⍵
}
gth←{⎕SIGNAL 2}⎕AMBIV (greaterthan numeric scalar)

⍝ ≠: Not Equal | First Occurrence
firstocc←{⎕SIGNAL 16}
neq_vec←'neq_vec_ibeam'⌶
noteq←{
	⍺ both_numeric ⍵:⍺ neq_vec ⍵
	⍺ both_char ⍵:⍺ neq_vec ⍵
	1
}
neq←firstocc ⎕AMBIV (noteq scalar)

⍝ ↓: Split | Drop
split←{⎕SIGNAL 16}
drop←{(⊂⍺+⍳(≢⍵)-⍺)⌷⍵}
drp←split ⎕AMBIV drop

⍝ ⌽: Reverse Last | Rotate Last
reverse_last←{(⊂(≢⍵)-1+⍳≢⍵)⌷⍵}
rotate_last←{⎕SIGNAL 16}
rot←reverse_last ⎕AMBIV rotate_last

⍝ ¨: Each
map_monadic←{⎕SIGNAL 16}
map_dyadic←{⍺ chk_scl ⍵: ⋄ s←⍺ max_shp ⍵ ⋄ s⍴⍺ ⍺⍺ ⎕VEACH ⍵}
map←{⍺ ⍺⍺ map_dyadic ⍵}

⍝ ⌿: Reduce First | N-wise Reduce First
reduce←{
	0≡≢⍴⍵:∇,⍵ ⋄ s←⍴⍵ ⋄ c←⊃s ⋄ zs←1↓s
	0≡c:⎕SIGNAL 16 ⋄ 1≡c:zs⍴⍵ ⋄ op←⍺⍺¨
	z⊣(⌽⍳c-1){⍬⊣z⊢←(⍺⌷⍵)op z}¨⊂⍵⊣z←(c-1)⌷⍵
}
nwreduce←{op←⍺⍺¨
	0≡is_integer ⍺:⎕SIGNAL 11 ⋄ rc←1+≢⍵ ⋄ rc<⍺:⎕SIGNAL 5 ⋄ rc-←|⍺
	z⊣(⌽⍳⍺-1){z⊢←((⊂⍺+⍳rc)⌷⍵)op z}¨⊂⍵⊣z←(⍺-1)↓⍵
}
rdf←{⍺←⊢ ⋄ 1<≢⍴⍺⊣0:⎕SIGNAL 4 ⋄ 1≢≢,⍺⊣0:⎕SIGNAL 5
	⍬≡⍺⊣⍬:⍺⍺ reduce ⍵ ⋄ ⍺(⍺⍺ nwreduce)⍵
}

⍝ ⌿⌿: Replicate First
rpf←{⎕SIGNAL 16}

⍝ .: Inner Product
dot←{⍺⍺⌿⍺ ⍵⍵¨ ⍵}

⍝ ⍣: Power Operator
pow←{0≡⍵⍵:⍵ ⋄ ⍺←⊢ ⋄ ⍺ ⍺⍺∇∇(⍵⍵-1)⊢⍺ ⍺⍺ ⍵}

⍝ ∘: Compose Operator
jot←{
	type←⎕NC'⍺' '⍺⍺' '⍵⍵'
	type≡2 3 3:⍺ ⍺⍺ ⍵⍵ ⍵
	type≡0 3 3:⍺⍺ ⍵⍵ ⍵
	type≡0 2 3:⍺⍺ ⍵⍵ ⍵
	type≡0 3 2:⍵ ⍺⍺ ⍵⍵
	⎕SIGNAL 2
}

:EndNamespace
