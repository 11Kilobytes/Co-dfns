CP←{ast←⍵
     pm←(1⌷⍉⍵)∊⊂'Primitive'               ⍝ Mask of Primitive nodes
     pn←'name'Prop pm⌿⍵                   ⍝ Primitive names
     cn←(APLPrims⍳pn)⌷¨⊂APLRunts⍪APLRtOps ⍝ Converted names
     hd←⍉⍪'class' 'function'              ⍝ Class is function
     at←(⊂⊂'name')(hd⍪,)¨cn               ⍝ Name of the function
     vn←(⊂'Variable'),(⊂''),⍪at           ⍝ Build the basic node structure
     ast⊣(pm⌿ast)←(pm/0⌷⍉⍵),vn            ⍝ Replace Primitive nodes
}

ConvertArray←{
     s←ffi_get_size ⍵                     ⍝ Get the number of data elements
     t←ffi_get_type ⍵                     ⍝ Type of data
     d←{
         t=2:ffi_get_data_int s ⍵         ⍝ Integer type
         ffi_get_data_float s ⍵           ⍝ Float type
     }⍵
     r←ffi_get_rank ⍵                     ⍝ Get the number of shape elements
     p←ffi_get_shape r ⍵                  ⍝ Get the shapes
     t,⊂p⍴d                               ⍝ Reshape based on shape
}

∇Z←FI;C;E;I;G;D;R;P
 Z←⍬ ⋄ R←CodfnsRuntime
 'ffi_get_type'⎕NA'U1 ',R,'|ffi_get_type P'
 'ffi_get_data_int'⎕NA R,'|ffi_get_data_int >I8[] P'
 'ffi_get_data_float'⎕NA R,'|ffi_get_data_float >F8[] P'
 'ffi_get_shape'⎕NA R,'|ffi_get_shape >U8[] P'
 'ffi_get_size'⎕NA'U8 ',R,'|ffi_get_size P'
 'ffi_get_rank'⎕NA'U2 ',R,'|ffi_get_rank P'
 'ffi_make_array_int'⎕NA'I ',R,'|ffi_make_array_int >P U2 U8 <U8[] <I8[]'
 'ffi_make_array_double'⎕NA'I ',R,'|ffi_make_array_double >P U2 U8 <U8[] <F8[]'
 'array_free'⎕NA R,'|array_free P'
 'cstring'⎕NA'libc.so.6|memcpy >C[] P P'
 'strlen'⎕NA'P libc.so.6|strlen P'
 'free'⎕NA'libc.so.6|free P'
∇
