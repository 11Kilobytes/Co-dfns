<?xml version="1.0" encoding="utf-8" ?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
 	<info>
    <title>Co-dfns Increment Test Plan</title>
    <author>
      <personname>Aaron W. Hsu</personname>
    </author>
		<date>Monday, November 25th, 2013</date>
  </info>
	<simpara>
		This document details the overall approach to testing, and
		provides documentation and insight into the structure and proper
		use of the other work products developed during Usage Modeling
		and Test Planning, namely, the <citetitle>Usage
		Models</citetitle> and <citetitle>Statistical Test
		Cases</citetitle>. This includes important details like how to
		run the tests, how the tests will be measured, as well as the
		order in which testing should be conducted. It does not include
		the actual usage models or test cases, but covers everything
		else created or designed during the Usage Modeling and Test
		Planning process.
	</simpara>
	<section>
		<title>Usage Model Overview</title>
		<simpara>
			The <filename>Certification.dws</filename> workspace contains
			the usage models documented here. The namespace
			<classname>UsageModels</classname> inside of the
			<filename>Certification.dws</filename> workspace contains the
			actual usage models. There are four usage models which
			correspond to the four general sequence enumerations in the
			<citetitle>Function Specification</citetitle>.  The
			<citetitle>Usage Specification</citetitle> diagrams and
			roughly estimates the basic structure and outline of each of
			these usage models.
		</simpara>
		<table frame="void" rules="rows">
			<caption>Usage Models and the Corresponding Recursions</caption>
			<thead>
				<tr>
					<th>Recursive Stimuli</th>
					<th colspan="2">Usage Model Name</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Top-level</td>
					<td colspan="2"><varname>UsageModels.TopLevel</varname></td>
				</tr>
				<tr>
					<td>Function</td>
					<td colspan="2"><varname>UsageModels.Function</varname></td>
				</tr>
				<tr>
					<td>Expression</td>
					<td colspan="2"><varname>UsageModels.Expression</varname></td>
				</tr>
				<tr>
					<td>Function Expression</td>
					<td colspan="2"><varname>UsageModels.FuncExpr</varname></td>
				</tr>
			</tbody>
		</table>
		<simpara>
			While the <citetitle>Usage Specification</citetitle> details a
			number of users and use cases, the most prominent case
			represents that of the tweaker who works on existing code
			bases and alters them for efficiency. This matches relatively
			well to the distribution of code in the wild right now. This
			is the use case that we will test against, as it has the
			greatest impact, and also is the most effective for
			testing. While we could test more than this, the benefit does
			not currently justify the costs of additional testing.
		</simpara>
		<table frame="void" rules="rows">
			<caption>Use Case Enumeration</caption>
			<thead>
				<tr>
					<th>ID</th>
					<th>User Profile</th>
					<th>Use Case</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>Tuner</td>
					<td>Tweak</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Tuner</td>
					<td>Profile</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Tuner</td>
					<td>Benchmark</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Library Writer</td>
					<td>Internal Library</td>
				</tr>
				<tr>
					<td>4</td>
					<td>Library Writer</td>
					<td>External Library</td>
				</tr>
				<tr>
					<td>5</td>
					<td>Direct User</td>
					<td>System</td>
				</tr>
				<tr>
					<td>6</td>
					<td>Direct User</td>
					<td>Interactive</td>
				</tr>
				<tr>
					<td>7</td>
					<td>Auto</td>
					<td>Dynamic</td>
				</tr>
				<tr>
					<td>8</td>
					<td>Auto</td>
					<td>Static</td>
				</tr>
			</tbody>
		</table>
		<simpara>
			While we will not test all of the use cases, we still want to
			allow for adequate specification of these other use cases in
			the case where we would like to run specific tests. Each usage
			model is therefore a set of Markov Models representing the
			distribution of the system. The states in the model are taken
			from the Canonical Analysis in the <citetitle>Function
			Specification</citetitle> while the transitions correspond to
			some possible stimuli at the level of that model. The models
			are only over the stimuli that are in their stimuli sets as
			defined in the <citetitle>Function Specification</citetitle>.
		</simpara>
		<table frame="void" rules="rows">
			<caption>Stimuli Set Ids for each Model</caption>
			<thead>
				<tr>
					<th>ID</th>
					<th>Top-Level</th>
					<th>Function</th>
					<th>Expression</th>
					<th colspan="2">Function Expression</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>E</td>
					<td>E</td>
					<td>E</td>
					<td colspan="2">E</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Fe</td>
					<td>Fe</td>
					<td>Es</td>
					<td colspan="2">Ea</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Fnm</td>
					<td>Fnm</td>
					<td>Fea</td>
					<td colspan="2">Fea</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Fnd</td>
					<td>Fnd</td>
					<td>Fed</td>
					<td colspan="2">Feaa</td>
				</tr>
				<tr>
					<td>4</td>
					<td><literal>⋄</literal></td>
					<td>{</td>
					<td>Fem</td>
					<td colspan="2">Fed</td>
				</tr>
				<tr>
					<td>5</td>
					<td><literal>←</literal></td>
					<td>}</td>
					<td>[</td>
					<td colspan="2">Feda</td>
				</tr>
				<tr>
					<td>6</td>
					<td>Break</td>
					<td>:</td>
					<td>]</td>
					<td colspan="2">Fem</td>
				</tr>
				<tr>
					<td>7</td>
					<td>Eot</td>
					<td>::</td>
					<td>(</td>
					<td colspan="2">Fema</td>
				</tr>
				<tr>
					<td>8</td>
					<td>Fix</td>
					<td><literal>⋄</literal></td>
					<td>)</td>
					<td colspan="2">Feo</td>
				</tr>
				<tr>
					<td>9</td>
					<td>Fnb</td>
					<td><literal>←</literal></td>
					<td>;</td>
					<td colspan="2">Fn</td>
				</tr>
				<tr>
					<td>10</td>
					<td>Fne</td>
					<td>Break</td>
					<td><literal>←</literal></td>
					<td colspan="2">Fnd</td>
				</tr>
				<tr>
					<td>11</td>
					<td>Fnf</td>
					<td>Nl</td>
					<td>Break</td>
					<td colspan="2">Fnm</td>
				</tr>
				<tr>
					<td>12</td>
					<td>Lle</td>
					<td>Vfo</td>
					<td>N</td>
					<td colspan="2">[</td>
				</tr>
				<tr>
					<td>13</td>
					<td>Lls</td>
					<td>Vu</td>
					<td>S</td>
					<td colspan="2">]</td>
				</tr>
				<tr>
					<td>14</td>
					<td>Nl</td>
					<td></td>
					<td>Sm</td>
					<td colspan="2">(</td>
				</tr>
				<tr>
					<td>15</td>
					<td>Nse</td>
					<td></td>
					<td>Sd</td>
					<td colspan="2">)</td>
				</tr>
				<tr>
					<td>16</td>
					<td>Nss</td>
					<td></td>
					<td>Va</td>
					<td colspan="2"><literal>←</literal></td>
				</tr>
				<tr>
					<td>17</td>
					<td>Vi</td>
					<td></td>
					<td>Vna</td>
					<td colspan="2"><literal>⍨</literal></td>
				</tr>
				<tr>
					<td>18</td>
					<td>Vfo</td>
					<td></td>
					<td>Vi</td>
					<td colspan="2"><literal>∘</literal></td>
				</tr>
				<tr>
					<td>19</td>
					<td>Vu</td>
					<td></td>
					<td>Vnu</td>
					<td colspan="2">¨</td>
				</tr>
				<tr>
					<td>20</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">.</td>
				</tr>
				<tr>
					<td>21</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2"><literal>⍣</literal></td>
				</tr>
				<tr>
					<td>22</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2"><literal>/</literal></td>
				</tr>
				<tr>
					<td>23</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2"><literal>⌿</literal></td>
				</tr>
				<tr>
					<td>24</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2"><literal>\</literal></td>
				</tr>
				<tr>
					<td>25</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2"><literal>⍀</literal></td>
				</tr>
				<tr>
					<td>26</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Break</td>
				</tr>
				<tr>
					<td>27</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">D</td>
				</tr>
				<tr>
					<td>28</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Da</td>
				</tr>
				<tr>
					<td>29</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">M</td>
				</tr>
				<tr>
					<td>30</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Ma</td>
				</tr>
				<tr>
					<td>31</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Vi</td>
				</tr>
				<tr>
					<td>32</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Vf</td>
				</tr>
				<tr>
					<td>33</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Vo</td>
				</tr>
				<tr>
					<td>34</td>
					<td></td>
					<td></td>
					<td></td>
					<td colspan="2">Vu</td>
				</tr>
			</tbody>
		</table>
		<simpara>
			Traversing a Markov Model corresponds to a specific Sequence
			History that maps to a given behavior of the system and a
			specific usage case or test. These traversals are defined by
			probabilities assigned to each transition, which correspond to
			the probabilities of encountering the stimuli that corresponds
			to the transition.
		</simpara>
		<simpara>
			This design leads to the following choice of structure for a
			specific usage model. Each usage model is a rank 5 array,
			whose first dimension corresponds to the specific use
			case. The second dimension corresponds to the state in the
			graph, and the third to a specific stimuli in the stimuli set
			of the model. The fourth dimension is the Increment to be
			tested in Index Origin 0.  The fifth dimsension corresponds to
			the probability of the transition.  This structure is
			summarized by the following synopsis, which is an expression
			for assigning model <varname>M</varname> a new transition
			probability <varname>Prob</varname> along the edge that
			corresponds to <varname>Stimuli</varname> for the use case
			<varname>UseCase</varname>.
		</simpara>
		<synopsis>M[UseCase;State;Stimuli;Increment] ← Prob</synopsis>
		<simpara>
			Those interested in the enumeration of the states should see
			the <citetitle>Function Specification</citetitle> canonical
			analysis tables, which enumerate the state space of the
			recursions.
		</simpara>
		<simpara>
			Together with the Usage Models, which describe the
			probabilities of transitions, some definition of the graph
			must exist. The <citetitle>Function Specification</citetitle>
			already defines these graphs in their totality, and they are
			partially described implicitly by the usage models. However,
			the usage models do not explicitly specify the targets of each
			edge in a model. These targets do not change across increments
			or use cases, but a traditional adjacency matrix does not
			suffice, since it is possible to have more than one edge going
			to the same target. We define a target description for each
			model.
		</simpara>
		<table frame="void" rules="rows">
			<caption>Target Descriptions for Each Model</caption>
			<thead>
				<tr>
					<th>Model</th>
					<th>Target Description</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><varname>UsageModels.TopLevel</varname></td>
					<td><varname>Targets.TopLevel</varname></td>
				</tr>
				<tr>
					<td><varname>UsageModels.Function</varname></td>
					<td><varname>Targets.Function</varname></td>
				</tr>
				<tr>
					<td><varname>UsageModels.Expression</varname></td>
					<td><varname>Targets.Expression</varname></td>
				</tr>
				<tr>
					<td><varname>UsageModels.FuncExpr</varname></td>
					<td><varname>Targets.FuncExpr</varname></td>
				</tr>
			</tbody>
		</table>
		<simpara>
			Each target description is represented as a matrix whose first
			dimension is the state space of the model, and whose second
			dimension represents the stimuli set of the model. Thus, the
			following synopsis describes the association of a target state
			<varname>Target</varname> with a origin state
			<varname>State</varname> and an edge corresponding to a
			stimuli in the appropriate stimuli set
			<varname>Stimuli</varname> for the given target description
			<varname>T</varname>.
		</simpara>
		<synopsis>T[State;Stimuli] ← Target</synopsis>
		<simpara>
			To make it easier to manage the stimuli sets, a
			<classname>Stimuli</classname> namespace inside of the
			<filename>Certification.dws</filename> workspace holds the
			stimuli sets for each of the models, represented using their
			canonical ordering as a vector of strings.
		</simpara>
		<table frame="void" rules="rows">
			<caption>Stimuli sets defined in <classname>Stimuli</classname></caption>
			<thead>
				<tr>
					<th>Set</th>
					<th>Variable</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Top Level</td>
					<td><varname>Stimuli.TopLevel</varname></td>
				</tr>
				<tr>
					<td>Function</td>
					<td><varname>Stimuli.Function</varname></td>
				</tr>
				<tr>
					<td>Expression</td>
					<td><varname>Stimuli.Expression</varname></td>
				</tr>
				<tr>
					<td>Function Expression</td>
					<td><varname>Stimuli.FuncExpr</varname></td>
				</tr>
			</tbody>
		</table>
		<simpara>
			In a similiar vein, the <classname>States</classname>
			namespace provides an association between the canonical
			sequences and the state enumeration used in the usage
			models. This makes it easier to identify the given states by
			their canonical sequence rather than by their ID, which is, of
			course, too hard to remember for mere mortals.
		</simpara>
		<table frame="void" rules="rows">
			<caption>State spaces defined in <classname>States</classname></caption>
			<thead>
				<tr>
					<th>Recursion</th>
					<th>Variable</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Top-Level</td>
					<td><varname>States.TopLevel</varname></td>
				</tr>
				<tr>
					<td>Function</td>
					<td><varname>States.Function</varname></td>
				</tr>
				<tr>
					<td>Expression</td>
					<td><varname>States.Expression</varname></td>
				</tr>
				<tr>
					<td>Function Expression</td>
					<td><varname>States.FuncExpr</varname></td>
				</tr>
			</tbody>
		</table>
	</section>
	<section>
		<title>Testing Plan and Procedures</title>
    <simpara>
      Each Increment will be tested against two sets of test
      cases. The first is a set of coverage tests which do not
      contribute to any sort of statistical results, but that serves
      to verify the correctness of the code behavior along all
      abstract edges and states of the <citetitle>Function
      Specification</citetitle>. After successfully passing all tests
      for the coverage tests, the statistical testing certification
      process begins.
    </simpara>
    <simpara>
      Increment 1, at the time of this writing has already undergone
      certification. However, it and Increment 2 are to be certified
      only against their ability to recognize and generate the correct
      code. The produced code will not be examined or tested, and test
      cases for the resulting code will not be used. Each further
      increment will also be tested mechanically to ensure that the
      resulting output code produces the correct results. This is
      because Increment 3 and onward should return a valid Namespace
      which can be used for testing. 
    </simpara>
    <simpara>
      Each test case for each increment is tested against the 
      <citetitle>Function Specification</citetitle> as well as an
      inspection to ensure that the code produced by the compiler
      matches expectations. A failure of any single test will trigger
      an engineering change and a halt to testing until the change has
      been completed. At this point, the statistical experiment is
      over, recorded, and must begin anew as a new experiement from
      the beginning of the test cases. Meticuluous notes should be 
      kept about the sort of error, the reason for the error, both
      apparent and actual, as well as the impact of the error, the fix
      applied to address the problem, and so forth.
    </simpara>
    <simpara>
      When doing coverage testing, any failures of the system should
      not necessitate an immediate engineering change. All possible
      errors should be recorded and as many of the coverage tests
      completed as possible before beginning an engineering change. 
    </simpara>
    <simpara>
      When examining test failures, a causal analysis should be run to
      determine the reason for the error in the development
      process. That is, the logical fault in the process that lead to
      the introduction of the error should be examined, and any
      adjustments made to ensure that the error is not introduced
      again through a change in the process and the methods of
      development. 
    </simpara>
    <simpara>
      Testing is complete when the compiler passes all of the
      statistical test cases without error. At this point, the
      compiler Increment can be considered and recored as having
      passed certification and the testing process concluded.
    </simpara>
    <simpara>
      The testing environment should be a fresh Co-dfns workspace with
      only the appropriate namespace <classname>CoDfns</classname>
      loaded from the namespace script or equivalent process, and the
      statistical and coverage test cases to be run. No other elements
      should be in the system and the system should start in its
      default state.
    </simpara>
	</section>
  <section>
    <title>Statistical and Coverage Test Cases</title>
    <simpara>
      The statistical test cases are located in the
      <varname>Tests</varname> variable in the
      <filename>Certification.dws</filename> workspace. This is a
      rank-3 array whose first access is the use case, second the
      increment, and third the test case number. Test cases are
      represented as input to the <function>⎕FIX</function> function.
      The coverage test cases are located in the
      <varname>CTests</varname> variable in the same workspace. This
      is a vector whose elements correspond to the test suites for
      coverage testing for each increment. Each element is a vector of
      tests where each test matches the format used for the
      Statistical test cases. 
    </simpara>
    <simpara>
      For each Increment, these test cases are generated using the
      following functions. The
      <function>Generate.Distribution</function> function generates
      the statistical test cases based off a model. The
      <function>Generate.Coverage</function> function generate the
      coverage tests based on a coverage model, which is the same as a
      distribution model except that it also has states in the set of
      data. See the <filename>Generate.dyalog</filename> namespace
      script for details about how these files work. Similarly, the
      models are generated by the functions
      <function>DModel</function> and <function>CModel</function> in
      the <classname>Generate</classname> namespace script. These are
      the correct functions to use to obtain valid models for input
      into either of the test generating functions.
    </simpara>
    <simpara>
      The generators for the test cases generate sequences for each
      test, and these must be expanded into real test cases. The
      function <function>Stimuli.Expand</function> found in the
      <classname>Stimuli</classname> namespace script serves this
      purpose, and expands a single sequence. See the
      <filename>Stimuli.dyalog</filename> script for the details on
      how to correctly invoke the <function>Expand</function>
      function. 
    </simpara>
    <simpara>
      Generally speaking, anyone who is working on generating the test
      cases or working with testing of the compiler should examine the
      two namespace mentioned above in their script form. While not
      documented explicitly here, they are fairly short and represent
      the set of utilities that serve the primary purpose of
      manipulating tests and test cases, including, mostly, their
      generation. 
    </simpara>
  </section>
</article>
