<?xml version="1.0" encoding="utf-8" ?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Performance Improvement Plan</title>
  </info>
  <section>
    <title>Evaluation 1 (2014-12-03): Examining and re-entering Cleanroom Process</title>
    <para>
      Prior to this the Cleanroom process was abandoned due to insufficient quality 
      metrics and several difficulties identified through the process, as follows:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Difficulty of specifying compiler using suitable and efficient specification 
          techniques that created a net benefit compared to comparable methods
        </para>
      </listitem>
      <listitem>
        <para>
          Difficulty in verifying the APL code written against the black-box specification
        </para>
      </listitem>
      <listitem>
        <para>
          Difficulty in predicting the time to implement, resulting in schedule slippage
        </para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Compiler Specification</title>
      <para>
        After analysis and reflection on these results, it becomes clear that the primary
        issue with specification of the compiler rests with an insufficient understanding of
        sequence based enumeration. In particular, it is impossible to use sequence-based
        enumeration to adequately specify a compiler without exposing some of the
        compiler architecture in the specification.
      </para>
      <para>
        However, it appears that if the specification is broken into a series of nano-passes 
        in the nanopass style, that the compiler can be properly specified with all relevant 
        features coming to the front and hiding irrelevant details. This in fact results in 
        a suitable specification, without going into too much architectural detail. There will 
        of necessity be an overlap between the <citetitle>Software Architecture</citetitle>
        and the <citetitle>Function Specification</citetitle> because the implementation of 
        a nanopass style compiler will match the divisions created in the 
        <citetitle>Function Specification</citetitle> but it is probably okay to have this 
        exposure.
      </para>
    </section>
    <section>
      <title>Verification Difficulty</title>
      <para>
        Analysis of the difficulty of verification of the APL code created during implementation 
        shows that too much of a leap from the Black-box specification to the APL code was 
        attempted, with the frame of the code deviating too much to make direct proof 
        easy. 
      </para>
      <para>
        To fix this, it is proposed that an initial implementation done in the traditional 
        box-structured style be used first, followed by a careful analysis of data dependencies 
        and a possible additional implementation that can be compared for functional equivalence 
        after the first implementation is tested. Since the technology is not ready yet for 
        this to be done reliably, it is proposed that no clever APL implementation be used for 
        the moment, but instead to focus on a direct translation until such time as they can 
        be carefully understood.
      </para>
    </section>
    <section>
      <title>Schedule Slippage</title>
      <para>
        Almost all of the schedule slippage can be attributed to the time it took to fix bugs 
        in the testing of the code, in finding the bugs, and in tracing back the cause of the 
        bugs' introduction. Adjusting the above problems should ensure that this slippage is 
        easier to control, as the specification will be at the required detail to enable 
        verification and the implementation will be verifiable, making the code much 
        more reliable and testing easier. 
      </para>
    </section>
  </section>
</chapter>
