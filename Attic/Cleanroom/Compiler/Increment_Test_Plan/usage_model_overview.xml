<section xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Usage Model Overview</title>
  <simpara>
    The <filename>Certification.dws</filename> workspace contains
    the usage models documented here. The namespace
    <classname>UsageModels</classname> inside of the
    <filename>Certification.dws</filename> workspace contains the
    actual usage models. There are four usage models which
    correspond to the four general sequence enumerations in the
    <citetitle>Function Specification</citetitle>.  The
    <citetitle>Usage Specification</citetitle> diagrams and
    roughly estimates the basic structure and outline of each of
    these usage models.
  </simpara>
  <xi:include href="tables/usage_models_recursions.xml" />
  <simpara>
    While the <citetitle>Usage Specification</citetitle> details a
    number of users and use cases, the most prominent case
    represents that of the tweaker who works on existing code
    bases and alters them for efficiency. This matches relatively
    well to the distribution of code in the wild right now. This
    is the use case that we will test against, as it has the
    greatest impact, and also is the most effective for
    testing. While we could test more than this, the benefit does
    not currently justify the costs of additional testing.
  </simpara>
  <xi:include href="tables/use_cases.xml" />
  <simpara>
    While we will not test all of the use cases, we still want to
    allow for adequate specification of these other use cases in
    the case where we would like to run specific tests. Each usage
    model is therefore a set of Markov Models representing the
    distribution of the system. The states in the model are taken
    from the Canonical Analysis in the <citetitle>Function
    Specification</citetitle> while the transitions correspond to
    some possible stimuli at the level of that model. The models
    are only over the stimuli that are in their stimuli sets as
    defined in the <citetitle>Function Specification</citetitle>.
  </simpara>
  <xi:include href="tables/stimuli_set_ids.xml" />
  <simpara>
    Traversing a Markov Model corresponds to a specific Sequence
    History that maps to a given behavior of the system and a
    specific usage case or test. These traversals are defined by
    probabilities assigned to each transition, which correspond to
    the probabilities of encountering the stimuli that corresponds
    to the transition.
  </simpara>
  <simpara>
    This design leads to the following choice of structure for a
    specific usage model. Each usage model is a rank 5 array,
    whose first dimension corresponds to the specific use
    case. The second dimension corresponds to the state in the
    graph, and the third to a specific stimuli in the stimuli set
    of the model. The fourth dimension is the Increment to be
    tested in Index Origin 0.  The fifth dimsension corresponds to
    the probability of the transition.  This structure is
    summarized by the following synopsis, which is an expression
    for assigning model <varname>M</varname> a new transition
    probability <varname>Prob</varname> along the edge that
    corresponds to <varname>Stimuli</varname> for the use case
    <varname>UseCase</varname>.
  </simpara>
  <synopsis>M[UseCase;State;Stimuli;Increment] ← Prob</synopsis>
  <simpara>
    Those interested in the enumeration of the states should see
    the <citetitle>Function Specification</citetitle> canonical
    analysis tables, which enumerate the state space of the
    recursions.
  </simpara>
  <simpara>
    Together with the Usage Models, which describe the
    probabilities of transitions, some definition of the graph
    must exist. The <citetitle>Function Specification</citetitle>
    already defines these graphs in their totality, and they are
    partially described implicitly by the usage models. However,
    the usage models do not explicitly specify the targets of each
    edge in a model. These targets do not change across increments
    or use cases, but a traditional adjacency matrix does not
    suffice, since it is possible to have more than one edge going
    to the same target. We define a target description for each
    model.
  </simpara>
  <xi:include href="tables/target_descriptions.xml" />
  <simpara>
    Each target description is represented as a matrix whose first
    dimension is the state space of the model, and whose second
    dimension represents the stimuli set of the model. Thus, the
    following synopsis describes the association of a target state
    <varname>Target</varname> with a origin state
    <varname>State</varname> and an edge corresponding to a
    stimuli in the appropriate stimuli set
    <varname>Stimuli</varname> for the given target description
    <varname>T</varname>.
  </simpara>
  <synopsis>T[State;Stimuli] ← Target</synopsis>
  <simpara>
    To make it easier to manage the stimuli sets, a
    <classname>Stimuli</classname> namespace inside of the
    <filename>Certification.dws</filename> workspace holds the
    stimuli sets for each of the models, represented using their
    canonical ordering as a vector of strings.
  </simpara>
  <xi:include href="tables/stimuli_sets.xml" />
  <simpara>
    In a similiar vein, the <classname>States</classname>
    namespace provides an association between the canonical
    sequences and the state enumeration used in the usage
    models. This makes it easier to identify the given states by
    their canonical sequence rather than by their ID, which is, of
    course, too hard to remember for mere mortals.
  </simpara>
  <xi:include href="tables/state_spaces.xml" />
</section>
